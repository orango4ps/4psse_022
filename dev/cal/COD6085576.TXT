OBJECT Codeunit 6085576 Capture Management
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=DCW13.70.00.5.00.07;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      WordFunc@1000000002 : Codeunit 6085574;
      Text004@1000000004 : TextConst 'DEU=Automatisch erstellt;ENU=Automatically Created;NLD=Automatisch gemaakt;SVE=Automatiskt skapad';
      Text005@1000000005 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Feldregel berein.\\M”chten Sie die Feldregel in ''%1'' (%2) „ndern?;ENU=The value of the field does not match the current Field Rule.\\Do you wish to update the Field Rule to be ''%1'' (%2)?;NLD=De waarde van het veld komt niet overeen met de huidige veldregel.\\Wilt u de veldregel bijwerken tot ''%1'' (%2)?';
      Text006@1000000006 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Feldregel berein.\\M”chten Sie die Feldregel in ''%1''„ndern?;ENU=The value of the field does not match the current Field Rule.\\Do you wish to add the Field Rule to be ''%1''?;NLD=De waarde van het veld komt niet overeen met de huidige veldregel.\\Wilt u de veldregel bijwerken tot ''%1''?';
      Text007@161024012 : TextConst 'DEU=Lookup in diesem Feld ist nicht m”glich.;ENU=Lookup in this field is not possible.;NLD=Opzoeken is niet mogelijk in dit veld.';
      Text008@161024013 : TextConst 'DEU=T;ENU=T;NLD=H;NOR=T;SVE=t';
      Text009@161024014 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Konfiguration berein. Sie k”nnen die Konfiguration „ndern in:\\%1: %2\\Dann wird das Datum erkannt als ''%3'' (lokales Format).\\M”chten Sie diese Žnderung durchfhren?;ENU=The value of the field does not match the current setup. You can change the setup to:\\%1: %2\\This will recognize the date as ''%3'' (local format).\\Do you want to make this change?;NLD=De waarde van het veld komt niet overeen met de huidige instellingen. U kunt de instellingen wijzigen naar:\\%1: %2\\Zodat de datum wordt herkend als ''%3''.\\Wilt u deze wijziging doorvoeren?';
      Text010@161024016 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Konfiguration berein. Sie k”nnen die Konfiguration „ndern in:\\%1: %2 (%3)\\Dann wird das Datum erkannt als ''%4'' (lokales Format).\\M”chten Sie diese Žnderung durchfhren?;ENU=The value of the field does not match the current setup. You can change the setup to:\\%1: %2 (%3)\\This will recognize the date as ''%4'' (local format).\\Do you want to make this change?;NLD=De waarde van het veld komt niet overeen met de huidige instellingen. U kunt de instellingen wijzigen naar:\\%1: %2 (%3)\\Zodat de datum wordt herkend als ''%4''.\\Wilt u deze wijziging doorvoeren?';
      Text011@161024015 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Konfiguration berein. Sie k”nnen die Konfiguration „ndern in:\\%1: %2\%3: %4 (%5)\\Dann wird das Datum erkannt als ''%6'' (lokales Format).\\M”chten Sie diese Žnderung durchfhren?;ENU=The value of the field does not match the current setup. You can change the setup to:\\%1: %2\%3: %4 (%5)\\This will recognize the date as ''%6'' (local format).\\Do you want to make this change?;NLD=De waarde van het veld komt niet overeen met de huidige instellingen. U kunt de instellingen wijzigen naar:\\%1: %2\%3: %4 (%5)\\Zodat de datum wordt herkend als ''%6''.\\Wilt u deze wijziging doorvoeren?';
      Text013@161024018 : TextConst 'DEU=Der Wert des Feldes stimmt nicht mit der aktuellen Feldregel berein.\\M”chten Sie die aktuelle Regel berschreiben lassen, damit sie mit dem neuen Wert bereinstimmt?;ENU=The value of the field does not match the current Field Rule.\\Do you want to have the current rule overwritten so it matches the new value?;NLD=De waarde van het veld komt niet overeen met de huidige veldregel.\\Wilt u de huidige regel overschrijven, zodat deze overeenkomt met de nieuwe waarde?';

    PROCEDURE CaptureFromPos@1000000000(Page@1000000000 : Record 6085591;VAR Field@1000000016 : Record 6085580;LineNo@1000000013 : Integer;IsValue@1000000009 : Boolean;VAR Top@1000000008 : Integer;VAR Left@1000000007 : Integer;VAR Bottom@1000000006 : Integer;VAR Right@1000000005 : Integer;VAR Value@1000000010 : Record 6085593) : Text[1024];
    VAR
      Text@1000000001 : Text[1024];
      IsNew@1000000002 : Boolean;
    BEGIN
      Text := CaptureFromPos2(Page,Field,
        Field.Multiline AND IsValue, // Recognize multiline or not
        Field."Auto Update Field Width" OR NOT IsValue,
        Field."Auto Update Field Height" OR NOT IsValue,
        IsValue, // Apply Translations
        Top,Left,Bottom,Right);

      IF NOT Value.GET(Page."Document No.",IsValue,Field.Code,LineNo) THEN BEGIN
        Value.INIT;
        Value."Document No." := Page."Document No.";
        Value."Is Value" := IsValue;
        Value.Type := Field.Type;
        Value.Code := Field.Code;
        Value."Line No." := LineNo;
        IsNew := TRUE;
      END;

      Value."Template No." := Field."Template No.";
      Value."Page No." := Page."Page No.";

      Value.Top := Top;
      Value.Left := Left;
      Value.Bottom := Bottom;
      Value.Right := Right;

      IF IsValue THEN BEGIN
        IF IsNew THEN
          Value.INSERT
        ELSE
          Value.MODIFY;

        UpdateFieldValue(Page."Document No.",Page."Page No.",LineNo,Field,Text,FALSE,FALSE);

        EXIT(Text);
      END ELSE BEGIN
        IF IsNew THEN
          Value.INSERT
        ELSE
          Value.MODIFY;

        EXIT(Text);
      END;
    END;

    PROCEDURE CaptureFromPos2@1160040009(Page@1000000000 : Record 6085591;VAR Field@1000000016 : Record 6085580;IsMultiLine@1160040001 : Boolean;UpdateWidth@1000000009 : Boolean;UpdateHeight@1160040000 : Boolean;ApplyTranslations@1160040002 : Boolean;VAR Top@1000000008 : Integer;VAR Left@1000000007 : Integer;VAR Bottom@1000000006 : Integer;VAR Right@1000000005 : Integer) : Text[1024];
    VAR
      Words@1000000003 : TEMPORARY Record 6085592;
      MiddleWord@161024014 : Record 6085592;
      Text@1000000001 : Text[1024];
      Middle@161024012 : Integer;
      LowOffset@161024013 : Integer;
      NewTop@161024018 : Integer;
      NewLeft@161024017 : Integer;
      NewBottom@161024016 : Integer;
      NewRight@161024015 : Integer;
    BEGIN
      WordFunc.GetWordsInRegion(Page,Top,Left,Bottom,Right,Words);

      IF (Words.COUNT > 1) AND NOT IsMultiLine THEN BEGIN
        Middle := ROUND((Bottom - Top) / 2,1) + Top;
        LowOffset := -1;
        Words.FINDSET;
        REPEAT
          IF NOT (Words.Word IN ['ùï`']) THEN
            IF (Words.Word <> '.') AND (Words.Word <> ',') AND (Words.Word <> '''') AND (Words.Word <> '-') THEN
              IF (LowOffset = -1) OR (ABS((ROUND((Words.Bottom - Words.Top) / 2,1) + Words.Top) - Middle) < LowOffset) THEN BEGIN
                LowOffset := ABS((ROUND((Words.Bottom - Words.Top) / 2,1) + Words.Top) - Middle);
                MiddleWord := Words;
              END;
        UNTIL Words.NEXT = 0;

        Words.FINDSET(TRUE,FALSE);
        REPEAT
          IF NOT WordFunc.IsWordsOnSameLine(Words,MiddleWord) THEN
            Words.DELETE;
        UNTIL Words.NEXT = 0;
        Words.SETCURRENTKEY("Document No.","Page No.",Left);
      END;

      WordFunc.GetRectFromWords(Words,NewTop,NewLeft,NewBottom,NewRight);

      IF UpdateWidth THEN BEGIN
        Left := NewLeft;
        Right := NewRight;
      END ELSE BEGIN
        Left := IIFInt(NewLeft < Left,NewLeft,Left);
        Right := IIFInt(NewRight > Right,NewRight,Right);
      END;

      IF UpdateHeight THEN BEGIN
        Top := NewTop;
        Bottom := NewBottom;
      END ELSE BEGIN
        Top := IIFInt(NewTop < Top,NewTop,Top);
        Bottom := IIFInt(NewBottom > Bottom,NewBottom,Bottom);
      END;

      Text := WordFunc.CombineWords(Words);
      IF ApplyTranslations THEN
        Text := ApplyTranslationToWord(Field,Text);

      EXIT(Text);
    END;

    PROCEDURE UpdateFieldValue@1000000017(DocumentNo@1000000003 : Code[20];PageNo@161024014 : Integer;LineNo@1000000004 : Integer;VAR Field@1000000001 : Record 6085580;Word@1000000000 : Text[1024];Manual@1000000005 : Boolean;UpdatedByUser@1160040002 : Boolean);
    VAR
      Comment@161024012 : Record 6085594;
      Value@1000000002 : Record 6085593;
      xValue@1160040003 : Record 6085593;
      FieldRule@1000000007 : Record 6085583;
      RecIDMgt@1160040000 : Codeunit 6085604;
      ValidatedDate@161024013 : Date;
      IsNew@1000000006 : Boolean;
      Parsed@1160040001 : Boolean;
    BEGIN
      IF (NOT Value.GET(DocumentNo,TRUE,Field.Code,LineNo)) THEN BEGIN
        Value.INIT;
        Value."Document No." := DocumentNo;
        Value."Page No." := PageNo;
        Value."Is Value" := TRUE;
        Value."Template No." := Field."Template No.";
        Value.Type := Field.Type;
        Value.Code := Field.Code;
        Value."Line No." := LineNo;
        IsNew := TRUE;
        Value.INSERT(TRUE);
      END;

      IF Manual AND (Word = '') THEN BEGIN
        Value.Top := 0;
        Value.Left := 0;
        Value.Bottom := 0;
        Value.Right := 0;
      END;

      Value."Value (Text)" := COPYSTR(Word,1,MAXSTRLEN(Value."Value (Text)"));

      // Delete previous created rules while handling current document
      IF Value."Value (Text)" = '' THEN
        DeleteFieldRuleFromCreatedDoc(Field,DocumentNo);

      IF NOT Manual THEN BEGIN
        IF ParseField(Field,Word,FALSE,DocumentNo) THEN BEGIN
          CASE Field."Data Type" OF
            Field."Data Type"::Text:
              BEGIN
                Value."Is Valid" := ParseText(Field,Word,Value."Value (Text)",MAXSTRLEN(Value."Value (Text)"));
                IF Value."Is Valid" THEN
                  Value."Is Valid" := IsValidText(Field,Value."Value (Text)",DocumentNo);

                IF Field."Enable Rule Generation" AND UpdatedByUser THEN BEGIN
                  IF NOT Value."Is Valid" THEN
                    // Delete previous created rules while handling current document
                    DeleteFieldRuleFromCreatedDoc(Field,DocumentNo);

                  AutoCreateTextRule(DocumentNo,Word,Value."Is Valid",Field);
                  Value."Is Valid" := IsValidText(Field,Value."Value (Text)",DocumentNo);
                END;
              END;

            Field."Data Type"::Number:
              BEGIN
                Value."Is Valid" := ParseNumber(Field,Word,Value."Value (Decimal)");
                IF Value."Is Valid" THEN
                  Value."Is Valid" := IsValidNumber(Field,Value."Value (Decimal)");
              END;

            Field."Data Type"::Date:
              BEGIN
                Value."Is Valid" := ParseDate(Field,Word,Value."Value (Date)",DocumentNo);
                IF Value."Is Valid" THEN
                  Value."Is Valid" := IsValidDate(Field,Value."Value (Date)");
              END;

            Field."Data Type"::Lookup:
              BEGIN
                Value."Is Valid" := ParseLookup(Value,Field);
                IF Value."Is Valid" THEN
                  Value."Is Valid" := IsValidLookup(Field,
                    RecIDMgt.GetKeyValue(Value."Value (Record ID Tree ID)",Field."Source Field No."),DocumentNo);
              END;

            Field."Data Type"::Boolean:
              BEGIN
                Value."Is Valid" := ParseBoolean(Word,Value."Value (Boolean)");
                IF Value."Is Valid" THEN
                  Value."Is Valid" := IsValidBoolean(Field,Value."Value (Boolean)");
              END;
          END;
        END;
      END ELSE BEGIN
        Comment.SETCURRENTKEY("Document No.");
        Comment.SETRANGE("Document No.",DocumentNo);
        Comment.SETRANGE("Field Type",Field.Type);
        Comment.SETRANGE("Field Code",Field.Code);
        Comment.SETRANGE("Line No.",LineNo);
        Comment.DELETEALL(TRUE);

        CASE Field."Data Type" OF
          Field."Data Type"::Text:
            BEGIN
              Value."Is Valid" := ParseText(Field,Word,Value."Value (Text)",MAXSTRLEN(Value."Value (Text)"));
              IF Value."Is Valid" THEN
                Value."Is Valid" := IsValidText(Field,Value."Value (Text)",DocumentNo);

              IF Field."Enable Rule Generation" AND UpdatedByUser THEN BEGIN
                IF NOT Value."Is Valid" THEN
                  // Delete previous created rules while handling current document
                  DeleteFieldRuleFromCreatedDoc(Field,DocumentNo);

                AutoCreateTextRule(DocumentNo,Word,Value."Is Valid",Field);
                Value."Is Valid" := IsValidText(Field,Value."Value (Text)",DocumentNo);
              END;
            END;

          Field."Data Type"::Number:
            BEGIN
              IF Word = '' THEN
                Value."Value (Decimal)" := 0
              ELSE BEGIN
                IF (STRPOS(Word,GetDecSep) = 0) AND (STRPOS(Word,GetThousandSep) <> 1) AND NOT UpdatedByUser THEN
                  Parsed := EVALUATE(Value."Value (Decimal)",Replace(Word,GetThousandSep,GetDecSep,FALSE));

                IF NOT Parsed THEN
                  Parsed := EVALUATE(Value."Value (Decimal)",Word);
                IF NOT Parsed THEN
                  Value."Value (Decimal)" := CalcExpression(Word);
              END;
              Value."Value (Decimal)" := RoundFromDecPlaces(Value."Value (Decimal)",Field."Decimal Places");
              Value."Is Valid" := IsValidNumber(Field,Value."Value (Decimal)");
            END;

          Field."Data Type"::Date:
            BEGIN
              IF Word = '' THEN
                Value."Value (Date)" := 0D
              ELSE BEGIN
                IF UPPERCASE(Word) = Text008 THEN
                  ValidatedDate := TODAY;
                IF EVALUATE(ValidatedDate,Word) THEN
                  IF ValidatedDate < 17540101D THEN
                    ValidatedDate := 0D;
                Value."Value (Date)" := ValidatedDate;
              END;
              Value."Is Valid" := IsValidDate(Field,Value."Value (Date)");
              IF (NOT Value."Is Valid") AND (Word <> '') THEN BEGIN
                IF EVALUATE(ValidatedDate,DELCHR(Word,'=','-')) THEN
                  IF ValidatedDate < 17540101D THEN
                    ValidatedDate := 0D;
                Value."Value (Date)" := ValidatedDate;
                Value."Is Valid" := IsValidDate(Field,Value."Value (Date)");
              END;
            END;

          Field."Data Type"::Lookup:
            BEGIN
              Value."Is Valid" := ParseLookup(Value,Field);
              IF Value."Is Valid" THEN
                Value."Is Valid" := IsValidLookup(Field,
                  RecIDMgt.GetKeyValue(Value."Value (Record ID Tree ID)",Field."Source Field No."),DocumentNo);
            END;

          Field."Data Type"::Boolean:
            Value."Is Valid" := ParseBoolean(Word,Value."Value (Boolean)");
        END;
      END;

      Value.MODIFY(TRUE);
      xValue := Value;

      Value."Updated By User" := UpdatedByUser;

      IF (Field."Codeunit ID: Lookup" <> 0) THEN
        Value."Value (Lookup)" := COPYSTR(Value."Value (Text)",1,MAXSTRLEN(Value."Value (Lookup)"));

      IF Field."Codeunit ID: Validate" <> 0 THEN
        CODEUNIT.RUN(Field."Codeunit ID: Validate",Value);

      IF Value."Is Valid" AND (Field."Codeunit ID: Is OK" <> 0) THEN
        CODEUNIT.RUN(Field."Codeunit ID: Is OK",Value);

      Value."Updated By User" := FALSE;
      IF NOT Value.IsEqual(xValue) THEN
        Value.MODIFY(TRUE);

      IF (Field.Formula = '') THEN
        UpdateFormulaFields(DocumentNo,Field.Type,PageNo,LineNo,UpdatedByUser);
    END;

    PROCEDURE UpdateFieldCaption@1000000004(VAR Field@1000000001 : Record 6085580;PageNo@1002 : Integer;Top@1000 : Integer;Left@1001 : Integer;DPI@1160040000 : Integer;Word@1000000000 : Text[1024]);
    VAR
      Caption@1000000002 : Record 6085581;
    BEGIN
      IF NOT Field."Auto Update Caption" THEN
        EXIT;

      Caption.SETRANGE("Template No.",Field."Template No.");
      Caption.SETRANGE(Type,Field.Type);
      Caption.SETRANGE(Code,Field.Code);
      Caption.DELETEALL(TRUE);

      IF Word = '' THEN
        EXIT;

      Caption."Template No." := Field."Template No.";
      Caption.Type := Field.Type;
      Caption.Code := Field.Code;
      Caption."Entry No." := 1;
      Caption.Caption := Word;
      Caption."Page No." := PageNo;
      Caption.Top := Top;
      Caption.Left := Left;
      Caption.DPI := DPI;
      Caption.INSERT(TRUE);
    END;

    PROCEDURE UpdateCaptionOffset@1000000011(VAR Field@1000000000 : Record 6085580;DocumentNo@1000000001 : Code[20]);
    VAR
      Value@1000000002 : Record 6085593;
      Caption@1000000003 : Record 6085593;
      Page@1160040000 : Record 6085591;
    BEGIN
      IF NOT Value.GET(DocumentNo,TRUE,Field.Code) THEN
        EXIT;

      IF NOT Caption.GET(DocumentNo,FALSE,Field.Code) THEN
        EXIT;

      IF (Value.Top = 0) OR (Caption.Top = 0) OR (Value.Left = 0) OR (Caption.Left = 0) THEN
        EXIT;

      Page.GET(DocumentNo,Value."Page No.");
      Field."Caption Offset X" := Value.Left - Caption.Left;
      Field."Caption Offset Y" := Value.Top - Caption.Top;
      Field."Offset DPI" := Page."TIFF Image Resolution";
      Field.MODIFY(TRUE);
    END;

    LOCAL PROCEDURE UpdateFormulaFields@161024014(DocumentNo@161024012 : Code[20];FieldType@161024015 : Integer;PageNo@161024018 : Integer;LineNo@161024017 : Integer;UpdatedByUser@1160040001 : Boolean);
    VAR
      Document@161024013 : Record 6085590;
      Field@161024014 : Record 6085580;
      Formula@161024016 : Text[1024];
      DecValue@1160040000 : Decimal;
    BEGIN
      Document.GET(DocumentNo);
      Field.SETCURRENTKEY("Template No.",Type,"Sort Order");
      Field.SETRANGE("Template No.",Document."Template No.");
      Field.SETRANGE(Type,Field.Type::Header);
      Field.SETFILTER(Formula,'<>%1','');
      IF Field.FINDSET THEN
        REPEAT
          Formula := CalcFieldFormula(Document,Field,0);
          IF Field."Data Type" = Field."Data Type"::Number THEN BEGIN
            DecValue := CalcExpression(Formula);
            IF NOT (DecValue IN [-999999999999999.99..999999999999999.99]) THEN
              DecValue := 0;

            Formula := DELCHR(FORMAT(DecValue),'=',GetThousandSep);

            IF Field."Decimal Places" <> '' THEN BEGIN
              EVALUATE(DecValue,Formula);

              Formula := FORMAT(DecValue,0,STRSUBSTNO('<Precision,%1><Standard Format,0>',Field."Decimal Places"));
              IF STRPOS(Formula,GetDecSep) = 0 THEN
                Formula := Formula + GetDecSep + '00';

              UpdateFieldValue(Document."No.",PageNo,0,Field,Formula,TRUE,UpdatedByUser);
            END ELSE
              UpdateFieldValue(Document."No.",PageNo,0,Field,Formula,TRUE,UpdatedByUser);
          END ELSE BEGIN
            Formula := ApplyTranslationToWord(Field,Formula);
            UpdateFieldValue(Document."No.",PageNo,0,Field,Formula,TRUE,UpdatedByUser);
          END;
        UNTIL Field.NEXT = 0;

      IF LineNo = 0 THEN
        EXIT;

      Field.SETCURRENTKEY("Template No.",Type,"Sort Order");
      Field.SETRANGE("Template No.",Document."Template No.");
      Field.SETRANGE(Type,Field.Type::Line);
      Field.SETFILTER(Formula,'<>%1','');
      IF Field.FINDSET THEN
        REPEAT
          Formula := CalcFieldFormula(Document,Field,LineNo);

          IF Field."Data Type" = Field."Data Type"::Number THEN BEGIN
            DecValue := CalcExpression(Formula);
            IF NOT (DecValue IN [-999999999999999.99..999999999999999.99]) THEN
              DecValue := 0;
            Formula := FORMAT(DecValue);

            IF STRPOS(Formula,GetDecSep) = 0 THEN
              Formula := Formula + GetDecSep + '00';
          END;

          Formula := ApplyTranslationToWord(Field,Formula);

          UpdateFieldValue(Document."No.",PageNo,LineNo,Field,Formula,TRUE,UpdatedByUser);
        UNTIL Field.NEXT = 0;
    END;

    LOCAL PROCEDURE CalcFieldFormula@161024016(Document@161024016 : Record 6085590;CurrentField@161024012 : Record 6085580;LineNo@161024018 : Integer) Result : Text[1024];
    VAR
      Field@161024014 : Record 6085580;
      TemplField@161024015 : Record 6085580;
      Amount@161024017 : Decimal;
      FormulaParts@6085575 : ARRAY [100] OF Text[1024];
      ValidOperators@6085573 : Text[30];
      StartPos@6085576 : Integer;
      i@6085578 : Integer;
      j@6085577 : Integer;
    BEGIN
      Field.SETRANGE("Template No.",Document."Template No.");
      Field.SETFILTER(Code,'<>%1',CurrentField.Code);

      IF LineNo = 0 THEN
        Field.SETRANGE(Type,Field.Type::Header)
      ELSE
        Field.SETRANGE(Type,Field.Type::Line);

      IF CurrentField."Data Type" = CurrentField."Data Type"::Number THEN BEGIN
        ValidOperators := '+-*/^%()';
        Field.SETRANGE("Data Type",Field."Data Type"::Number);
      END ELSE
        ValidOperators := '+';

      // Split Formula into operators and fields / constants inbetween. Store in FormulaParts array
      StartPos := 1;
      IF CurrentField.Formula <> '' THEN BEGIN
        FOR i := 1 TO STRLEN(CurrentField.Formula) DO BEGIN
          IF STRPOS(ValidOperators,COPYSTR(CurrentField.Formula,i,1)) <> 0 THEN BEGIN
            IF i > 1 THEN BEGIN
              j := j + 1;
              FormulaParts[j] := COPYSTR(CurrentField.Formula,StartPos,(i - StartPos + 1) - 1);
            END;

            j := j + 1;
            FormulaParts[j] := COPYSTR(CurrentField.Formula,i,1);

            StartPos := i + 1;
          END;
        END;

        IF StartPos <= STRLEN(CurrentField.Formula) THEN BEGIN
          j := j + 1;
          FormulaParts[j] := COPYSTR(CurrentField.Formula,StartPos);
        END;
      END;

      // Loop thought FormulaParts array and replace field code with captured field value
      FOR i := 1 TO ARRAYLEN(FormulaParts) DO
        IF FormulaParts[i] <> '' THEN BEGIN
          // When operator stored in FormulaParts[i], only include operator in result when field is a number field as for text fields,
          // we concatenate when the plus operator is used (only + operator allowed for text fields)
          IF STRPOS(ValidOperators,FormulaParts[i]) <> 0 THEN BEGIN
            IF CurrentField."Data Type" = CurrentField."Data Type"::Number THEN
              Result := Result + FormulaParts[i]
          END ELSE BEGIN
            // A constant (and not a field code) is used when the text is larger than field code or no field is found
            IF STRLEN(FormulaParts[i]) > MAXSTRLEN(Field.Code) THEN
              Result := Result + FormulaParts[i]
            ELSE BEGIN
              Field.SETRANGE(Code,FormulaParts[i]);
              IF Field.FINDFIRST THEN BEGIN
                IF Field."Data Type" = Field."Data Type"::Number THEN BEGIN
                  Amount := GetDecimal(Document,Field.Type,Field.Code,LineNo);

                  // *********************************************************************************************************************
                  // FIND POTENTIAL AMOUNTS (FROM OTHER TEMPLATE FIELDS) TO BE SUBTRACTED
                  // *********************************************************************************************************************
                  TemplField.SETRANGE("Template No.",Document."Template No.");
                  TemplField.SETRANGE(Type,Field.Type);
                  TemplField.SETRANGE("Subtract from Amount Field",Field.Code);
                  IF TemplField.FINDSET THEN
                    REPEAT
                      Amount := Amount - GetDecimal(Document,TemplField.Type,TemplField.Code,LineNo);
                    UNTIL TemplField.NEXT = 0;

                    IF (CurrentField."Data Type" = CurrentField."Data Type"::Number) OR (Amount <> 0) OR
                      ((Amount = 0) AND (NOT Field."Blank Zero"))
                    THEN
                      Result := Result + FORMAT(Amount);
                END ELSE
                  Result := Result + GetValueAsText(Document."No.",LineNo,Field);
              END ELSE
                Result := Result + FormulaParts[i];
            END;
          END;
        END;
    END;

    LOCAL PROCEDURE CheckFieldExists@1160040008(TemplateNo@1160040000 : Code[20];FieldCode@1160040001 : Code[20];FieldDataType@1160040002 : Integer) : Boolean;
    VAR
      Field@1160040003 : Record 6085580;
    BEGIN
      Field.SETRANGE("Template No.",TemplateNo);
      Field.SETRANGE(Code,FieldCode);
      Field.SETRANGE("Data Type",FieldDataType);
      Field.FINDFIRST;
    END;

    PROCEDURE GetFieldValue@1000000021(Document@1000000001 : Record 6085590;Field@1000000002 : Record 6085580;LineNo@1000000003 : Integer;VAR Value@1000000000 : Record 6085593) : Boolean;
    BEGIN
      Value.SETRANGE("Document No.",Document."No.");
      Value.SETRANGE(Type,Field.Type);
      Value.SETRANGE(Code,Field.Code);
      Value.SETRANGE("Is Value",TRUE);
      Value.SETRANGE("Line No.",LineNo);
      EXIT(Value.FINDFIRST);
    END;

    LOCAL PROCEDURE ApplyTranslationToWord@1000000001(VAR Field@1000000001 : Record 6085580;Word@1000000000 : Text[1024]) : Text[1024];
    VAR
      FieldTransl@1000000002 : Record 6085582;
      Currency@161024013 : Record 4;
      TextToFind@161024012 : Text[250];
    BEGIN
      FieldTransl.SETRANGE("Template No.",Field."Template No.");
      FieldTransl.SETRANGE(Type,Field.Type);
      FieldTransl.SETRANGE(Code,Field.Code);
      IF FieldTransl.FINDSET THEN
        REPEAT
          IF FieldTransl."Translate From" = '' THEN
            FieldTransl."Translate From" := ' ';

          IF FieldTransl."Translate From" <> '*' THEN BEGIN
            CASE STRPOS(FieldTransl."Translate From",'*') OF
              1:
                BEGIN
                  TextToFind := COPYSTR(FieldTransl."Translate From",2);
                  IF STRPOS(Word,TextToFind) > 0 THEN
                    Word := FieldTransl."Translate To" + COPYSTR(Word,STRPOS(Word,TextToFind) + STRLEN(TextToFind));
                END;
              STRLEN(FieldTransl."Translate From"):
                BEGIN
                  TextToFind := COPYSTR(FieldTransl."Translate From",1,STRLEN(FieldTransl."Translate From") - 1);
                  IF STRPOS(Word,TextToFind) > 0 THEN
                    Word := COPYSTR(Word,1,STRPOS(Word,TextToFind) - 1) + FieldTransl."Translate To";
                END;
            END;
          END;

          Word := Replace(Word,FieldTransl."Translate From",FieldTransl."Translate To",FieldTransl."Case-sensitive");
        UNTIL FieldTransl.NEXT = 0;

      IF (Field."Data Type" = Field."Data Type"::Number) AND (TextContainsLetters(Word)) THEN BEGIN
        IF Currency.READPERMISSION THEN
          IF Currency.FINDSET THEN
            REPEAT
              Word := Replace(Word,Currency.Code,'',FALSE);
            UNTIL Currency.NEXT = 0;
      END;

      IF Field."Delete Blanks" THEN
        Word := DELCHR(Word,'=',' ');

      EXIT(DELCHR(Word,'<>',' '));
    END;

    PROCEDURE FindTemplateFromSearchWords@1000000022(VAR Document@1000000001 : Record 6085590;VAR Template@1000000003 : Record 6085579;PageNo@1160040000 : Integer;SearchMasters@161024017 : Boolean) : Boolean;
    VAR
      DocumentPage@1160040001 : Record 6085591;
      DocumentWord@1000000002 : Record 6085592;
      TemplSearchText@161024013 : Record 6085588;
      DocCat@161024018 : Record 6085575;
      BigString@1000000000 : Codeunit 6085587;
      BestTemplateNo@1160040003 : Code[20];
      Pos@1000000004 : Integer;
      BestPos@1000000005 : Integer;
      BestNoOfSearchTextFound@161024015 : Integer;
      NoOfSearchTextFound@161024016 : Integer;
      SkipTemplateSearch@1160040004 : Boolean;
      AllSearchTextFound@1160040002 : Boolean;
    BEGIN
      DocumentWord.SETCURRENTKEY("Document No.","Page No.",Top,Left);

      DocumentPage.SETRANGE("Document No.",Document."No.");
      IF PageNo > 0 THEN
        DocumentPage.SETRANGE("Page No.",PageNo);

      IF DocumentPage.FINDSET THEN BEGIN
        DocumentWord.SETRANGE("Document No.",Document."No.");

        REPEAT
          DocumentWord.SETRANGE("Page No.",DocumentPage."Page No.");
          IF DocumentWord.FINDSET THEN
            REPEAT
              BigString.Append(UPPERCASE(DELCHR(DocumentWord.Word,'=',' ,.-;:/\*+')));
            UNTIL DocumentWord.NEXT = 0;
        UNTIL DocumentPage.NEXT = 0;
      END;

      DocCat.GET(Document."Document Category Code");
      Template.SETCURRENTKEY("Category Code",Type);
      Template.SETRANGE("Category Code",Document."Document Category Code");
      IF SearchMasters THEN
        Template.SETRANGE(Type,Template.Type::Master)
      ELSE
        Template.SETRANGE(Type,Template.Type::" ");

      Template.SETFILTER("Search Text",'<>%1','');
      IF Template.FINDSET THEN
        REPEAT
          Template.MARK(TRUE);
          Pos := BigString.IndexOf(UPPERCASE(DELCHR(Template."Search Text",'=',' ,.-;:/\*+')));
          IF Pos <> -1 THEN BEGIN
            NoOfSearchTextFound := 1;
            AllSearchTextFound := TRUE;

            TemplSearchText.SETRANGE("Template No.",Template."No.");
            IF TemplSearchText.FINDSET THEN
              REPEAT
                IF BigString.IndexOf(UPPERCASE(DELCHR(TemplSearchText."Search Text",'=',' ,.-;:/\*+'))) <> -1 THEN
                  NoOfSearchTextFound := NoOfSearchTextFound + 1
                ELSE
                  AllSearchTextFound := FALSE;
              UNTIL (TemplSearchText.NEXT = 0) OR (NOT AllSearchTextFound);

            IF (NoOfSearchTextFound = 1) AND (BestNoOfSearchTextFound <= 1) THEN BEGIN
              // If only one word has been matched, then find the template with the search word closes to the begining of the page
              IF (Pos < BestPos) OR (BestPos = 0) THEN BEGIN
                BestTemplateNo := Template."No.";
                BestNoOfSearchTextFound := NoOfSearchTextFound;
                BestPos := Pos;
              END;
            END ELSE BEGIN
              IF AllSearchTextFound THEN
                IF NoOfSearchTextFound > BestNoOfSearchTextFound THEN BEGIN
                  BestTemplateNo := Template."No.";
                  BestNoOfSearchTextFound := NoOfSearchTextFound;
                END;
            END;
          END;
        UNTIL Template.NEXT = 0;

      TemplSearchText.SETRANGE("Template No.");
      IF TemplSearchText.FINDSET THEN
        REPEAT
          SkipTemplateSearch := FALSE;
          AllSearchTextFound := TRUE;

          Template.GET(TemplSearchText."Template No.");
          TemplSearchText.SETRANGE("Template No.",TemplSearchText."Template No.");

          IF Template.MARK OR (Document."Document Category Code" <> Template."Category Code") THEN
            SkipTemplateSearch := TRUE
          ELSE BEGIN
            IF SearchMasters THEN
              SkipTemplateSearch := Template.Type <> Template.Type::Master
            ELSE
              SkipTemplateSearch := Template.Type <> Template.Type::" ";
          END;

          IF NOT SkipTemplateSearch THEN BEGIN
            NoOfSearchTextFound := 0;

            REPEAT
              Pos := BigString.IndexOf(UPPERCASE(DELCHR(TemplSearchText."Search Text",'=',' ,.-;:/\*+')));
              IF Pos <> -1 THEN
                NoOfSearchTextFound := NoOfSearchTextFound + 1
              ELSE
                AllSearchTextFound := FALSE;
            UNTIL (TemplSearchText.NEXT = 0) OR (NOT AllSearchTextFound);

            IF AllSearchTextFound THEN
              IF (NoOfSearchTextFound = 1) AND (BestNoOfSearchTextFound <= 1) THEN BEGIN
                // If only one word has been matched, then find the template with the search word closes to the begining of the page
                IF (Pos < BestPos) OR (BestPos = 0) THEN BEGIN
                  BestTemplateNo := Template."No.";
                  BestNoOfSearchTextFound := NoOfSearchTextFound;
                  BestPos := Pos;
                END;
              END ELSE
                IF NoOfSearchTextFound > BestNoOfSearchTextFound THEN BEGIN
                  BestTemplateNo := Template."No.";
                  BestNoOfSearchTextFound := NoOfSearchTextFound;
                END;
          END;

          TemplSearchText.FINDLAST;
          TemplSearchText.SETRANGE("Template No.");
        UNTIL TemplSearchText.NEXT = 0;

      IF BestTemplateNo <> '' THEN
        Template.GET(BestTemplateNo)
      ELSE
        CLEAR(Template);

      EXIT(BestTemplateNo <> '');
    END;

    PROCEDURE ParseField@1000000002(VAR Field@1000000001 : Record 6085580;Word@1000000000 : Text[1024];ValidateValue@1000000006 : Boolean;DocumentNo@6085573 : Code[20]) IsValid : Boolean;
    VAR
      OutText@1000000002 : Text[1024];
      OutCode@1000000003 : Code[1024];
      OutDecimal@1000000004 : Decimal;
      OutDate@1000000005 : Date;
      OutBoolean@1160040000 : Boolean;
    BEGIN
      CASE Field."Data Type" OF
        Field."Data Type"::Text:
          BEGIN
            IsValid := ParseText(Field,Word,OutText,MAXSTRLEN(OutText)) AND ((OutText <> '') OR (NOT Field.Required));
            IF ValidateValue AND IsValid THEN
              IsValid := IsValidText(Field,OutText,DocumentNo);
          END;

        Field."Data Type"::Number:
          BEGIN
            IsValid := ParseNumber(Field,Word,OutDecimal);
            IF ValidateValue AND IsValid THEN
              IsValid := IsValidNumber(Field,OutDecimal);
          END;

        Field."Data Type"::Date:
          BEGIN
            IsValid := ParseDate(Field,Word,OutDate,DocumentNo) AND ((OutDate <> 0D) OR (NOT Field.Required));
            IF ValidateValue AND IsValid THEN
              IsValid := IsValidDate(Field,OutDate);
          END;

        Field."Data Type"::Lookup:
          BEGIN
            IsValid := ParseCode(Field,Word,OutCode,MAXSTRLEN(OutCode));
            IF ValidateValue AND IsValid AND (OutCode <> '') THEN
              IsValid := IsValidLookup(Field,Word,DocumentNo);
          END;

        Field."Data Type"::Boolean:
          BEGIN
            IsValid := ParseBoolean(Word,OutBoolean) OR (NOT Field.Required);
            IF ValidateValue AND IsValid THEN
              IsValid := IsValidBoolean(Field,OutBoolean);
          END;
      END;
    END;

    PROCEDURE ParseNumber@1000000008(VAR Field@1000000009 : Record 6085580;Text@1000000005 : Text[1024];VAR NewNumber@1000000007 : Decimal) : Boolean;
    VAR
      LeftSide@1000000000 : Text[30];
      RightSide@1000000001 : Text[30];
      NegNumber@1000000002 : Boolean;
      PassedDecPoint@1000000003 : Boolean;
      I@1000000004 : Integer;
      TempInt@1000000006 : Integer;
      TempDec@1000000008 : Decimal;
      NoWrongChars@6085573 : Boolean;
    BEGIN
      Text := DELCHR(Text,'=','$œ° ');

      IF Text = '' THEN BEGIN
        NewNumber := 0;
        EXIT(FALSE);
      END;

      REPEAT
        IF COPYSTR(Text,1,1) IN [',','.'] THEN
          Text := COPYSTR(Text,2)
        ELSE
          NoWrongChars := TRUE;
      UNTIL NoWrongChars OR (Text = '');

      NoWrongChars := FALSE;
      IF Text <> '' THEN
        REPEAT
          IF COPYSTR(Text,STRLEN(Text),1) IN [',','.'] THEN
            Text := COPYSTR(Text,1,STRLEN(Text)-1)
          ELSE
            NoWrongChars := TRUE;
        UNTIL NoWrongChars OR (Text = '');

      IF Text = '' THEN BEGIN
        NewNumber := 0;
        EXIT(FALSE);
      END;

      FOR I := 1 TO STRLEN(Text) DO BEGIN
        IF (Text[I] = '.') OR (Text[I] = ',') OR (Text[I] = '''') THEN BEGIN
          IF PassedDecPoint THEN BEGIN
            IF STRLEN(LeftSide + RightSide) > MAXSTRLEN(LeftSide) THEN
              EXIT;

            LeftSide := LeftSide + RightSide;
            RightSide := '';
          END;
          PassedDecPoint := TRUE;
        END ELSE
          IF (Text[I] = '-') THEN
            NegNumber := TRUE
          ELSE BEGIN
            IF EVALUATE(TempInt,FORMAT(Text[I])) THEN BEGIN
              IF (NOT PassedDecPoint) THEN
                LeftSide := COPYSTR(LeftSide + FORMAT(Text[I]),1,MAXSTRLEN(LeftSide))
              ELSE
                RightSide := COPYSTR(RightSide + FORMAT(Text[I]),1,MAXSTRLEN(RightSide));
            END ELSE
              EXIT(FALSE);
          END;
      END;

      IF ((LeftSide = '') AND (RightSide = '')) THEN
        EXIT(FALSE);

      IF EVALUATE(TempDec,LeftSide + GetDecSep + RightSide) THEN BEGIN
        IF NegNumber AND NOT Field."Make Absolute Number" THEN
          NewNumber := TempDec * -1
        ELSE
          NewNumber := TempDec;
        NewNumber := RoundFromDecPlaces(NewNumber,Field."Decimal Places");
        EXIT(TRUE);
      END;

      EXIT(FALSE);
    END;

    PROCEDURE ParseDate@1000000005(VAR Field@1000000002 : Record 6085580;Text@1000000001 : Text[1024];VAR NewDate@1000000000 : Date;DocumentNo@6085573 : Code[20]) : Boolean;
    VAR
      FieldRule@1000000008 : Record 6085583;
      Language@1000000003 : Record 8;
      DateParser@1000000007 : Codeunit 6085586;
      Text2@161024012 : Text[1024];
      ValidatedDate@161024013 : Date;
      LCID@1000000004 : Integer;
      i@161024014 : Integer;
    BEGIN
      FOR i := 1990 TO 2049 DO BEGIN
        Text := Replace(Text,COPYSTR(FORMAT(i),1,3) + ' ' + COPYSTR(FORMAT(i),4),FORMAT(i),FALSE);
        Text := Replace(Text,COPYSTR(FORMAT(i),1,1) + ' ' + COPYSTR(FORMAT(i),2),FORMAT(i),FALSE);

        IF i IN [2013..2049] THEN
          Text := Replace(Text,COPYSTR(FORMAT(i),1,2) + ' ' + COPYSTR(FORMAT(i),3),FORMAT(i),FALSE);
      END;

      NewDate := 0D;
      IF Text = '' THEN
        EXIT(FALSE);

      IF Language.GET(Field."Language Code") THEN
        LCID := Language."Windows Language ID";

      IF LCID = 0 THEN
        LCID := GLOBALLANGUAGE;

      FilterRule(Field,FieldRule);
      IF FieldRule.FINDSET(TRUE,FALSE) THEN BEGIN
        REPEAT
          IF FieldRule.Rule <> '' THEN BEGIN
            FieldRule.Rule := Replace(FieldRule.Rule,'D','d',TRUE);
            FieldRule.Rule := Replace(FieldRule.Rule,'m','M',TRUE);
            FieldRule.Rule := Replace(FieldRule.Rule,'Y','y',TRUE);
            Text2 := Text;
            IF (UPPERCASE(FieldRule.Rule) IN ['DMMYY','DMMYYYY','DDMMYY','DDMMYYYY']) THEN
              IF (STRLEN(Text2) = 5) OR (STRLEN(Text2) = 7) THEN
                Text2 := '0' + Text2;

            IF DateParser.ParseExact(Text2,LCID,FieldRule.Rule) THEN BEGIN
              IF DMY2DATE(DateParser.Day,DateParser.Month,DateParser.Year) >= 17540101D THEN BEGIN
                NewDate := DMY2DATE(DateParser.Day,DateParser.Month,DateParser.Year);

                IF Field."Enable Rule Generation" THEN BEGIN
                  ClearFldRuleCreatedFromMaster(FieldRule,DocumentNo);

                  // Several rules could have been copied from the master template. Delete these when a rule matches the found value
                  DelFldRulesCreatedFromMaster(FieldRule."Entry No.");

                  CLEAR(DateParser);
                  EXIT(TRUE);
                END;
              END;
            END;
          END;
        UNTIL FieldRule.NEXT = 0;

        CLEAR(DateParser);
      END;

      NewDate := ParseDate2(Field."Date Format",Text,LCID);

      IF NewDate < 17540101D THEN
        NewDate := 0D;

      IF NewDate <> 0D THEN
        EXIT(TRUE);
    END;

    LOCAL PROCEDURE ParseText@1000000007(VAR Field@1000000002 : Record 6085580;Text@1000000001 : Text[1024];VAR NewText@1000000000 : Text[1024];MaxLen@1000000004 : Integer) : Boolean;
    BEGIN
      NewText := COPYSTR(Text,1,MaxLen);
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE ParseCode@1000000033(VAR Field@1000000002 : Record 6085580;Text@1000000001 : Code[1024];VAR NewText@1000000000 : Code[1024];MaxLen@1000000004 : Integer) : Boolean;
    BEGIN
      NewText := COPYSTR(Text,1,MaxLen);
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE ParseDate2@1161054001(DateFormat@161024015 : Integer;DateText@161024014 : Text[1024];LCID@161024013 : Integer) : Date;
    VAR
      Date@161024012 : Record 2000000007;
      TemplField@161024016 : Record 6085580;
      DateParser@1161054010 : Codeunit 6085586;
      Separators@161024018 : ARRAY [10] OF Text[30];
      ActiveSeparator@1161054005 : Text[1];
      TextArray@1161054006 : ARRAY [100] OF Text[1024];
      SeparatorsCount@161024017 : ARRAY [10] OF Integer;
      TotalSeparatorsCount@161024019 : Integer;
      NoOfSplitters@161024020 : Integer;
      Catch@1161054008 : ARRAY [3] OF ' ,Day,Month,Year';
      CurrCatch@1161054009 : Integer;
      Day@1161054001 : Integer;
      Month@1161054002 : Integer;
      Year@1161054003 : Integer;
      i@1161054007 : Integer;
      i2@1161054011 : Integer;
    BEGIN
      Separators[1] := '-';
      Separators[2] := '/';
      Separators[3] := '.';
      Separators[4] := ',';
      Separators[5] := '\';
      Separators[6] := ' ';

      FOR i := 1 TO 6 DO BEGIN
        SeparatorsCount[i] := NoOfOccourance(DateText,Separators[i]);
        IF (SeparatorsCount[i] >= 2) AND (ActiveSeparator = '') THEN
          ActiveSeparator := Separators[i];
        TotalSeparatorsCount := TotalSeparatorsCount + SeparatorsCount[i];
      END;

      IF ActiveSeparator <> '' THEN BEGIN
        FOR i := 1 TO 6 DO
          IF Separators[i] <> ActiveSeparator THEN
            DateText := Replace(DateText,Separators[i],'',FALSE);
      END ELSE
        IF TotalSeparatorsCount = 2 THEN BEGIN
          FOR i := 1 TO 6 DO
            DateText := Replace(DateText,Separators[i],'-',FALSE);
          ActiveSeparator := '-';
        END;

      DateText := Replace(DateText,'  ','',FALSE);

      Split(DateText,ActiveSeparator,TextArray);
      IF TextArray[3] = '' THEN BEGIN
        ActiveSeparator := '';
        FOR i := 1 TO 6 DO
          DateText := Replace(DateText,Separators[i],'',FALSE);
        IF NOT EVALUATE(Day,DateText) THEN
          EXIT;

        Day := 0;
        IF NOT (STRLEN(DateText) IN [6,8]) THEN
          EXIT;
      END;

      CASE DateFormat OF
        TemplField."Date Format"::"Day / Month / Year":
          BEGIN
            Catch[1] := Catch::Day;
            Catch[2] := Catch::Month;
            Catch[3] := Catch::Year;

            IF ActiveSeparator = '' THEN BEGIN
              TextArray[1] := COPYSTR(DateText,1,2);
              TextArray[2] := COPYSTR(DateText,3,2);
              TextArray[3] := COPYSTR(DateText,5);
            END;
          END;

        TemplField."Date Format"::"Month / Day / Year":
          BEGIN
            Catch[1] := Catch::Month;
            Catch[2] := Catch::Day;
            Catch[3] := Catch::Year;

            IF ActiveSeparator = '' THEN BEGIN
              TextArray[1] := COPYSTR(DateText,1,2);
              TextArray[2] := COPYSTR(DateText,3,2);
              TextArray[3] := COPYSTR(DateText,5);
            END;
          END;

        TemplField."Date Format"::"Year / Day / Month":
          BEGIN
            Catch[1] := Catch::Year;
            Catch[2] := Catch::Day;
            Catch[3] := Catch::Month;

            IF ActiveSeparator = '' THEN BEGIN
              IF STRLEN(DateText) = 6 THEN BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,2);
                TextArray[3] := COPYSTR(DateText,5);
              END ELSE BEGIN
                TextArray[1] := COPYSTR(DateText,1,4);
                TextArray[2] := COPYSTR(DateText,5,2);
                TextArray[3] := COPYSTR(DateText,7);
              END;
            END;
          END;

        TemplField."Date Format"::"Year / Month / Day":
          BEGIN
            Catch[1] := Catch::Year;
            Catch[2] := Catch::Month;
            Catch[3] := Catch::Day;

            IF ActiveSeparator = '' THEN BEGIN
              IF STRLEN(DateText) = 6 THEN BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,2);
                TextArray[3] := COPYSTR(DateText,5);
              END ELSE BEGIN
                TextArray[1] := COPYSTR(DateText,1,4);
                TextArray[2] := COPYSTR(DateText,5,2);
                TextArray[3] := COPYSTR(DateText,7);
              END;
            END;
          END;

        TemplField."Date Format"::"Day / Year / Month":
          BEGIN
            Catch[1] := Catch::Day;
            Catch[2] := Catch::Year;
            Catch[3] := Catch::Month;

            IF ActiveSeparator = '' THEN BEGIN
              IF STRLEN(DateText) = 6 THEN BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,2);
                TextArray[3] := COPYSTR(DateText,5);
              END ELSE BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,4);
                TextArray[3] := COPYSTR(DateText,7);
              END;
            END;
          END;

        TemplField."Date Format"::"Month / Year / Day":
          BEGIN
            Catch[1] := Catch::Month;
            Catch[2] := Catch::Year;
            Catch[3] := Catch::Day;

            IF ActiveSeparator = '' THEN BEGIN
              IF STRLEN(DateText) = 6 THEN BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,2);
                TextArray[3] := COPYSTR(DateText,5);
              END ELSE BEGIN
                TextArray[1] := COPYSTR(DateText,1,2);
                TextArray[2] := COPYSTR(DateText,3,4);
                TextArray[3] := COPYSTR(DateText,7);
              END;
            END;
          END;
      END;

      i := 1;
      CurrCatch := 1;
      WHILE ((Day = 0) OR (Month = 0) OR (Year = 0)) AND (TextArray[i] <> '') AND (CurrCatch < 4) DO BEGIN
        CASE Catch[CurrCatch] OF
          Catch::Day:
            BEGIN
              IF EVALUATE(Day,TextArray[i]) THEN
                CurrCatch := CurrCatch + 1
              ELSE
                IF EVALUATE(Day,COPYSTR(TextArray[i],1,2)) THEN
                  CurrCatch := CurrCatch + 1
                ELSE
                  IF EVALUATE(Day,COPYSTR(TextArray[i],1,1)) THEN
                    CurrCatch := CurrCatch + 1
            END;

          Catch::Month:
            BEGIN
              IF EVALUATE(Month,TextArray[i]) THEN
                CurrCatch := CurrCatch + 1
              ELSE BEGIN
                IF (DateParser.ParseExact('01-' + TextArray[i] + '-' + FORMAT(DATE2DMY(TODAY,3)),LCID,'dd-MMMM-yyyy')) THEN BEGIN
                  Month := DateParser.Month;
                  CurrCatch := CurrCatch + 1;
                END ELSE
                  IF (DateParser.ParseExact('01-' + TextArray[i] + '-' +
                    FORMAT(DATE2DMY(TODAY,3)),LCID,'dd-MMM-yyyy'))
                  THEN BEGIN
                    Month := DateParser.Month;
                    CurrCatch := CurrCatch + 1;
                  END;
                CLEAR(DateParser);
              END;
            END;

          Catch::Year:
            BEGIN
              IF EVALUATE(Year,TextArray[i]) THEN BEGIN
                IF (STRLEN(FORMAT(Year)) = 1) OR (STRLEN(FORMAT(Year)) = 2) THEN
                  Year := Year + 2000;
                CurrCatch := CurrCatch + 1;
              END;
            END;
        END;

        i := i + 1;
      END;

      IF (Day IN [1..31]) AND (Month IN [1..12]) AND (Year IN [1754..9999]) THEN BEGIN
        Date.SETRANGE("Period Type",0);
        Date.SETRANGE("Period Start",DMY2DATE(1,Month,Year),CALCDATE('<CM>',DMY2DATE(1,Month,Year)));
        IF Date.FINDFIRST THEN BEGIN
          IF Day = 1 THEN
            EXIT(Date."Period Start")
          ELSE
            IF Date.NEXT(Day - 1) = Day - 1 THEN
              EXIT(Date."Period Start");
        END;
      END;
    END;

    PROCEDURE ParseBoolean@1160040012(Text@1000000001 : Text[1024];VAR NewBoolean@1000000000 : Boolean) : Boolean;
    BEGIN
      IF NOT EVALUATE(NewBoolean,Text) THEN
        IF UPPERCASE(Text) IN['TRUE','YES'] THEN
          NewBoolean := TRUE
        ELSE
          NewBoolean := FALSE;

      EXIT(TRUE);
    END;

    PROCEDURE TryUpdateFieldRuleFromMaster@1000000030(VAR Field@1000000001 : Record 6085580;Word@1000000000 : Text[1024];DocumentNo@6085573 : Code[20]) : Boolean;
    VAR
      Language@1000000002 : Record 8;
      FieldRule@1000000011 : Record 6085583;
      FieldRule2@6085575 : Record 6085583;
      Template@1000000006 : Record 6085579;
      MasterTemplate@1000000005 : Record 6085579;
      MasterField@1000000004 : Record 6085580;
      Field2@161024014 : Record 6085580;
      MasterFieldRule@1000000007 : Record 6085583;
      DateParser@1000000010 : Codeunit 6085586;
      NewDate@161024013 : Date;
      LCID@1000000003 : Integer;
      i@161024012 : Integer;
      NextEntryNo@6085574 : Integer;
      ValidRuleFound@1000000008 : Boolean;
    BEGIN
      IF Word = '' THEN
        EXIT;

      IF NOT Field."Enable Rule Generation" THEN
        EXIT(FALSE);

      IF Field."Data Type" <> Field."Data Type"::Date THEN
        EXIT(FALSE);

      IF Language.GET(Field."Language Code") THEN
        LCID := Language."Windows Language ID";

      IF LCID = 0 THEN
        LCID := GLOBALLANGUAGE;

      Template.GET(Field."Template No.");
      MasterTemplate.SETCURRENTKEY("Category Code",Type);
      MasterTemplate.SETRANGE("Category Code",Template."Category Code");
      MasterTemplate.SETRANGE(Type,MasterTemplate.Type::Master);
      IF MasterTemplate.FINDSET THEN
        REPEAT
          IF MasterField.GET(MasterTemplate."No.",Field.Type,Field.Code) THEN BEGIN
            MasterFieldRule.SETRANGE("Template No.",MasterField."Template No.");
            MasterFieldRule.SETRANGE(Type,MasterField.Type);
            MasterFieldRule.SETRANGE(Code,MasterField.Code);
            IF MasterFieldRule.FINDSET THEN
              REPEAT
                ValidRuleFound := DateParser.ParseExact(Word,LCID,MasterFieldRule.Rule);

                IF ValidRuleFound THEN BEGIN
                  IF CONFIRM(STRSUBSTNO(Text005,MasterFieldRule.Rule,MasterFieldRule.Description),TRUE) THEN BEGIN
                    DeleteFieldRuleFromCreatedDoc(Field,DocumentNo);

                    FieldRule := MasterFieldRule;
                    FieldRule."Template No." := Template."No.";

                    FieldRule2.SETRANGE("Template No.",Field."Template No.");
                    FieldRule2.SETRANGE(Type,Field.Type);
                    FieldRule2.SETRANGE(Code,Field.Code);
                    IF FieldRule2.FINDLAST THEN
                      NextEntryNo := FieldRule2."Entry No." + 10000
                    ELSE
                      NextEntryNo := 10000;

                    FieldRule."Entry No." := NextEntryNo;
                    FieldRule."Document No." := DocumentNo;
                    FieldRule.INSERT(TRUE);

                    EXIT(TRUE);
                  END;
                END;
              UNTIL MasterFieldRule.NEXT = 0;
          END;
        UNTIL MasterTemplate.NEXT = 0;

      FOR i := 1 TO 6 DO BEGIN
        NewDate := ParseDate2(i,Word,LCID);
        IF NewDate <> 0D THEN BEGIN
          Field2."Date Format" := i;
          IF CONFIRM(Text009,TRUE,Field2.FIELDCAPTION("Date Format"),Field2."Date Format",NewDate) THEN BEGIN
            Field."Date Format" := i;
            Field.MODIFY;

            IF Field.Type = Field.Type::Header THEN BEGIN
              Field2.SETRANGE("Template No.",Template."No.");
              Field2.SETRANGE("Data Type",Field2."Data Type"::Date);
              Field2.SETFILTER("Sort Order",'>%1',Field."Sort Order");
              Field2.MODIFYALL("Date Format",Field."Date Format");
            END;
            EXIT(TRUE);
          END ELSE
            EXIT;
        END;
      END;

      Language.SETFILTER("Windows Language ID",'>%1',0);
      IF Language.FINDSET THEN
        REPEAT
          NewDate := ParseDate2(Field."Date Format",Word,Language."Windows Language ID");

          IF NewDate <> 0D THEN BEGIN
            IF CONFIRM(Text010,TRUE,Field2.FIELDCAPTION("Language Code"),Language.Code,Language.Name,NewDate) THEN BEGIN
              IF Field.Type = Field.Type::Header THEN BEGIN
                Template.GET(Field."Template No.");
                Template."Language Code" := Language.Code;
                Template.MODIFY;

                Field2.SETRANGE("Template No.",Template."No.");
                IF Field2.FINDSET(TRUE,FALSE) THEN
                  REPEAT
                    IF NOT ((Field2.Type = Field.Type) AND (Field2.Code = Field.Code)) THEN BEGIN
                      Field2."Language Code" := Language.Code;
                      Field2.MODIFY;
                    END;
                  UNTIL Field2.NEXT = 0;
              END;

              Field."Language Code" := Language.Code;
              Field.MODIFY;
              EXIT(TRUE);
            END ELSE
              EXIT;
          END;
        UNTIL Language.NEXT = 0;

      FOR i := 1 TO 6 DO BEGIN
        Language.SETFILTER("Windows Language ID",'>%1',0);
        IF Language.FINDSET THEN
          REPEAT
            NewDate := ParseDate2(i,Word,Language."Windows Language ID");

            IF NewDate <> 0D THEN BEGIN
              Field2."Date Format" := i;
              IF CONFIRM(Text011,TRUE,Field2.FIELDCAPTION("Date Format"),Field2."Date Format",
                Field2.FIELDCAPTION("Language Code"),Language.Code,Language.Name,NewDate)
              THEN BEGIN
                IF Field.Type = Field.Type::Header THEN BEGIN
                  Template.GET(Field."Template No.");
                  Template."Language Code" := Language.Code;
                  Template.MODIFY;

                  Field2.SETRANGE("Template No.",Template."No.");
                  IF Field2.FINDSET(TRUE,FALSE) THEN
                    REPEAT
                      IF NOT ((Field2.Type = Field.Type) AND (Field2.Code = Field.Code)) THEN BEGIN
                        IF Field2."Sort Order" > Field."Sort Order" THEN
                          Field2."Date Format" := i;
                        Field2."Language Code" := Language.Code;
                        Field2.MODIFY;
                      END;
                    UNTIL Field2.NEXT = 0;
                END;

                Field."Date Format" := i;
                Field."Language Code" := Language.Code;
                Field.MODIFY;
                EXIT(TRUE);
              END ELSE
                EXIT;
            END;
          UNTIL Language.NEXT = 0;
      END;

      EXIT(FALSE);
    END;

    LOCAL PROCEDURE IsValidNumber@6085574(VAR Field@6085575 : Record 6085580;Number@6085574 : Decimal) : Boolean;
    VAR
      FieldRule@6085576 : Record 6085583;
      TempTemplateField@6085573 : TEMPORARY Record 6085580;
    BEGIN
      IF Field."Codeunit ID: Capture Value" <> 0 THEN
        EXIT(TestCaptureValue(Field,FieldRule,FORMAT(Number)));

      IF (Number = 0) AND Field.Required THEN
        EXIT(FALSE);

      FilterRule(Field,FieldRule);

      TempTemplateField."Fixed Value (Decimal)" := Number;
      TempTemplateField.INSERT;

      IF FieldRule.FINDSET THEN
        REPEAT
          IF FieldRule.Rule <> '' THEN BEGIN
            TempTemplateField.SETFILTER("Fixed Value (Decimal)",FieldRule.Rule);
            IF TempTemplateField.ISEMPTY THEN
              EXIT(FALSE);
          END;
        UNTIL FieldRule.NEXT = 0;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE IsValidDate@1000000014(VAR Field@1000000001 : Record 6085580;Date@1000000000 : Date) : Boolean;
    VAR
      FieldRule@161024012 : Record 6085583;
    BEGIN
      IF Field."Codeunit ID: Capture Value" <> 0 THEN
        EXIT(TestCaptureValue(Field,FieldRule,FORMAT(Date)));

      IF (Date = 0D) THEN
        EXIT(NOT Field.Required);

      IF FORMAT(Field."Validation Dateformula From") <> '' THEN
        IF Date < CALCDATE(Field."Validation Dateformula From",TODAY) THEN
          EXIT(FALSE);

      IF FORMAT(Field."Validation Dateformula To") <> '' THEN
        IF Date > CALCDATE(Field."Validation Dateformula To",TODAY) THEN
          EXIT(FALSE);

      IF Date < 17540101D THEN
        EXIT(FALSE);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE IsValidText@1000000015(VAR Field@1000000001 : Record 6085580;Text@1000000000 : Text[1024];DocumentNo@6085573 : Code[20]) : Boolean;
    VAR
      FieldRule@1000000004 : Record 6085583;
      TempWord@161024012 : TEMPORARY Record 6085592;
      RegEx@1000000003 : Codeunit 6085585;
      IsValid@1000000002 : Boolean;
    BEGIN
      Text := UPPERCASE(Text);

      IF Field."Codeunit ID: Capture Value" <> 0 THEN
        IF TestCaptureValue(Field,FieldRule,Text) THEN
          EXIT(TRUE);

      FilterRule(Field,FieldRule);
      IF NOT FieldRule.FINDFIRST THEN
        EXIT((Text <> '') OR (NOT Field.Required));

      IF Text = '' THEN
        EXIT(NOT Field.Required);

      TempWord.Word := Text;
      TempWord.INSERT;

      REPEAT
        FieldRule.Rule := UPPERCASE(FieldRule.Rule);
        IF (STRPOS(FieldRule.Rule,'<') <> 0) OR
          (STRPOS(FieldRule.Rule,'>') <> 0) OR
          (STRPOS(FieldRule.Rule,'|') <> 0) OR
          (STRPOS(FieldRule.Rule,'*') <> 0) OR
          (STRPOS(FieldRule.Rule,'&') <> 0)
        THEN BEGIN
          TempWord.SETFILTER(Word,FieldRule.Rule);
          IsValid := NOT TempWord.ISEMPTY;
        END ELSE BEGIN
          IF (RegEx.MatchValue(Text,FieldRule.Rule,TRUE) = Text) THEN BEGIN
            IF Field."Codeunit ID: Capture Value" <> 0 THEN
              IsValid := TestCaptureValue(Field,FieldRule,Text)
            ELSE
              IsValid := TRUE;

            IF IsValid AND Field."Enable Rule Generation" THEN BEGIN
              ClearFldRuleCreatedFromMaster(FieldRule,DocumentNo);

              // Several rules could have been copied from the master template. Delete these when a rule matches the found value
              DelFldRulesCreatedFromMaster(FieldRule."Entry No.");
            END;
          END;
        END;
      UNTIL (FieldRule.NEXT = 0) OR (IsValid);

      EXIT(IsValid);
    END;

    LOCAL PROCEDURE IsValidLookup@1000000031(Field@1000000001 : Record 6085580;Value@1160040000 : Text[250];DocumentNo@6085573 : Code[20]) : Boolean;
    VAR
      RecIDMgt@1160040001 : Codeunit 6085604;
    BEGIN
      EXIT(IsValidText(Field,Value,DocumentNo));
    END;

    PROCEDURE IsValidValue@1000000019(VAR Field@1000000001 : Record 6085580;DocumentNo@1000000000 : Code[20];LineNo@1000000004 : Integer) : Boolean;
    VAR
      Value@1000000002 : Record 6085593;
    BEGIN
      IF NOT Value.GET(DocumentNo,TRUE,Field.Code,LineNo) THEN
        EXIT(NOT Field.Required);

      EXIT(Value."Is Valid");
    END;

    LOCAL PROCEDURE IsValidBoolean@1160040016(VAR Field@1000000001 : Record 6085580;Boolean@1000000000 : Boolean) : Boolean;
    VAR
      FieldRule@161024012 : Record 6085583;
    BEGIN
      EXIT(TRUE);
    END;

    PROCEDURE GetText@1000000026(VAR Document@1000000004 : Record 6085590;FieldType@1000000006 : Integer;FieldCode@1000000000 : Code[20];LineNo@1000000002 : Integer) : Text[1024];
    VAR
      Field@1000000001 : Record 6085580;
      Value@1000000005 : Record 6085593;
    BEGIN
      IF NOT Field.GET(Document."Template No.",FieldType,FieldCode) THEN
        EXIT;

      GetFieldValue(Document,Field,LineNo,Value);
      EXIT(Value."Value (Text)");
    END;

    PROCEDURE GetDate@1000000025(VAR Document@1000000004 : Record 6085590;FieldType@1000000006 : Integer;FieldCode@1000000000 : Code[20];LineNo@1000000002 : Integer) : Date;
    VAR
      Field@1000000001 : Record 6085580;
      Value@1000000005 : Record 6085593;
    BEGIN
      IF NOT Field.GET(Document."Template No.",FieldType,FieldCode) THEN
        EXIT;

      GetFieldValue(Document,Field,LineNo,Value);
      EXIT(Value."Value (Date)");
    END;

    PROCEDURE GetDecimal@1000000024(VAR Document@1000000004 : Record 6085590;FieldType@1000000006 : Integer;FieldCode@1000000000 : Code[20];LineNo@1000000002 : Integer) : Decimal;
    VAR
      Field@1000000001 : Record 6085580;
      Value@1000000005 : Record 6085593;
    BEGIN
      IF NOT Field.GET(Document."Template No.",FieldType,FieldCode) THEN
        EXIT;

      GetFieldValue(Document,Field,LineNo,Value);
      EXIT(Value."Value (Decimal)");
    END;

    PROCEDURE GetValueAsText@1000000018(DocumentNo@1000000003 : Code[20];LineNo@1000000001 : Integer;VAR Field@1000000000 : Record 6085580) : Text[1024];
    VAR
      Value@1000000002 : Record 6085593;
      RecIDMgt@1160040000 : Codeunit 6085604;
    BEGIN
      IF NOT Value.GET(DocumentNo,TRUE,Field.Code,LineNo) THEN
        EXIT;

      CASE Field."Data Type" OF
        Field."Data Type"::Text:
          EXIT(FORMAT(Value."Value (Text)"));

        Field."Data Type"::Number:
          CASE TRUE OF
            Field."Blank Zero" AND (Value."Value (Decimal)" = 0):
              EXIT('');

            Field."Decimal Places" <> '':
              EXIT(FORMAT(Value."Value (Decimal)",0,STRSUBSTNO('<Precision,%1><Standard Format,0>',Field."Decimal Places")));

            ELSE
              EXIT(FORMAT(Value."Value (Decimal)"));
          END;

        Field."Data Type"::Date:
          EXIT(FORMAT(Value."Value (Date)"));

        Field."Data Type"::Lookup:
          EXIT(RecIDMgt.GetKeyValue(Value."Value (Record ID Tree ID)",Field."Source Field No."));

        Field."Data Type"::Boolean:
          EXIT(FORMAT(Value."Value (Boolean)"));
      END;
    END;

    PROCEDURE OptionToInt@1160040002(TableNo@1160040000 : Integer;FieldNo@1160040001 : Integer;OptionAsText@1160040002 : Text[250]) : Integer;
    VAR
      RecRef@1160040003 : RecordRef;
      FieldRef@1160040004 : FieldRef;
      CapVal@1160040005 : ARRAY [100] OF Text[1024];
      i@1160040006 : Integer;
      OptionAsInt@1160040007 : Integer;
      ArraySize@1160040008 : Integer;
    BEGIN
      RecRef.OPEN(TableNo);
      FieldRef := RecRef.FIELD(FieldNo);
      ArraySize := Split(FieldRef.OPTIONCAPTION,',',CapVal);
      i := 1;

      REPEAT
        IF UPPERCASE(CapVal[i]) = UPPERCASE(OptionAsText) THEN
          EXIT(i-1);
        i := i + 1;
      UNTIL i = 100;

      i := 1;
      REPEAT
        IF COPYSTR(UPPERCASE(CapVal[i]),1,STRLEN(OptionAsText)) = UPPERCASE(OptionAsText) THEN
          EXIT(i-1);
        i := i + 1;
      UNTIL i = 100;

      IF EVALUATE(OptionAsInt,OptionAsText) THEN
        IF OptionAsInt >= ArraySize THEN
          EXIT(-2);

      EXIT(-1);
    END;

    PROCEDURE LookupValue@1000000010(DocumentNo@161024012 : Code[20];VAR Field@1000000001 : Record 6085580;LineNo@161024013 : Integer;Text@1000000000 : Text[1024]) : Text[1024];
    VAR
      Document@161024015 : Record 6085590;
      Value@161024014 : Record 6085593;
      TempLookupRecID@1160040000 : TEMPORARY Record 6085760;
      RecIDMgt@161024016 : Codeunit 6085604;
    BEGIN
      IF Field."Codeunit ID: Lookup" <> 0 THEN BEGIN
        IF Document.GET(DocumentNo) THEN;
        IF NOT GetFieldValue(Document,Field,LineNo,Value) THEN BEGIN
          Value."Template No." := Field."Template No.";
          Value."Document No." := DocumentNo;
          Value.Type := Field.Type;
          Value.Code := Field.Code;
          Value."Line No." := LineNo;
        END;
        CODEUNIT.RUN(Field."Codeunit ID: Lookup",Value);
        EXIT(Value."Value (Text)");
      END;

      IF Field."Source Table No." <> 0 THEN BEGIN
        TempLookupRecID."Table No." := Field."Source Table No.";
        TempLookupRecID."Record ID Tree ID" :=
          RecIDMgt.GetRecIDTreeID2(Field."Source Table No.",Field."Source Field No.",Field."Source Table Filter GUID",Text);

        IF TempLookupRecID."Record ID Tree ID" = 0 THEN
          TempLookupRecID."Record ID Tree ID" := Field."Fixed Value (Rec. ID Tree ID)";
        TempLookupRecID."Table Filter GUID" := Field."Source Table Filter GUID";

        TempLookupRecID."Document No." := DocumentNo;
        TempLookupRecID."Line No." := LineNo;

        CODEUNIT.RUN(CODEUNIT::"Record ID Lookup",TempLookupRecID);

        IF TempLookupRecID."Lookup Mode" = TempLookupRecID."Lookup Mode"::OK THEN
          EXIT(RecIDMgt.GetKeyValue(TempLookupRecID."Record ID Tree ID",Field."Source Field No."));
        EXIT;
      END;

      IF Field."Data Type" <> Field."Data Type"::Lookup THEN
        EXIT(Text);

      Field.TESTFIELD("Source Table No.");
    END;

    LOCAL PROCEDURE BuildTextRegExPattern@1000000012(Value@1000000001 : Text[1024]) Pattern : Text[1024];
    VAR
      RegEx@1000000000 : Codeunit 6085585;
    BEGIN
      Pattern := RegEx.BuildPattern(Value);
    END;

    LOCAL PROCEDURE GetDecSep@1000000009() : Text[1];
    BEGIN
      EXIT(COPYSTR(FORMAT(1.1),2,1));
    END;

    LOCAL PROCEDURE GetThousandSep@1160040003() : Text[1];
    BEGIN
      EXIT(COPYSTR(FORMAT(1000.1,0),2,1));
    END;

    PROCEDURE Replace@1000000003(Text@1000000000 : Text[1024];ReplaceTxt@1000000001 : Text[1024];ReplaceWithTxt@1000000002 : Text[1024];CaseSensitive@1160040000 : Boolean) : Text[1024];
    VAR
      ReplaceTxtLen@1000000003 : Integer;
      ReplaceWithTxtLen@1000000004 : Integer;
      i@1000000005 : Integer;
    BEGIN
      ReplaceTxtLen := STRLEN(ReplaceTxt);
      ReplaceWithTxtLen := STRLEN(ReplaceWithTxt);

      IF CaseSensitive THEN
        i := STRPOS(Text,ReplaceTxt)
      ELSE
        i := STRPOS(UPPERCASE(Text),UPPERCASE(ReplaceTxt));
      IF i <> 0 THEN BEGIN
        Text := COPYSTR(Text,1,i-1) +
          ReplaceWithTxt +
          COPYSTR(Text,i+ReplaceTxtLen);

        Text := COPYSTR(Text,1,i-1+ReplaceWithTxtLen) +
          Replace(
            COPYSTR(Text,i+ReplaceWithTxtLen),
            ReplaceTxt,
            ReplaceWithTxt,CaseSensitive);
      END;
      EXIT(Text);
    END;

    PROCEDURE Split@1000000006(Text@1000000000 : Text[1024];Splitter@1000000001 : Text[1];VAR TextArray@1000000002 : ARRAY [100] OF Text[1024]) ArraySize : Integer;
    VAR
      i@1000000004 : Integer;
      Index@1000000003 : Integer;
    BEGIN
      i := STRPOS(Text,Splitter);

      WHILE (i <> 0) AND (Index < 100) DO BEGIN
        Index := Index + 1;
        IF (i < MAXSTRLEN(TextArray[Index])) THEN
          TextArray[Index] := COPYSTR(Text,1,i-1)
        ELSE
          TextArray[Index] := COPYSTR(Text,1,MAXSTRLEN(TextArray[Index]));
        Text := COPYSTR(Text,i+1);
        i := STRPOS(Text,Splitter);
      END;
      TextArray[Index + 1] := Text;
      ArraySize := Index + 1;
    END;

    PROCEDURE FilterRule@1000000016(VAR Field@1000000000 : Record 6085580;VAR FieldRule@1000000001 : Record 6085583);
    BEGIN
      FieldRule.SETRANGE("Template No.",Field."Template No.");
      FieldRule.SETRANGE(Type,Field.Type);
      FieldRule.SETRANGE(Code,Field.Code);
      FieldRule.SETFILTER(Rule,'<>%1','');
    END;

    LOCAL PROCEDURE InitRule@1000000028(VAR Field@1000000001 : Record 6085580;VAR FieldRule@1000000000 : Record 6085583);
    BEGIN
      FieldRule.INIT;
      FieldRule."Template No." := Field."Template No.";
      FieldRule.Type := Field.Type;
      FieldRule.Code := Field.Code;
    END;

    LOCAL PROCEDURE CalcExpression@161024012(Expression@161024012 : Text[1024]) Result : Decimal;
    VAR
      Parantheses@161024013 : Integer;
      OperatorNo@161024015 : Integer;
      i@161024014 : Integer;
      LeftResult@161024016 : Decimal;
      RightResult@161024017 : Decimal;
      Operator@1160040000 : Char;
      SignFactor@1160040006 : Integer;
      Operators@1160040001 : Text[8];
      LeftOperand@1160040002 : Text[80];
      RightOperand@1160040003 : Text[80];
      IsExpression@1160040004 : Boolean;
      IsFilter@1160040005 : Boolean;
      IsSign@1160040007 : Boolean;
    BEGIN
      Result := 0;

      Expression := DELCHR(Expression,'<>',' ');

      IF STRLEN(Expression) > 0 THEN BEGIN
        Parantheses := 0;
        IsExpression := FALSE;
        Operators := '+-*/^%';
        OperatorNo := 1;

        REPEAT
          i := STRLEN(Expression);
          REPEAT
            IF Expression[i] = '(' THEN
              Parantheses := Parantheses + 1
            ELSE
              IF Expression[i] = ')' THEN
                Parantheses := Parantheses - 1;

            IF (Parantheses = 0) AND (Expression[i] = Operators[OperatorNo]) THEN BEGIN
              SignFactor := +1;
              IsSign := FALSE;

              // CHECK IF THIS IS JUST A SIGN
              IF i > 1 THEN BEGIN
                IF Expression[i] IN ['-','+'] THEN BEGIN
                  IF STRPOS(Operators,FORMAT(Expression[i-1])) > 0 THEN BEGIN
                    IF Expression[i] = '-' THEN
                      SignFactor := -1
                    ELSE
                      SignFactor := +1;
                    IsSign := TRUE;
                  END;
                END;
              END;

              IF IsSign THEN
                i := i - 1
              ELSE
                IsExpression := TRUE
            END ELSE
              i := i - 1;
          UNTIL IsExpression OR (i <= 0);

          IF NOT IsExpression THEN
            OperatorNo := OperatorNo + 1;
        UNTIL (OperatorNo > STRLEN(Operators)) OR IsExpression;

        IF IsExpression THEN BEGIN
          IF i > 1 THEN
            LeftOperand := COPYSTR(Expression,1,i - 1)
          ELSE
            LeftOperand := '';

          IF i < STRLEN(Expression) THEN
            RightOperand := COPYSTR(Expression,i+1)
          ELSE
            RightOperand := '';

          LeftResult := CalcExpression(LeftOperand);

          Operator := Expression[i];

          IF (RightOperand = '') AND (Operator = '%') THEN
            RightResult := CalcExpression(LeftOperand)
          ELSE
            RightResult := CalcExpression(RightOperand);

          CASE Operator OF
            '^':
              Result := POWER(LeftResult,RightResult);
            '%':
              IF RightResult = 0 THEN
                Result := 0
              ELSE
                Result := 100 * LeftResult / (RightResult * SignFactor);
            '*':
              Result := LeftResult * (RightResult * SignFactor);
            '/':
              IF RightResult = 0 THEN
                Result := 0
              ELSE
                Result := LeftResult / (RightResult * SignFactor);
            '+':
              Result := LeftResult + (RightResult * SignFactor);
            '-':
              Result := LeftResult - (RightResult * SignFactor);
          END;
        END ELSE BEGIN
          IF (Expression[1] = '(') AND (Expression[STRLEN(Expression)] = ')') THEN
            Result := CalcExpression(COPYSTR(Expression,2,STRLEN(Expression) - 2))
          ELSE BEGIN
            IsFilter :=
               (STRPOS(Expression,'..') +
                STRPOS(Expression,'|') +
                STRPOS(Expression,'<') +
                STRPOS(Expression,'>') +
                STRPOS(Expression,'&') +
                STRPOS(Expression,'=') > 0);

            Expression := DELCHR(Expression,'=',GetThousandSep);
            IF NOT IsFilter THEN
              IF NOT EVALUATE(Result,Expression) THEN
                EXIT(0);
          END;
        END;
      END;

      EXIT(Result);
    END;

    PROCEDURE ValidateNumberFormula@1160040006(TemplateNo@1160040003 : Code[20];Formula@161024012 : Text[1024]);
    VAR
      Field@1160040002 : Record 6085580;
      Pos@1160040001 : Integer;
      FormulaLength@1160040004 : Integer;
      TempDec@1160040005 : Decimal;
      FormulaPart@1160040000 : Text[250];
    BEGIN
      Formula := DELCHR(Formula,'=',' ');
      FormulaLength := STRLEN(Formula);

      FOR Pos := 1 TO FormulaLength DO
        IF Formula[Pos] IN ['(',')'] THEN BEGIN
          IF FormulaPart <> '' THEN BEGIN
            IF NOT EVALUATE(TempDec,FormulaPart) THEN
              CheckFieldExists(TemplateNo,FormulaPart,Field."Data Type"::Number);

            FormulaPart := '';
          END;
        END ELSE
          IF Formula[Pos] IN ['+','-','*','/','^','%'] THEN BEGIN
            IF NOT (Pos > 1) OR NOT (Pos < FormulaLength) THEN
              CheckFieldExists(TemplateNo,COPYSTR(Formula,Pos,1),Field."Data Type"::Number);

            IF FormulaPart <> '' THEN BEGIN
              IF NOT EVALUATE(TempDec,FormulaPart) THEN
                CheckFieldExists(TemplateNo,FormulaPart,Field."Data Type"::Number);

              FormulaPart := '';
            END;
          END ELSE
            FormulaPart := FormulaPart + COPYSTR(Formula,Pos,1);

      IF NOT EVALUATE(TempDec,FormulaPart) THEN
        IF FormulaPart <> '' THEN
          CheckFieldExists(TemplateNo,FormulaPart,Field."Data Type"::Number);
    END;

    LOCAL PROCEDURE TextContainsLetters@161024015(Text@161024012 : Text[1024]) : Boolean;
    VAR
      i@161024013 : Integer;
    BEGIN
      Text := UPPERCASE(Text);
      FOR i := 1 TO STRLEN(Text) DO
        IF (COPYSTR(Text,i,1) IN ['A'..'Z']) THEN
          EXIT(TRUE);
    END;

    LOCAL PROCEDURE TestCaptureValue@161024017(Field@161024012 : Record 6085580;Rule@161024013 : Record 6085583;Value@161024014 : Text[1024]) : Boolean;
    VAR
      TempCaptureFieldVal@161024015 : Record 6085597;
    BEGIN
      TempCaptureFieldVal."Field Type" := Field.Type;
      TempCaptureFieldVal."Field Code" := Field.Code;
      TempCaptureFieldVal."File Rule Entry No." := Rule."Entry No.";
      TempCaptureFieldVal.Rule := Rule.Rule;
      TempCaptureFieldVal.Value := Value;
      CODEUNIT.RUN(Field."Codeunit ID: Capture Value",TempCaptureFieldVal);
      EXIT(TempCaptureFieldVal."Is Valid");
    END;

    PROCEDURE NoOfOccourance@1161054000(Text@1161054000 : Text[1024];CharToCount@1161054001 : Text[1]) NoOfOccour : Integer;
    VAR
      TextArray@1161054002 : ARRAY [100] OF Text[1024];
    BEGIN
      Split(Text,CharToCount,TextArray);
      WHILE TextArray[NoOfOccour + 1] <> '' DO
        NoOfOccour := NoOfOccour + 1;

      IF NoOfOccour > 0 THEN
        NoOfOccour := NoOfOccour - 1;
    END;

    LOCAL PROCEDURE IIFInt@161024018(TestValue@1000000000 : Boolean;ValueIfTrue@1000000001 : Integer;ValueIfFalse@1000000002 : Integer) : Decimal;
    BEGIN
      IF TestValue THEN
        EXIT(ValueIfTrue)
      ELSE
        EXIT(ValueIfFalse);
    END;

    LOCAL PROCEDURE ParseLookup@1160040000(VAR Value@1160040000 : Record 6085593;Field@1160040002 : Record 6085580) : Boolean;
    VAR
      LookupRecID@1160040003 : Record 6085760;
      RecIDMgt@1160040001 : Codeunit 6085604;
    BEGIN
      Value."Value (Record ID Tree ID)" := 0;

      IF  Field."Source Table No." > 0 THEN BEGIN
        LookupRecID."Table No." := Field."Source Table No.";
        LookupRecID."Record ID Tree ID" := RecIDMgt.GetRecIDTreeID2(Field."Source Table No.",Field."Source Field No.",
          Field."Source Table Filter GUID",Value."Value (Text)");
        IF LookupRecID."Record ID Tree ID" = 0 THEN
          LookupRecID."Record ID Tree ID" := Field."Fixed Value (Rec. ID Tree ID)";
        LookupRecID."Table Filter GUID" := Field."Source Table Filter GUID";
        LookupRecID."Document No." := Value."Document No.";
        LookupRecID."Line No." := Value."Line No.";

        Value."Value (Record ID Tree ID)" := RecIDMgt.SetKeyValueWithLookupRecID(Field."Source Table No.",Field."Source Field No.",
          LookupRecID,Value."Value (Text)",FALSE);
      END ELSE
        Value."Value (Text)" := '';

      IF NOT Field.Required AND (Value."Value (Record ID Tree ID)" = 0) THEN BEGIN
        Value."Value (Text)" := '';
        EXIT(TRUE);
      END ELSE
        EXIT(Value."Value (Record ID Tree ID)" <> 0);
    END;

    LOCAL PROCEDURE RoundFromDecPlaces@1160040001(Number@1160040001 : Decimal;DecPlaces@1160040000 : Text[30]) : Decimal;
    BEGIN
      IF DecPlaces = '' THEN
        EXIT(Number);

      CASE COPYSTR(DecPlaces,STRLEN(DecPlaces),1) OF
        '0':
          EXIT(ROUND(Number,1));
        '1':
          EXIT(ROUND(Number,0.1));
        '2':
          EXIT(ROUND(Number,0.01));
        '3':
          EXIT(ROUND(Number,0.001));
        '4':
          EXIT(ROUND(Number,0.0001));
        '5':
          EXIT(ROUND(Number,0.00001));
        ELSE
          EXIT(Number);
      END;
    END;

    PROCEDURE TransferTableFields@1160040004(RecRef@1160040003 : RecordRef;Document@1160040002 : Record 6085590;DocumentLineNo@1160040006 : Integer;TransHeaderFields@1160040004 : Boolean) : Boolean;
    VAR
      DocCat@1160040001 : Record 6085575;
      Field@1160040005 : Record 6085580;
    BEGIN
      IF NOT DocCat.GET(Document."Document Category Code") THEN
        EXIT;

      Field.SETCURRENTKEY("Template No.",Type,"Sort Order");
      Field.SETRANGE("Template No.",Document."Template No.");

      IF TransHeaderFields THEN BEGIN
        Field.SETFILTER("Destination Header Field No.",'>%1',0);
        IF Field.ISEMPTY THEN
          EXIT;

        DocCat.TESTFIELD("Destination Header Table No.",RecRef.NUMBER);
      END ELSE BEGIN
        Field.SETFILTER("Destination Line Field No.",'>%1',0);
        IF Field.ISEMPTY THEN
          EXIT;

        DocCat.TESTFIELD("Destination Line Table No.",RecRef.NUMBER);
      END;

      TransferDestFields(RecRef,Field,Document,DocumentLineNo,TransHeaderFields);
    END;

    LOCAL PROCEDURE TransferDestFields@1160040007(VAR RecRef@1160040000 : RecordRef;VAR Field@1160040001 : Record 6085580;Document@1160040002 : Record 6085590;LineNo@1160040003 : Integer;TransHeaderFields@1160040006 : Boolean);
    VAR
      Value@1160040007 : Record 6085593;
      TableField@1160040011 : Record 2000000041;
      FieldRef@1160040005 : FieldRef;
      UseLineNo@1160040013 : Integer;
      i@1160040010 : Integer;
    BEGIN
      IF Field.FINDSET THEN
        REPEAT
          IF Field.Type = Field.Type::Header THEN
            UseLineNo := 0
          ELSE
            UseLineNo := LineNo;

          IF NOT Value.GET(Document."No.",TRUE,Field.Code,UseLineNo) THEN
            CLEAR(Value);

          IF TransHeaderFields THEN
            FieldRef := RecRef.FIELD(Field."Destination Header Field No.")
          ELSE
            FieldRef := RecRef.FIELD(Field."Destination Line Field No.");

          TableField.GET(RecRef.NUMBER,FieldRef.NUMBER);

          CASE TableField.Type OF
            TableField.Type::Text,TableField.Type::Code:
              IF FORMAT(FieldRef.VALUE) <> Value."Value (Text)" THEN
                IF (Value."Value (Text)" <> '') OR Field."Transfer Blank Values" THEN
                  FieldRef.VALIDATE(Value."Value (Text)");

            TableField.Type::Date:
              IF FORMAT(FieldRef.VALUE) <> FORMAT(Value."Value (Date)") THEN
                IF (Value."Value (Date)" <> 0D) OR Field."Transfer Blank Values" THEN
                  FieldRef.VALIDATE(Value."Value (Date)");

            TableField.Type::Decimal,TableField.Type::Integer:
              IF FORMAT(FieldRef.VALUE) <> FORMAT(Value."Value (Decimal)") THEN
                IF (Value."Value (Decimal)" <> 0) OR Field."Transfer Blank Values" THEN
                  FieldRef.VALIDATE(Value."Value (Decimal)");

            TableField.Type::Option:
              BEGIN
                IF Value."Value (Text)" <> '' THEN BEGIN
                  i := OptionToInt(RecRef.NUMBER,FieldRef.NUMBER,Value."Value (Text)");
                  IF i > -1 THEN
                    FieldRef.VALIDATE(i)
                  ELSE
                    IF EVALUATE(i,Value."Value (Text)") THEN
                      FieldRef.VALIDATE(i);
                END;
              END;

            TableField.Type::Boolean:
              IF FORMAT(FieldRef.VALUE) <> FORMAT(Value."Value (Boolean)") THEN
                FieldRef.VALIDATE(Value."Value (Boolean)");
          END;
        UNTIL Field.NEXT = 0;
    END;

    PROCEDURE GetAmountToSubtract@1160040010(Document@1160040002 : Record 6085590;Field@1160040000 : Record 6085580) Amount : Decimal;
    VAR
      Field2@1160040001 : Record 6085580;
    BEGIN
      // *****************************************************************************************************************************
      // FIND POTENTIAL AMOUNTS (FROM OTHER TEMPLATE FIELDS) TO BE SUBTRACTED
      // *****************************************************************************************************************************
      Field2.SETRANGE("Template No.",Field."Template No.");
      Field2.SETRANGE(Type,Field.Type);
      Field2.SETRANGE("Data Type",Field."Data Type");
      Field2.SETRANGE("Subtract from Amount Field",Field.Code);
      IF Field2.FINDSET THEN
        REPEAT
          Amount += GetDecimal(Document,Field2.Type,Field2.Code,0);
        UNTIL Field2.NEXT = 0;
    END;

    PROCEDURE ReplaceIllegalFilterCharacters@1160040013(FilterText@1160040000 : Text[1024];ReplaceWithQuestionMark@6085573 : Boolean;MaxLenghtToReturn@6085574 : Integer) : Text[1024];
    VAR
      NewText@1160040001 : Text[1024];
      ReplaceText@6085575 : Text[1];
    BEGIN
      IF ReplaceWithQuestionMark THEN
        ReplaceText := '?';

      NewText := Replace(FilterText,'=',ReplaceText,FALSE);
      NewText := Replace(NewText,'&',ReplaceText,FALSE);
      NewText := Replace(NewText,'<',ReplaceText,FALSE);
      NewText := Replace(NewText,'>',ReplaceText,FALSE);
      NewText := Replace(NewText,'@',ReplaceText,FALSE);
      NewText := Replace(NewText,'*','',FALSE);
      NewText := Replace(NewText,'(',ReplaceText,FALSE);
      NewText := Replace(NewText,')',ReplaceText,FALSE);
      NewText := Replace(NewText,'''',ReplaceText,FALSE);
      NewText := Replace(NewText,'"',ReplaceText,FALSE);
      NewText := Replace(NewText,'..',ReplaceText + ReplaceText,FALSE);
      NewText := Replace(NewText,'|','',FALSE);

      IF MaxLenghtToReturn <> 0 THEN
        NewText := COPYSTR(NewText,1,MaxLenghtToReturn);
      EXIT(NewText);
    END;

    PROCEDURE HasIllegalFilterCharacters@6085573(FilterText@6085574 : Text[1024]) : Boolean;
    VAR
      NewText@6085577 : Text[1024];
    BEGIN
      IF (STRPOS(FilterText,'=') <> 0) OR
        (STRPOS(FilterText,'&') <> 0) OR
        (STRPOS(FilterText,'<') <> 0) OR
        (STRPOS(FilterText,'>') <> 0) OR
        (STRPOS(FilterText,'@') <> 0) OR
        (STRPOS(FilterText,'*') <> 0) OR
        (STRPOS(FilterText,'(') <> 0) OR
        (STRPOS(FilterText,')') <> 0) OR
        (STRPOS(FilterText,'''') <> 0) OR
        (STRPOS(FilterText,'"') <> 0) OR
        (STRPOS(FilterText,'..') <> 0) OR
        (STRPOS(FilterText,'|') <> 0)
      THEN
        EXIT(TRUE)
      ELSE
        EXIT(FALSE);
    END;

    LOCAL PROCEDURE AutoCreateTextRule@6085575(DocumentNo@6085579 : Code[20];Word@6085574 : Text[1024];ValueIsValid@6085573 : Boolean;Field@6085575 : Record 6085580);
    VAR
      FieldRule@6085578 : Record 6085583;
      FieldRule2@6085576 : Record 6085583;
      NextEntryNo@6085577 : Integer;
    BEGIN
      FilterRule(Field,FieldRule);
      IF ((NOT ValueIsValid) OR (FieldRule.ISEMPTY)) AND (Word <> '') THEN BEGIN
        FieldRule2.RESET;
        FieldRule2.SETRANGE("Template No.",Field."Template No.");
        FieldRule2.SETRANGE(Type,Field.Type);
        FieldRule2.SETRANGE(Code,Field.Code);
        IF FieldRule2.FINDLAST THEN
          NextEntryNo := FieldRule2."Entry No." + 10000
        ELSE
          NextEntryNo := 10000;

        InitRule(Field,FieldRule);
        FieldRule."Entry No." := NextEntryNo;
        FieldRule."Document No." := DocumentNo;
        FieldRule.Rule := BuildTextRegExPattern(Word);
        FieldRule.Description := Text004;
        FieldRule.INSERT(TRUE);
      END;
    END;

    LOCAL PROCEDURE DeleteFieldRuleFromCreatedDoc@6085576(Field@6085573 : Record 6085580;DocumentNo@6085574 : Code[20]);
    VAR
      FieldRule@6085575 : Record 6085583;
    BEGIN
      FieldRule.SETRANGE("Template No.",Field."Template No.");
      FieldRule.SETRANGE(Type,Field.Type);
      FieldRule.SETRANGE(Code,Field.Code);
      FieldRule.SETRANGE("Document No.",DocumentNo);
      FieldRule.DELETEALL(TRUE);
    END;

    LOCAL PROCEDURE ClearFldRuleCreatedFromMaster@6085577(VAR FieldRule@6085573 : Record 6085583;DocumentNo@6085574 : Code[20]);
    BEGIN
      IF FieldRule."Created from Master Template" THEN BEGIN
        FieldRule."Created from Master Template" := FALSE;
        FieldRule."Document No." := DocumentNo;
        FieldRule.MODIFY(TRUE);
      END;
    END;

    LOCAL PROCEDURE DelFldRulesCreatedFromMaster@6085579(SkipEntryNo@6085574 : Integer);
    VAR
      FieldRule@6085573 : Record 6085583;
    BEGIN
      FieldRule.SETRANGE("Created from Master Template",TRUE);
      FieldRule.SETFILTER("Entry No.",'<>%1',SkipEntryNo);
      IF NOT FieldRule.ISEMPTY THEN
        FieldRule.DELETEALL(TRUE);
    END;

    BEGIN
    END.
  }
}

