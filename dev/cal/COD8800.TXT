OBJECT Codeunit 8800 Custom Layout Reporting
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVW114.05;
  }
  PROPERTIES
  {
    EventSubscriberInstance=Manual;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      TempBlobReqParamStore@1005 : TEMPORARY Record 99008535;
      ReportSelections@1009 : Record 77;
      CustomReportSelection@1004 : Record 9657;
      ReportLayoutSelection@1010 : Record 9651;
      TempNameValueBuffer@1016 : TEMPORARY Record 823;
      TempEmailNameValueBuffer@1022 : TEMPORARY Record 823;
      TempEraseFileNameValueBuffer@1020 : TEMPORARY Record 823;
      RequestPageParametersHelper@1119 : Codeunit 1530;
      FileManagement@1110 : Codeunit 419;
      ClientTypeManagement@1031 : Codeunit 4030;
      ErrorMessageManagement@1034 : Codeunit 28;
      ErrorMessageHandler@1032 : Codeunit 29;
      ReportDataRecordRef@1111 : RecordRef;
      IteratorRecordRef@1015 : RecordRef;
      ReportDataIteratorFieldRef@1112 : FieldRef;
      IteratorJoinFieldRef@1113 : FieldRef;
      BalAcctTypeFieldRef@1024 : FieldRef;
      AcctTypeFieldRef@1023 : FieldRef;
      OutputType@1001 : 'Print,Preview,PDF,Email,Excel,Word,XML';
      SaveFolderMsg@1003 : TextConst 'ENU=Select a folder to save reports to.;NOR=Velg en mappe † lagre rapporter i.;SVE=V„lj en mapp att spara rapporter i.';
      NotInitializedErr@1000 : TextConst 'ENU=Report data not initialized.;NOR=Rapportdata er ikke initialisert.;SVE=Rapportdata har inte initierats.';
      OutputNotSupportedErr@1012 : TextConst 'ENU=The chosen output method is not supported.;NOR=Den valgte utdatametoden st›ttes ikke.;SVE=Den valda utdatametoden st”ds inte.';
      SMTPNotSetupErr@1002 : TextConst 'ENU=To send as email, you must set up SMTP.;NOR=Du m† konfigurere SMTP for † kunne sende som e-post.;SVE=Du m†ste konfigurera SMTP f”r att kunna skicka e-post.';
      ReportingType@1014 : 'Object,Layout';
      ZipFileName@1017 : Text;
      ZipDownloadTxt@1019 : TextConst 'ENU=AllReports.zip;NOR=AllReports.zip;SVE=AllReports.zip';
      Path@1056 : Text;
      OutputFileBaseName@1013 : Text;
      Initialized@1057 : Boolean;
      ReportDataAndIteratorDiffer@1058 : Boolean;
      SupressOutput@1006 : Boolean;
      PrintIfEmailIsMissing@1007 : Boolean;
      OverrideOutput@1011 : Boolean;
      TestModeWebClient@1008 : Boolean;
      PathLengthErr@1018 : TextConst '@@@=%1: a file name, generated by the system;ENU=The file name %1 is too long and cannot be used.;NOR=Filnavnet %1 er for langt og kan ikke brukes.;SVE=Filnamnet %1 „r f”r l†ngt och g†r inte att anv„nda.';
      ReportFormatNotSupportedErr@1021 : TextConst '@@@=%1 is the extension for the report.;ENU=Creation of report with format type %1 is not supported.;NOR=Det er ikke st›tte for † opprette rapporter med formattypen %1.;SVE=Det g†r inte att skapa rapporter med formattypen %1.';
      NoOutputErr@1025 : TextConst 'ENU=No data exists for the specified report filters.;NOR=Ingen data finnes for de angitte rapportfiltrene.';
      AnyOutputExists@1026 : Boolean;
      LastUsedTxt@1027 : TextConst '@@@=Translation must match RequestPageLatestSavedSettingsName from Lang.resx;ENU=Last used options and filters;NOR=Sist brukte alternativer og filtre;SVE=Senast anv„nda alternativ och filter';
      WordOutputXmlHasData@1028 : Boolean;
      WordOutputXmlHasDataVerified@1029 : Boolean;
      IgnoreRequestParameters@1030 : Boolean;
      PredefinedRequestParameters@1170000001 : Text;
      ReportInboxReportNameTxt@1033 : TextConst 'ENU=Customer Statements;NOR=Kontoutdrag';
      ErrorForDataOccuredErr@1035 : TextConst '@@@=%1 - Error text, %2 - Report ID, %3 - Record ID.;ENU=The error, %1, occurred when running report %2 for %3.;NOR=Feilen, %1, oppstod under kj›ring av rapporten %2 for %3.';

    [External]
    PROCEDURE GetLayoutIteratorKeyFilter@22(VAR FilterRecordRef@1080 : RecordRef;VAR FilterRecordKeyFieldRef@1081 : FieldRef;CustomReportLayoutCode@1003 : Code[20]);
    VAR
      CustomReportSelection2@1058 : Record 9657;
      Filter@1083 : Text;
    BEGIN
      // Further filters the items in FilterRecordRef by restricting them only to items who have entries in the "* Report Selection" tables
      // This prevents us from iterating over items that aren't related to the custom layouts
      CustomReportSelection2.SETVIEW(CustomReportSelection.GETVIEW);

      // Set the filters on the "* Report Selection" table and iterate through
      CustomReportSelection2.SETRANGE("Custom Report Layout Code",CustomReportLayoutCode);

      IF CustomReportSelection2.FINDSET THEN
        CASE CustomReportSelection2."Source Type" OF
          DATABASE::Customer:
            Filter := GetCustomerFilter(CustomReportSelection2);
          DATABASE::Vendor:
            Filter := GetVendorFilter(CustomReportSelection2);
          ELSE BEGIN
            REPEAT
              IF Filter <> '' THEN
                Filter := Filter + '|';
              Filter := STRSUBSTNO('%1%2',Filter,CustomReportSelection2."Source No.");
            UNTIL CustomReportSelection2.NEXT = 0;
          END;
        END;

      // Set the more restrictive filter
      SetNextGroupFilter(FilterRecordRef,FilterRecordKeyFieldRef,Filter)
    END;

    LOCAL PROCEDURE GetCustomerFilter@68(VAR CustomReportSelection@1000 : Record 9657) : Text;
    VAR
      Customer@1001 : Record 18;
      SelectionFilterMgt@1005 : Codeunit 46;
    BEGIN
      REPEAT
        Customer.GET(CustomReportSelection."Source No.");
        Customer.MARK(TRUE);
      UNTIL CustomReportSelection.NEXT = 0;
      Customer.MARKEDONLY(TRUE);
      EXIT(SelectionFilterMgt.GetSelectionFilterForCustomer(Customer));
    END;

    LOCAL PROCEDURE GetVendorFilter@69(VAR CustomReportSelection@1000 : Record 9657) : Text;
    VAR
      Vendor@1002 : Record 23;
      SelectionFilterMgt@1005 : Codeunit 46;
    BEGIN
      REPEAT
        Vendor.GET(CustomReportSelection."Source No.");
        Vendor.MARK(TRUE);
      UNTIL CustomReportSelection.NEXT = 0;
      Vendor.MARKEDONLY(TRUE);
      EXIT(SelectionFilterMgt.GetSelectionFilterForVendor(Vendor));
    END;

    [Internal]
    PROCEDURE ProcessReport@43();
    VAR
      RequestPageParamsView@1000 : Text;
      FilterGroup@1001 : Integer;
    BEGIN
      // If we're not yet initialized, exit - data needs to be set up before reports can be run
      IF NOT Initialized THEN
        EXIT;

      CLEARLASTERROR;
      AnyOutputExists := TRUE;

      ErrorMessageManagement.Activate(ErrorMessageHandler);
      ErrorMessageManagement.PushContext(ReportSelections,0,'');

      // Iterate through the selections and run the reports.
      IF ReportSelections.FINDSET THEN BEGIN
        AnyOutputExists := FALSE;
        REPEAT
          SetOutputType(ReportSelections."Report ID");

          CustomReportSelection.SETFILTER("Report ID",STRSUBSTNO('0|%1',ReportSelections."Report ID"));
          CustomReportSelection.SETRANGE(Usage,ReportSelections.Usage);

          PrintIfEmailIsMissing := FALSE;

          // If our report's data item and the 'join table' are the same, then set its filter from the request page.
          IF NOT ReportDataAndIteratorDiffer THEN BEGIN
            RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",IteratorRecordRef.NUMBER);
            IteratorRecordRef.SETVIEW(RequestPageParamsView);
          END;

          FilterGroup := ReportDataRecordRef.FILTERGROUP;
          ReportDataRecordRef.FILTERGROUP(FindNextEmptyFilterGroup(ReportDataRecordRef)); // Set the request page filters separately to preserve the existing filters
          RequestPageParamsView := GetViewFromParameters(ReportSelections."Report ID",ReportDataRecordRef.NUMBER);
          ReportDataRecordRef.SETVIEW(RequestPageParamsView);
          ReportDataRecordRef.FILTERGROUP(FilterGroup);
          CASE OutputType OF
            OutputType::Email:
              BEGIN
                IF EVALUATE(
                     PrintIfEmailIsMissing,GetOptionValueFromRequestPage(
                       GetRequestParametersText(ReportSelections."Report ID"),'PrintIfEmailIsMissing'))
                THEN;
                ProcessReportPerObject;
              END;
            OutputType::PDF,
            OutputType::Word,
            OutputType::Excel,
            OutputType::XML:
              ProcessReportPerObject;
            OutputType::Preview,
            OutputType::Print:
              ProcessReportPerLayout;
          END;
          LogAndClearLastError(ReportSelections."Report Caption",ReportDataRecordRef.RECORDID);
        UNTIL ReportSelections.NEXT = 0;
      END;

      // Download the .zip file containing the reports if one was generated (usually from being on the web client)
      TempNameValueBuffer.RESET;  // Filters need to be cleared in order to get an accurate count.
      IF (ZipFileName <> '') AND NOT SupressOutput AND TempNameValueBuffer.FINDSET THEN
        // If there's a single file, download it directly instead of the zip file
        IF TempNameValueBuffer.COUNT = 1 THEN
          IF IsTestMode THEN
            FileManagement.CopyServerFile(TempNameValueBuffer.Value,FileManagement.CombinePath(Path,TempNameValueBuffer.Name),TRUE)
          ELSE
            IF ClientTypeManagement.IsBackground AND FileManagement.ServerFileExists(TempNameValueBuffer.Value) THEN
              SendToReportInbox(FALSE,ReportSelections."Report ID")
            ELSE
              FileManagement.DownloadHandler(TempNameValueBuffer.Value,'','','',TempNameValueBuffer.Name)
        ELSE BEGIN
          REPEAT
            FileManagement.AddFileToZipArchive(TempNameValueBuffer.Value,TempNameValueBuffer.Name);
            TempEraseFileNameValueBuffer.AddNewEntry(TempNameValueBuffer.Value,'');
          UNTIL TempNameValueBuffer.NEXT = 0;
          FileManagement.CloseZipArchive;
          // If we're in test mode, save the zip to the save path. Otherwise send to the client.
          IF IsTestMode THEN
            FileManagement.CopyServerFile(ZipFileName,FileManagement.CombinePath(Path,ZipDownloadTxt),TRUE)
          ELSE
            IF ClientTypeManagement.IsBackground AND FileManagement.ServerFileExists(ZipFileName) THEN
              SendToReportInbox(TRUE,ReportSelections."Report ID")
            ELSE
              FileManagement.DownloadHandler(ZipFileName,'','','',ZipDownloadTxt)
        END;

      CleanupTempFiles;

      IF NOT (SupressOutput OR AnyOutputExists) THEN
        LogSimpleError(NoOutputErr);

      IF ErrorMessageHandler.HasErrors THEN
        IF NOT ClientTypeManagement.IsBackground THEN
          IF ErrorMessageHandler.ShowErrors THEN
            ERROR('');
    END;

    [Internal]
    PROCEDURE ProcessReportForData@27(ReportSelectionUsage@1005 : Integer;VAR DataRecordRef@1004 : RecordRef;SourceJoinFieldName@1003 : Text;DataRecordJoinTable@1002 : Integer;IteratorTableFieldName@1001 : Text;DataItemTableSameAsIterator@1000 : Boolean);
    BEGIN
      // Provides a single function to run initialization code, check for issues, and start report processing
      IF NOT Initialized THEN
        InitializeData(
          ReportSelectionUsage,DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,
          DataItemTableSameAsIterator);
      // If there was an error during initalization, exit
      IF NOT Initialized THEN
        EXIT;
      ProcessReport;
    END;

    LOCAL PROCEDURE ProcessReportPerLayout@7();
    VAR
      ReportedLayouts@1086 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      ReportedObjects@1087 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      TempRecordRef@1000 : RecordRef;
      TempRecordKeyFieldRef@1088 : FieldRef;
      CustomReportLayoutCode@1089 : Code[20];
      ReportedRecordKeyVal@1091 : Text;
    BEGIN
      ReportingType := ReportingType::Layout;
      // Prevent early calls to the function
      IF NOT Initialized THEN
        ERROR(NotInitializedErr);

      // Temporary lists to keep track of what we've reported over, used to determine what to report on using the default layout
      ReportedLayouts := ReportedLayouts.ArrayList;
      ReportedObjects := ReportedObjects.ArrayList;

      // Iterate through the layouts in the Custom Report Selection table
      IF CustomReportSelection.FINDSET THEN BEGIN
        REPEAT
          CustomReportLayoutCode := CustomReportSelection."Custom Report Layout Code";

          // Reset the TempRecordRef object
          TempRecordRef := ReportDataRecordRef.DUPLICATE;
          TempRecordKeyFieldRef := TempRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);

          // If we've not already reported on this layout and it truly is a custom layout, then report on it
          IF NOT ReportedLayouts.Contains(CustomReportLayoutCode) AND
             (ResolveCustomReportLayoutCode(CustomReportSelection) <> '')
          THEN BEGIN
            ReportedLayouts.Add(CustomReportLayoutCode);

            // Run the report only for those objects that have this layout
            GetLayoutIteratorKeyFilter(TempRecordRef,TempRecordKeyFieldRef,CustomReportLayoutCode); // set view based on intersection of lists

            // Run the report on the data record, using the above filter
            RunReportWithCustomReportSelection(TempRecordRef,ReportSelections."Report ID",CustomReportSelection,PrintIfEmailIsMissing);

            // Save this list of objects reported on, using the 'iterator field', they will not get the default report layout later
            IF TempRecordRef.FINDFIRST THEN
              REPEAT
                ReportedRecordKeyVal := FORMAT(TempRecordKeyFieldRef.VALUE);
                IF NOT ReportedObjects.Contains(ReportedRecordKeyVal) THEN
                  ReportedObjects.Add(ReportedRecordKeyVal);
              UNTIL TempRecordRef.NEXT = 0;
          END;
        UNTIL CustomReportSelection.NEXT = 0;
      END;

      // Construct the filter for the remaining objects - iterate through all items in the data record and build a filter that contains the
      // items that are not in the list of already reported items.
      TempRecordRef := ReportDataRecordRef.DUPLICATE;
      TempRecordKeyFieldRef := TempRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);

      // Set the exclusion filter based on the items we've already reported on and set that filter on top of the filter already applied
      IF TempRecordRef.FINDFIRST THEN
        REPEAT
          IF ReportedObjects.Contains(FORMAT(TempRecordKeyFieldRef.VALUE)) THEN
            SetNextGroupFilter(TempRecordRef,TempRecordKeyFieldRef,STRSUBSTNO('<>%1',FORMAT(TempRecordKeyFieldRef.VALUE)));
        UNTIL TempRecordRef.NEXT = 0;

      // Only run the report if we still have something to report on
      IF TempRecordRef.FINDFIRST THEN
        RunReport(TempRecordRef,ReportSelections."Report ID",PrintIfEmailIsMissing);
    END;

    LOCAL PROCEDURE ProcessReportPerObject@21();
    VAR
      PrevRecordID@1003 : RecordID;
      IteratorJoinFieldValue@1095 : Code[20];
      ReportID@1096 : Integer;
      IteratorFilterGroup@1000 : Integer;
      JoinValue@1001 : Code[20];
    BEGIN
      ReportingType := ReportingType::Object;
      IF NOT Initialized THEN
        ERROR(NotInitializedErr);

      ReportID := ReportSelections."Report ID";

      EVALUATE(IteratorJoinFieldValue,FORMAT(IteratorJoinFieldRef.VALUE));

      // Set the data filter to be the item we're iterating over:

      IF ReportDataRecordRef.FINDSET THEN BEGIN
        REPEAT
          // Get and set the report selection for this particular object/report combination
          JoinValue := FORMAT(ReportDataIteratorFieldRef.VALUE,20);
          CustomReportSelection.SETRANGE("Source No.",JoinValue);
          IteratorFilterGroup := SetNextGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,JoinValue);
          PrevRecordID := ReportDataRecordRef.RECORDID;

          SetIteratorJoinFieldRef;
          // Find the 'join' value in the associated table, this helps us generate the name
          IteratorJoinFieldRef.SETRANGE(JoinValue);
          IteratorRecordRef.FINDFIRST;

          // If the object has custom layouts defined - process each one based on the selected output type, otherwise use the default layout
          IF CustomReportSelection.FINDSET THEN
            REPEAT
              RunReportWithCustomReportSelection(ReportDataRecordRef,ReportID,CustomReportSelection,PrintIfEmailIsMissing);
            UNTIL CustomReportSelection.NEXT = 0
          ELSE
            RunReport(ReportDataRecordRef,ReportID,PrintIfEmailIsMissing);

          // Clear out the filter and reset:
          SetGroupFilter(ReportDataRecordRef,ReportDataIteratorFieldRef,'',IteratorFilterGroup);
          ReportDataRecordRef.GET(PrevRecordID);

        UNTIL ReportDataRecordRef.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE RunReportWithCustomReportSelection@24(VAR DataRecRef@1000 : RecordRef;ReportID@1001 : Integer;VAR CustomReportSelection@1002 : Record 9657;EmailPrintIfEmailIsMissing@1003 : Boolean);
    VAR
      CustomReportLayoutCode@1005 : Code[20];
    BEGIN
      // Set the custom report layout
      CustomReportLayoutCode := ResolveCustomReportLayoutCode(CustomReportSelection);
      ReportLayoutSelection.SetTempLayoutSelected(CustomReportLayoutCode);

      CASE OutputType OF
        OutputType::Email:
          BEGIN
            IF CustomReportSelection."Send To Email" = '' THEN BEGIN
              IF EmailPrintIfEmailIsMissing THEN
                PrintReport(DataRecRef,ReportID,CustomReportLayoutCode)
              ELSE
                CustomReportSelection.CheckEmailSendTo;
            END ELSE
              EmailReport(DataRecRef,ReportID,CustomReportSelection)
          END;
        OutputType::PDF:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);
        OutputType::Excel:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Excel);
        OutputType::Word:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);
        OutputType::Print:
          PrintReport(DataRecRef,ReportID,CustomReportLayoutCode);
        OutputType::Preview:
          PreviewReport(DataRecRef,ReportID,CustomReportLayoutCode);
        OutputType::XML:
          SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Xml);
      END;
      IF CustomReportLayoutCode <> '' THEN
        ReportLayoutSelection.SetTempLayoutSelected('');

      LogAndClearLastError(CustomReportSelection."Report Caption",DataRecRef.RECORDID);
    END;

    LOCAL PROCEDURE RunReport@25(VAR DataRecRef@1003 : RecordRef;ReportID@1002 : Integer;EmailPrintRemaining@1000 : Boolean);
    VAR
      NullCustomReportSelection@1004 : Record 9657;
    BEGIN
      // If we know we don't need a custom report selection, e.g. we don't need layouts or won't be sending email
      NullCustomReportSelection.INIT;
      RunReportWithCustomReportSelection(DataRecRef,ReportID,NullCustomReportSelection,EmailPrintRemaining);
    END;

    [External]
    PROCEDURE SetOutputOption@26(OutputOption@1000 : Integer);
    BEGIN
      OutputType := OutputOption;
    END;

    [Internal]
    PROCEDURE GetOutputOption@1(ReportID@1002 : Integer) : Integer;
    VAR
      OptionText@1001 : Text;
      OptionInt@1000 : Integer;
    BEGIN
      // Given a report ID, get the currently selected output option
      OptionText := GetOptionValueFromRequestPageForReport(ReportID,'ChosenOutputMethod');
      IF EVALUATE(OptionInt,OptionText) THEN
        EXIT(OptionInt);

      EXIT(-1); // Invalid output option, still a valid return code - signals no output
    END;

    [External]
    PROCEDURE GetPrintOption@3() : Integer;
    BEGIN
      EXIT(OutputType::Print);
    END;

    [External]
    PROCEDURE GetEmailOption@4() : Integer;
    BEGIN
      EXIT(OutputType::Email);
    END;

    [External]
    PROCEDURE GetPreviewOption@5() : Integer;
    BEGIN
      EXIT(OutputType::Preview);
    END;

    [External]
    PROCEDURE GetExcelOption@6() : Integer;
    BEGIN
      EXIT(OutputType::Excel);
    END;

    [External]
    PROCEDURE GetPDFOption@8() : Integer;
    BEGIN
      EXIT(OutputType::PDF);
    END;

    [External]
    PROCEDURE GetWordOption@13() : Integer;
    BEGIN
      EXIT(OutputType::Word);
    END;

    [External]
    PROCEDURE GetXMLOption@30() : Integer;
    BEGIN
      EXIT(OutputType::XML);
    END;

    LOCAL PROCEDURE PrintReport@12(VAR DataRecRef@1003 : RecordRef;ReportID@1002 : Integer;CustomReportLayoutCode@1000 : Code[20]);
    BEGIN
      // If the print action is selected and we're on the web, shunt over to PDF output and ZIP file download

      IF (IsWebClient OR ClientTypeManagement.IsBackground) AND NOT IsWordLayout(ReportID,CustomReportLayoutCode) THEN
        SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Pdf);

      // If we're on the web client, and Word layout, then run the default
      IF (IsWebClient OR ClientTypeManagement.IsBackground) AND IsWordLayout(ReportID,CustomReportLayoutCode) THEN
        SaveAsReport(DataRecRef,ReportID,REPORTFORMAT::Word);

      // Local client - print
      IF NOT IsWebClient AND NOT SupressOutput AND NOT ClientTypeManagement.IsBackground THEN BEGIN
        REPORT.PRINT(ReportID,GetRequestParametersText(ReportID),'',DataRecRef);
        AnyOutputExists := TRUE;
      END;
    END;

    LOCAL PROCEDURE EmailReport@11(VAR DataRecRef@1004 : RecordRef;ReportID@1003 : Integer;CustomReportSelection@1002 : Record 9657);
    VAR
      MailManagement@1007 : Codeunit 9520;
      FieldRef1@1014 : FieldRef;
      FieldRef2@1013 : FieldRef;
      ReportRecordVariant@1012 : Variant;
      TempPdfFilePath@1009 : Text[250];
      TempEmailBodyFilePath@1008 : Text[250];
      FileName@1005 : Text[250];
      PdfFileName@1006 : Text[250];
      TempReportLayoutCode@1001 : Code[20];
      EmailBodyLayoutCode@1000 : Code[20];
    BEGIN
      TempPdfFilePath := CreateReportWithExtension(DataRecRef,ReportID,REPORTFORMAT::Pdf,FileName);
      IF TempPdfFilePath = '' THEN
        EXIT;

      // Set the pdf file name to be used later when sending an email.
      PdfFileName := FileName;

      // Use the iterator values if the data item and iterator differ
      IF ReportDataAndIteratorDiffer THEN BEGIN
        GetKeyFieldRef(IteratorRecordRef,FieldRef1);
        GetNameFieldRef(IteratorRecordRef,FieldRef2);
      END ELSE BEGIN
        GetKeyFieldRef(DataRecRef,FieldRef1);
        GetNameFieldRef(DataRecRef,FieldRef2);
      END;

      EmailBodyLayoutCode := ResolveEmailBodyLayoutCode(CustomReportSelection,ReportSelections);
      IF EmailBodyLayoutCode <> '' THEN BEGIN
        TempReportLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
        ReportLayoutSelection.SetTempLayoutSelected(EmailBodyLayoutCode);
        ReportRecordVariant := DataRecRef;
        BINDSUBSCRIPTION(MailManagement);
        TempEmailBodyFilePath := CreateReportWithExtension(ReportRecordVariant,ReportID,REPORTFORMAT::Html,FileName);
        UNBINDSUBSCRIPTION(MailManagement);
        IF TempEmailBodyFilePath = '' THEN
          EXIT;
        ReportLayoutSelection.SetTempLayoutSelected(TempReportLayoutCode);
      END;

      IF SupressOutput OR RemoveEmptyFile(TempPdfFilePath) THEN
        EXIT;

      AnyOutputExists := TRUE;
      TryEmailReport(TempPdfFilePath,PdfFileName,TempEmailBodyFilePath,CustomReportSelection,FieldRef2);
    END;

    LOCAL PROCEDURE PreviewReport@10(VAR DataRecRef@1001 : RecordRef;ReportID@1000 : Integer;CustomReportLayoutCode@1006 : Code[20]);
    VAR
      File@1073 : File;
      FileStream@1074 : OutStream;
      FileName@1075 : Text;
      TempFilePath@1076 : Text;
      ReportSaved@1077 : Boolean;
    BEGIN
      IF IsWebClient OR IsWordLayout(ReportID,CustomReportLayoutCode) THEN BEGIN
        TempFilePath := FileManagement.ServerTempFileName('.docx');
        FileName := GenerateFileNameForReportLayout(ReportID,'.docx','');
        File.CREATE(TempFilePath);
        File.CREATEOUTSTREAM(FileStream);
        ReportSaved := BoundCallReportSaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Word,FileStream,DataRecRef);
        File.CLOSE;
        IF FileManagement.ServerFileExists(TempFilePath) AND ReportSaved AND NOT RemoveEmptyFile(TempFilePath) THEN
          AddFileToClientZip(TempFilePath,FileName);
      END ELSE
        IF NOT SupressOutput THEN BEGIN
          REPORT.EXECUTE(ReportID,GetRequestParametersText(ReportID),DataRecRef);
          AnyOutputExists := TRUE;
        END;
    END;

    LOCAL PROCEDURE SaveAsReport@9(VAR DataRecRef@1002 : RecordRef;ReportID@1000 : Integer;RepFormat@1059 : ReportFormat);
    VAR
      File@1077 : File;
      FileStream@1078 : OutStream;
      FileName@1079 : Text;
      Extension@1080 : Text;
      TempFilePath@1070 : Text;
      ReportSaved@1071 : Boolean;
      BasePath@1001 : Text;
    BEGIN
      // Handle both 'save file' types of reports together - PDF and Excel
      CASE RepFormat OF
        REPORTFORMAT::Excel:
          Extension := '.xlsx';
        REPORTFORMAT::Pdf:
          Extension := '.pdf';
        REPORTFORMAT::Word:
          Extension := '.docx';
        REPORTFORMAT::Xml:
          Extension := '.xml';
        ELSE
          ERROR(OutputNotSupportedErr);
      END;

      // If no path was given (often during test runs), use a temp directory on the server
      IF FileManagement.IsWindowsClient AND (Path = '') THEN
        Path := FileManagement.ServerCreateTempSubDirectory;

      // If we're not on the web client, use the path that was selected for saving
      // In the web client, the path isn't used since we zip up the files and send them to the client
      IF NOT IsWebClient THEN
        BasePath := Path;
      CASE ReportingType OF
        ReportingType::Object:
          FileName := GenerateFileNameForReport(ReportID,Extension,BasePath,TRUE);
        ReportingType::Layout:
          FileName := GenerateFileNameForReportLayout(ReportID,Extension,BasePath);
      END;

      TempFilePath := FileManagement.ServerTempFileName(Extension);
      File.CREATE(TempFilePath);
      File.CREATEOUTSTREAM(FileStream);
      ReportSaved := BoundCallReportSaveAs(ReportID,GetRequestParametersText(ReportID),RepFormat,FileStream,DataRecRef);
      File.CLOSE;

      IF ReportSaved AND NOT RemoveEmptyFile(TempFilePath) AND FileManagement.ServerFileExists(TempFilePath) AND NOT SupressOutput THEN
        IF IsWebClient OR ClientTypeManagement.IsBackground THEN
          AddFileToClientZip(TempFilePath,FileName)
        ELSE BEGIN
          FileManagement.DownloadToFile(TempFilePath,FileName);
          TempEraseFileNameValueBuffer.AddNewEntry(FORMAT(TempFilePath,250),'');
          AnyOutputExists := TRUE;
        END;
    END;

    LOCAL PROCEDURE GenerateFileNameForReport@2(ReportID@1005 : Integer;Extension@1001 : Text;FilePath@1002 : Text;IncludeLayoutName@1004 : Boolean) : Text[250];
    VAR
      NameFieldRef@1072 : FieldRef;
      ObjectName@1000 : Text;
      Caption@1003 : Text;
    BEGIN
      // If we're iterating through Customer or Vendor, get the appropriate name
      IF GetNameFieldRef(IteratorRecordRef,NameFieldRef) THEN
        ObjectName := STRSUBSTNO('%1',NameFieldRef.VALUE);

      IF IncludeLayoutName THEN BEGIN
        Caption := GetTempLayoutReportCaption(ReportID);
        ObjectName := STRSUBSTNO('%1_%2',ObjectName,Caption);
      END;

      EXIT(GenerateFileName(ObjectName,ReportID,Extension,FilePath));
    END;

    LOCAL PROCEDURE GenerateFileNameForReportLayout@31(ReportID@1005 : Integer;Extension@1001 : Text;FilePath@1002 : Text) : Text[250];
    BEGIN
      // Get report caption if we're not on a custom layout, otherwise get the custom layout caption
      EXIT(GenerateFileName(GetTempLayoutReportCaption(ReportID),ReportID,Extension,FilePath));
    END;

    LOCAL PROCEDURE GenerateFileName@32(ObjectName@1003 : Text;ReportID@1002 : Integer;Extension@1001 : Text;FilePath@1000 : Text) : Text;
    VAR
      FileName@1004 : Text;
      EndDate@1005 : Text;
      ReportParameters@1006 : Text;
    BEGIN
      ReportParameters := GetRequestParametersText(ReportID);

      IF STRPOS(Extension,'.') <> 1 THEN
        Extension := '.' + Extension;

      // We need to limit the file name - limit of other functions
      IF (STRLEN(ObjectName) + STRLEN(FilePath)) >= 250 THEN
        ObjectName := FORMAT(ObjectName,250 - STRLEN(FilePath));

      // Fetch request page parameters
      EndDate := GetOptionValueFromRequestPage(ReportParameters,'EndDate');

      // Construct with the end date, if it exists. Format the object name to adhere to filename size limits
      IF OutputFileBaseName = '' THEN
        OutputFileBaseName := 'Report';
      IF EndDate <> '' THEN
        FileName := OutputFileBaseName + ' for ' + ObjectName + ' as of ' + EndDate + Extension
      ELSE
        FileName := OutputFileBaseName + ' for ' + ObjectName + Extension;

      FileName := FileManagement.StripNotsupportChrInFileName(FileName);

      IF FilePath <> '' THEN
        FileName := FileManagement.CombinePath(FilePath,FileName);

      EXIT(FileName);
    END;

    LOCAL PROCEDURE GetOptionValueFromRequestPage@45(ReportParameters@1002 : Text;OptionName@1001 : Text) : Text;
    BEGIN
      EXIT(RequestPageParametersHelper.GetRequestPageOptionValue(OptionName,ReportParameters));
    END;

    [Internal]
    PROCEDURE GetOptionValueFromRequestPageForReport@48(ReportID@1002 : Integer;OptionName@1001 : Text) : Text;
    BEGIN
      // Given a report ID - get the option from the request parameters page
      IF NOT TempBlobReqParamStore.GET(ReportID) THEN
        EXIT('');
      EXIT(GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),OptionName));
    END;

    LOCAL PROCEDURE GetTempLayoutReportCaption@42(ReportID@1000 : Integer) : Text;
    VAR
      CustomReportLayout@1004 : Record 9650;
      AllObjWithCaption@1003 : Record 2000000058;
      ReportCaption@1002 : Text;
      CurrentCustomLayoutCode@1001 : Code[20];
    BEGIN
      CurrentCustomLayoutCode := ReportLayoutSelection.GetTempLayoutSelected;
      IF CurrentCustomLayoutCode = '' THEN BEGIN
        AllObjWithCaption.GET(AllObjWithCaption."Object Type"::Report,ReportID);
        ReportCaption := AllObjWithCaption."Object Caption";
      END ELSE BEGIN
        CustomReportLayout.GET(CurrentCustomLayoutCode);
        ReportCaption := CustomReportLayout.Description;
      END;
      EXIT(ReportCaption);
    END;

    [External]
    PROCEDURE SetSavePath@29(SavePath@1000 : Text);
    BEGIN
      // This allows us to set the path ahead of setting request parameters if we know it or need to set it ahead of time
      // e.g. for unit tests
      Path := SavePath;
    END;

    LOCAL PROCEDURE GetViewFromParameters@75(ReportID@1004 : Integer;TableNumber@1075 : Integer) : Text;
    VAR
      RecordRef@1005 : RecordRef;
    BEGIN
      TempBlobReqParamStore.GET(ReportID);
      TempBlobReqParamStore.SETRECFILTER;
      TempBlobReqParamStore.CALCFIELDS(Blob);
      // Use the request page helper to parse the parameters and set the view to the RecordRef and the Record
      RecordRef.OPEN(TableNumber);
      RequestPageParametersHelper.ConvertParametersToFilters(RecordRef,TempBlobReqParamStore);

      EXIT(RecordRef.GETVIEW);
    END;

    LOCAL PROCEDURE GetRequestParameters@23();
    VAR
      SMTPMailSetup@1001 : Record 409;
      DataVariant@1002 : Variant;
      RequestPageParameters@1000 : Text;
      FilterGroup@1003 : Integer;
      LocalRepId@1004 : Integer;
    BEGIN
      ReportSelections.SETFILTER("Report ID",'<>0');
      ReportSelections.FINDFIRST;

      IF ReportSelections.FINDSET THEN
        REPEAT
          LocalRepId := ReportSelections."Report ID";
          // If we're at this point, and we're set in test mode with XML output - run the report directly from here
          // This is done to retain compatibility with report testing (which uses RequestPage.SaveAsXML and needs the traditional output options buttons)
          // XML output can't use the layouts anyways.
          IF IsTestMode AND OverrideOutput AND (OutputType = OutputType::XML) THEN BEGIN
            DataVariant := ReportDataRecordRef;
            REPORT.RUNMODAL(LocalRepId,TRUE,FALSE,DataVariant);
            ERROR(''); // Exit early in an uninitialized state, prevents the full initialization flag from being set
          END;
          COMMIT;
          RequestPageParameters := RunRequestPage(LocalRepId);
          // If the user cancelled out of the request page - exclude this report ID from processing:
          IF RequestPageParameters = '' THEN BEGIN
            // Advance to the next open filtergroup outside of the system range
            FilterGroup := ReportSelections.FILTERGROUP;
            IF ReportSelections.HASFILTER OR (ReportSelections.FILTERGROUP < 10) THEN
              REPEAT
                ReportSelections.FILTERGROUP(ReportSelections.FILTERGROUP + 1)
              UNTIL NOT ReportSelections.HASFILTER AND (ReportSelections.FILTERGROUP >= 10);
            ReportSelections.SETFILTER("Report ID",STRSUBSTNO('<>%1',LocalRepId));
            ReportSelections.FILTERGROUP(FilterGroup);
            BREAK;
          END;

          StoreRequestParameters(RequestPageParameters);
          SaveReportRequestPageParameters(LocalRepId,RequestPageParameters);
          // Validate output type and get a file save path, if necessary, only prompt for windows clients that are not in test mode
          SetOutputType(LocalRepId);
          IF FileManagement.IsWindowsClient AND (Path = '') AND (NOT IsTestMode) AND
             (OutputType IN [OutputType::PDF,OutputType::Excel,OutputType::Word,OutputType::XML])
          THEN
            FileManagement.SelectFolderDialog(SaveFolderMsg,Path);

          // Use the temp path if we're set in test mode and the path wasn't already set
          IF (Path = '') AND IsTestMode THEN
            Path := TEMPORARYPATH;

          // If email is chosen, ensure that SMTP is set up
          IF (OutputType = OutputType::Email) AND NOT SMTPMailSetup.GetSetup AND NOT SupressOutput THEN
            ERROR(SMTPNotSetupErr);
        UNTIL ReportSelections.NEXT = 0;
      Initialized := TRUE;
    END;

    LOCAL PROCEDURE SetOutputType@33(ReportID@1002 : Integer);
    VAR
      OutputMethod@1000 : Text;
      OptionInt@1001 : Integer;
    BEGIN
      // Don't set based on the report ID if we're overriding the output type (for tests, output-specific functions)
      IF OverrideOutput THEN
        EXIT;
      // The request page should have the appropriate parameters set for the chosen output method
      OutputMethod := GetOptionValueFromRequestPage(GetRequestParametersText(ReportID),'ChosenOutputMethod');
      IF OutputMethod <> '' THEN BEGIN
        IF NOT EVALUATE(OptionInt,OutputMethod) THEN
          ERROR(OutputNotSupportedErr);
      END ELSE
        ERROR(OutputNotSupportedErr);

      SetOutputOption(OptionInt);
    END;

    LOCAL PROCEDURE SetReportUsage@37(ReportSelectionUsage@1000 : Integer);
    BEGIN
      ReportSelections.SETRANGE(Usage,ReportSelectionUsage);
      CustomReportSelection.SETRANGE(Usage,ReportSelectionUsage);
    END;

    [External]
    PROCEDURE SetOutputSupression@14(SupressOutputFlag@1000 : Boolean);
    BEGIN
      SupressOutput := SupressOutputFlag;
    END;

    LOCAL PROCEDURE StoreRequestParameters@15(Parameters@1000 : Text);
    VAR
      OutStr@1001 : OutStream;
      ReportID@1002 : Integer;
    BEGIN
      EVALUATE(ReportID,RequestPageParametersHelper.GetReportID(Parameters));
      // Insert or Modify - based on if it exists already or not
      IF TempBlobReqParamStore.GET(ReportID) THEN BEGIN
        TempBlobReqParamStore.Blob.CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(Parameters);
        TempBlobReqParamStore.MODIFY;
      END ELSE BEGIN
        TempBlobReqParamStore.INIT;
        TempBlobReqParamStore.Blob.CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(Parameters);
        TempBlobReqParamStore."Primary Key" := ReportID;
        TempBlobReqParamStore.INSERT;
      END;
      COMMIT;
    END;

    LOCAL PROCEDURE GetRequestParametersText@19(ReportID@1000 : Integer) : Text;
    VAR
      InStr@1001 : InStream;
      ReqPageXML@1004 : Text;
    BEGIN
      TempBlobReqParamStore.GET(ReportID);
      TempBlobReqParamStore.CALCFIELDS(Blob);
      TempBlobReqParamStore.Blob.CREATEINSTREAM(InStr);
      InStr.READTEXT(ReqPageXML);
      EXIT(ReqPageXML);
    END;

    LOCAL PROCEDURE AddFileToClientZip@82(TempFileName@1000 : Text;ClientFileName@1001 : Text);
    BEGIN
      IF STRLEN(TempFileName) > 250 THEN
        ERROR(PathLengthErr,TempFileName);

      IF STRLEN(ClientFileName) > 250 THEN
        ERROR(PathLengthErr,ClientFileName);

      // Ensure we have a zip file object
      IF ZipFileName = '' THEN
        ZipFileName := FileManagement.CreateZipArchiveObject;

      TempNameValueBuffer.SETRANGE(Name,COPYSTR(ClientFileName,1,250));
      IF NOT TempNameValueBuffer.FINDFIRST THEN
        TempNameValueBuffer.AddNewEntry(COPYSTR(ClientFileName,1,250),COPYSTR(TempFileName,1,250));

      AnyOutputExists := TRUE;
    END;

    [External]
    PROCEDURE CallReportSaveAs@55(ReportID@1001 : Integer;RequestParameterText@1002 : Text;ReportFormatValue@1003 : ReportFormat;VAR FileStream@1004 : OutStream;VAR RecRef@1005 : RecordRef) : Boolean;
    VAR
      ReportSaved@1000 : Boolean;
    BEGIN
      ReportSaved := REPORT.SAVEAS(ReportID,RequestParameterText,ReportFormatValue,FileStream,RecRef);

      IF NOT ReportSaved THEN
        EXIT(FALSE);

      IF NOT WordOutputXmlHasDataVerified THEN
        EXIT(TRUE);

      EXIT(WordOutputXmlHasData);
    END;

    LOCAL PROCEDURE BoundCallReportSaveAs@62(ReportID@1001 : Integer;RequestParameterText@1002 : Text;ReportFormatValue@1003 : ReportFormat;VAR FileStream@1004 : OutStream;VAR RecRef@1005 : RecordRef) : Boolean;
    VAR
      CustomLayoutReporting@1000 : Codeunit 8800;
    BEGIN
      BINDSUBSCRIPTION(CustomLayoutReporting);
      EXIT(CustomLayoutReporting.CallReportSaveAs(ReportID,RequestParameterText,ReportFormatValue,FileStream,RecRef))
    END;

    LOCAL PROCEDURE IsWordLayout@88(ReportID@1000 : Integer;CustomReportLayoutCode@1001 : Code[20]) : Boolean;
    VAR
      CustomReportLayout@1002 : Record 9650;
    BEGIN
      IF CustomReportLayoutCode <> '' THEN BEGIN
        CustomReportLayout.Code := CustomReportLayoutCode;
        IF CustomReportLayout.FIND('=') THEN
          EXIT(CustomReportLayout.Type = CustomReportLayout.Type::Word);

        EXIT(REPORT.DEFAULTLAYOUT(ReportID) = DEFAULTLAYOUT::Word);
      END;
      EXIT(REPORT.DEFAULTLAYOUT(ReportID) = DEFAULTLAYOUT::Word)
    END;

    LOCAL PROCEDURE SetReportDataItem@1051(VAR DataRecordRef@1065 : RecordRef;SourceJoinFieldName@1066 : Text;DataRecordJoinTable@1067 : Integer;IteratorTableFieldName@1069 : Text;DataItemTableSameAsIterator@1068 : Boolean);
    VAR
      Field@1000 : Record 2000000041;
      TypeHelper@1001 : Codeunit 10;
      ConfigValidateManagement@1076 : Codeunit 8617;
      RelationTable@1077 : Integer;
      RelationField@1079 : Integer;
    BEGIN
      // Copy the RecordRef so as to not disturb the original
      ReportDataRecordRef := DataRecordRef.DUPLICATE;

      // Find the fields that relate the iterator to the data record - based on caption:
      Field.SETRANGE(FieldName,SourceJoinFieldName);
      IF TypeHelper.FindFields(ReportDataRecordRef.NUMBER,Field) THEN
        ReportDataIteratorFieldRef := ReportDataRecordRef.FIELD(Field."No.");
      // If the tables are different, 'join' using the filter of the data item passed in.
      IF DataItemTableSameAsIterator THEN BEGIN
        IteratorRecordRef.OPEN(ReportDataRecordRef.NUMBER);
        IteratorJoinFieldRef := IteratorRecordRef.FIELD(ReportDataIteratorFieldRef.NUMBER);
        SetNextGroupFilter(IteratorRecordRef,IteratorJoinFieldRef,ReportDataIteratorFieldRef.GETFILTER);
        ReportDataAndIteratorDiffer := FALSE;
      END ELSE BEGIN
        ConfigValidateManagement.GetRelationInfoByIDs(
          ReportDataRecordRef.NUMBER,ReportDataIteratorFieldRef.NUMBER,RelationTable,RelationField);
        IteratorRecordRef.OPEN(DataRecordJoinTable);
        Field.RESET;
        Field.SETRANGE(FieldName,IteratorTableFieldName);
        IF TypeHelper.FindFields(IteratorRecordRef.NUMBER,Field) THEN
          IteratorJoinFieldRef := IteratorRecordRef.FIELD(Field."No.");
        ReportDataAndIteratorDiffer := TRUE;
      END;

      CustomReportSelection.SETRANGE("Source Type",IteratorRecordRef.NUMBER);
    END;

    LOCAL PROCEDURE RemoveEmptyFile@1050(FileName@1060 : Text) : Boolean;
    VAR
      File@1061 : File;
    BEGIN
      // This function cleans up empty files, allowing us to remove reports that do not save correctly or error out/have no output.
      File.OPEN(FileName);
      IF File.LEN = 0 THEN BEGIN
        File.CLOSE;
        ERASE(FileName);
        EXIT(TRUE);
      END;
      File.CLOSE;
      EXIT(FALSE);
    END;

    [External]
    PROCEDURE IsWebClient@18() : Boolean;
    BEGIN
      IF TestModeWebClient THEN
        EXIT(TRUE);
      EXIT(FileManagement.IsWebClient);
    END;

    [External]
    PROCEDURE SetOutputFileBaseName@20(FileBaseName@1000 : Text);
    BEGIN
      // Sets a text base name for the output files:
      // e.g. code calling reports with usage of 'Statement' would set 'Statement' here
      OutputFileBaseName := FileBaseName;
    END;

    PROCEDURE SetTestMode@35(TestMode@1000 : Boolean);
    VAR
      TempBlob@1002 : Record 99008535;
      BlobOutStream@1001 : OutStream;
    BEGIN
      // Sets test mode for this codeunit - enables unit test scenarios
      TempBlob.INIT;
      TempBlob.RESET;
      TempBlob."Primary Key" := CODEUNIT::"Custom Layout Reporting";
      IF TempBlob.FIND THEN
        TempBlob.DELETE;

      TempBlob.Blob.CREATEOUTSTREAM(BlobOutStream);
      BlobOutStream.WRITETEXT(FORMAT(TestMode));
      TempBlob.INSERT;
      COMMIT;

      OverrideOutput := TestMode;
    END;

    LOCAL PROCEDURE IsTestMode@36() : Boolean;
    VAR
      TempBlob@1003 : Record 99008535;
      TestModeInStream@1002 : InStream;
      ReadText@1001 : Text[10];
      ReadBoolean@1000 : Boolean;
    BEGIN
      // Check to see if the test mode flag is set (usually via test codeunits before calling this codeunit directly)
      // Alternatively, check tempblob for a sentinel value (set via test codeunits that do not/cannot call this codeunit directly)
      ReadBoolean := FALSE;
      IF TempBlob.GET(8800) THEN BEGIN
        TempBlob.CALCFIELDS(Blob);
        TempBlob.Blob.CREATEINSTREAM(TestModeInStream);
        TestModeInStream.READTEXT(ReadText,10);
        EVALUATE(ReadBoolean,ReadText);
      END;
      EXIT(ReadBoolean);
    END;

    [External]
    PROCEDURE SetTestModeWebClient@38(TestModeSpoofWebClient@1000 : Boolean);
    BEGIN
      TestModeWebClient := TestModeSpoofWebClient;
    END;

    LOCAL PROCEDURE ResolveCustomReportLayoutCode@46(VAR CustomReportSelection@1000 : Record 9657) : Code[20];
    BEGIN
      // Given a custom report selection, return the custom layout, unless report ID  = 0, then resolve to the appropriate company-wide layout for the report ID
      IF CustomReportSelection."Custom Report Layout Code" <> '' THEN
        EXIT(CustomReportSelection."Custom Report Layout Code");

      // If we don't have a custom layout defined in this selection record, get the default for the report number
      IF ReportLayoutSelection.GET(CustomReportSelection."Report ID",COMPANYNAME) THEN
        EXIT(ReportLayoutSelection."Custom Report Layout Code");

      EXIT(''); // We haven't found any custom report layouts
    END;

    LOCAL PROCEDURE ResolveEmailBodyLayoutCode@54(VAR CustomReportSelection@1001 : Record 9657;VAR ReportSelections@1000 : Record 77) : Code[20];
    BEGIN
      IF CustomReportSelection."Use for Email Body" THEN
        EXIT(CustomReportSelection."Email Body Layout Code");

      IF ReportSelections."Use for Email Body" THEN
        EXIT(ReportSelections."Email Body Layout Code");

      EXIT(''); // We haven't found any custom report layouts
    END;

    [Internal]
    PROCEDURE InitializeData@49(ReportSelectionUsage@1005 : Integer;VAR DataRecordRef@1004 : RecordRef;SourceJoinFieldName@1003 : Text;DataRecordJoinTable@1002 : Integer;IteratorTableFieldName@1001 : Text;DataItemTableSameAsIterator@1000 : Boolean);
    BEGIN
      // Initialize parameters and request pages, but do not run the reports yet
      SetReportUsage(ReportSelectionUsage);
      SetReportDataItem(DataRecordRef,SourceJoinFieldName,DataRecordJoinTable,IteratorTableFieldName,DataItemTableSameAsIterator);
      GetRequestParameters;
    END;

    [External]
    PROCEDURE HasRequestParameterData@50(ReportID@1000 : Integer) : Boolean;
    BEGIN
      // Allows the caller to determine if valid request parameters XML is stored for the given report ID.
      // This is mostly useful to determine if a given report's request page has been canceled or not.
      EXIT(TempBlobReqParamStore.GET(ReportID));
    END;

    LOCAL PROCEDURE GetKeyFieldRef@53(VAR TableRecordRef@1001 : RecordRef;VAR KeyFieldRef@1000 : FieldRef) : Boolean;
    VAR
      DataTypeManagement@1002 : Codeunit 701;
    BEGIN
      CASE TableRecordRef.NUMBER OF
        DATABASE::Customer,
        DATABASE::Vendor:
          BEGIN
            DataTypeManagement.FindFieldByName(TableRecordRef,KeyFieldRef,'No.');
            EXIT(TRUE);
          END;
        ELSE
          EXIT(FALSE);
      END;
    END;

    LOCAL PROCEDURE GetNameFieldRef@52(VAR TableRecordRef@1001 : RecordRef;VAR NameFieldRef@1000 : FieldRef) : Boolean;
    VAR
      DataTypeManagement@1002 : Codeunit 701;
    BEGIN
      CASE TableRecordRef.NUMBER OF
        DATABASE::Customer,
        DATABASE::Vendor:
          BEGIN
            DataTypeManagement.FindFieldByName(TableRecordRef,NameFieldRef,'Name');
            EXIT(TRUE);
          END;
        ELSE
          EXIT(FALSE);
      END;
    END;

    LOCAL PROCEDURE FindNextEmptyFilterGroup@41(VAR RecordRef@1000 : RecordRef) : Integer;
    VAR
      FilterGroup@1001 : Integer;
      StartingGroup@1002 : Integer;
    BEGIN
      // Finds the next empty filter group, with a minimum of group 10 to ensure we're in a non-system group.
      StartingGroup := RecordRef.FILTERGROUP;
      FilterGroup := StartingGroup;

      IF FilterGroup < 10 THEN
        FilterGroup := 10;

      // Find the next empty group
      RecordRef.FILTERGROUP(FilterGroup);
      IF RecordRef.HASFILTER THEN
        REPEAT
          FilterGroup += 1;
          RecordRef.FILTERGROUP(FilterGroup);
        UNTIL NOT RecordRef.HASFILTER;

      // Reset the group back to the original value
      RecordRef.FILTERGROUP(StartingGroup);

      EXIT(FilterGroup);
    END;

    LOCAL PROCEDURE SetNextGroupFilter@56(VAR RecordRef@1000 : RecordRef;VAR FieldRef@1004 : FieldRef;Filter@1001 : Text) : Integer;
    VAR
      NextGroup@1002 : Integer;
    BEGIN
      NextGroup := FindNextEmptyFilterGroup(RecordRef);
      SetGroupFilter(RecordRef,FieldRef,Filter,NextGroup);
      EXIT(NextGroup);
    END;

    LOCAL PROCEDURE SetGroupFilter@87(VAR RecordRef@1000 : RecordRef;VAR FieldRef@1001 : FieldRef;Filter@1002 : Text;GroupNumber@1003 : Integer);
    VAR
      FilterGroup@1004 : Integer;
    BEGIN
      FilterGroup := RecordRef.FILTERGROUP;
      RecordRef.FILTERGROUP(GroupNumber);
      FieldRef.SETFILTER(Filter);
      RecordRef.FILTERGROUP(FilterGroup);
    END;

    LOCAL PROCEDURE CleanupTempFiles@16();
    VAR
      DeleteError@1000 : Boolean;
    BEGIN
      // Sometimes file handles are kept by .NET - we try to delete what we can.
      IF TempEraseFileNameValueBuffer.FINDSET THEN
        REPEAT
          IF NOT TryDeleteFile(TempEraseFileNameValueBuffer.Name) THEN
            DeleteError := TRUE;
        UNTIL TempEraseFileNameValueBuffer.NEXT = 0;

      IF DeleteError THEN
        ERROR('');
    END;

    [TryFunction]
    LOCAL PROCEDURE TryDeleteFile@17(FileName@1000 : Text);
    BEGIN
      FileManagement.DeleteServerFile(FileName);
    END;

    [TryFunction]
    LOCAL PROCEDURE TryCreateFileStream@28(VAR File@1000 : File;ReportID@1003 : Integer;VAR TempFilePath@1002 : Text[250];VAR FileName@1004 : Text[250];VAR FileStream@1006 : OutStream;Extension@1005 : Text);
    VAR
      FileManagement@1001 : Codeunit 419;
    BEGIN
      TempFilePath := COPYSTR(FileManagement.ServerTempFileName(Extension),1,250);

      FileName := GenerateFileNameForReport(ReportID,Extension,'',FALSE);

      File.CREATE(TempFilePath);
      File.CREATEOUTSTREAM(FileStream);
    END;

    [TryFunction]
    LOCAL PROCEDURE TryEmailReport@39(TempFilePath@1001 : Text[250];FileName@1002 : Text[250];TempEmailBodyFilePath@1003 : Text[250];VAR CustomReportSelection@1004 : Record 9657;VAR FieldRef2@1005 : FieldRef);
    VAR
      DocumentMailing@1000 : Codeunit 260;
      MailSent@1006 : Boolean;
    BEGIN
      MailSent := DocumentMailing.EmailFile(
          COPYSTR(TempFilePath,1,250),FileName,TempEmailBodyFilePath,'',CustomReportSelection."Send To Email",
          STRSUBSTNO('%1',FieldRef2.VALUE),TRUE,CustomReportSelection.Usage);
      IF EXISTS(TempFilePath) THEN BEGIN
        TempEraseFileNameValueBuffer.AddNewEntry(TempFilePath,FORMAT(FieldRef2.VALUE));
        IF NOT MailSent THEN
          AddFileToClientZip(TempFilePath,FileName);
      END;
      IF EXISTS(TempEmailBodyFilePath) THEN
        TempEraseFileNameValueBuffer.AddNewEntry(TempEmailBodyFilePath,'');
    END;

    LOCAL PROCEDURE CreateReportWithExtension@34(VAR DataRecRef@1001 : RecordRef;ReportID@1000 : Integer;ReportFormatType@1002 : ReportFormat;VAR FileName@1003 : Text[250]) : Text[250];
    VAR
      File@1006 : File;
      FileStream@1005 : OutStream;
      TempFilePath@1004 : Text[250];
    BEGIN
      CASE ReportFormatType OF
        REPORTFORMAT::Pdf:
          BEGIN
            TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'pdf');
            TempEmailNameValueBuffer.SETRANGE(Name,FileName);
            IF NOT TempEmailNameValueBuffer.FINDFIRST THEN
              IF BoundCallReportSaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Pdf,FileStream,DataRecRef) THEN BEGIN
                TempEmailNameValueBuffer.AddNewEntry(COPYSTR(FileName,1,250),COPYSTR(TempFilePath,1,250));
                File.CLOSE;
                EXIT(TempFilePath);
              END;
            File.CLOSE;
            EXIT('');
          END;
        REPORTFORMAT::Html:
          BEGIN
            TryCreateFileStream(File,ReportID,TempFilePath,FileName,FileStream,'html');
            TempEmailNameValueBuffer.SETRANGE(Name,FileName);
            IF NOT TempEmailNameValueBuffer.FINDFIRST THEN
              IF BoundCallReportSaveAs(ReportID,GetRequestParametersText(ReportID),REPORTFORMAT::Html,FileStream,DataRecRef) THEN BEGIN
                TempEmailNameValueBuffer.AddNewEntry(COPYSTR(FileName,1,250),COPYSTR(TempFilePath,1,250));
                File.CLOSE;
                EXIT(TempFilePath);
              END;
            File.CLOSE;
            EXIT('');
          END;
        ELSE
          ERROR(ReportFormatNotSupportedErr,ReportFormatType);
      END;
    END;

    LOCAL PROCEDURE SetIteratorJoinFieldRef@44();
    VAR
      Vendor@1000 : Record 23;
      Customer@1001 : Record 18;
      GenJournalLine@1002 : Record 81;
      IteratorTableFieldName@1003 : Text;
      i@1004 : Integer;
      DataRecordJoinTable@1005 : Integer;
    BEGIN
      BalAcctTypeFieldRef := ReportDataRecordRef.FIELD(63);
      AcctTypeFieldRef := ReportDataRecordRef.FIELD(3);

      CASE FORMAT(BalAcctTypeFieldRef.VALUE) OF
        FORMAT(GenJournalLine."Bal. Account Type"::Vendor):
          BEGIN
            DataRecordJoinTable := DATABASE::Vendor;
            IteratorTableFieldName := Vendor.FIELDNAME("No.");
          END;
        FORMAT(GenJournalLine."Bal. Account Type"::Customer):
          BEGIN
            DataRecordJoinTable := DATABASE::Customer;
            IteratorTableFieldName := Customer.FIELDNAME("No.");
          END;
        FORMAT(GenJournalLine."Bal. Account Type"::"Bank Account"):
          CASE FORMAT(AcctTypeFieldRef.VALUE) OF
            FORMAT(GenJournalLine."Account Type"::Customer):
              BEGIN
                DataRecordJoinTable := DATABASE::Customer;
                IteratorTableFieldName := Customer.FIELDNAME("No.");
              END;
            FORMAT(GenJournalLine."Account Type"::Vendor):
              BEGIN
                DataRecordJoinTable := DATABASE::Vendor;
                IteratorTableFieldName := Vendor.FIELDNAME("No.");
              END;
          END;
      END;
      IF DataRecordJoinTable <> 0 THEN BEGIN
        IteratorRecordRef.CLOSE;
        IteratorRecordRef.OPEN(DataRecordJoinTable);
        FOR i := 1 TO IteratorRecordRef.FIELDCOUNT DO
          IF IteratorRecordRef.FIELD(i).NAME = IteratorTableFieldName THEN BEGIN
            IteratorJoinFieldRef := IteratorRecordRef.FIELD(i);
            BREAK;
          END;
      END;
    END;

    PROCEDURE RunRequestPage@60(ReportId@1000 : Integer) : Text;
    VAR
      SavedParameters@1001 : Text;
    BEGIN
      IF PredefinedRequestParameters <> '' THEN
        EXIT(PredefinedRequestParameters);

      SavedParameters := GetReportRequestPageParameters(ReportId);
      EXIT(REPORT.RUNREQUESTPAGE(ReportId,SavedParameters));
    END;

    LOCAL PROCEDURE LogSimpleError@65(ErrorText@1000 : Text);
    BEGIN
      ErrorMessageManagement.LogSimpleErrorMessage(ErrorText);
    END;

    LOCAL PROCEDURE LogAndClearLastError@64(ReportCaption@1001 : Text;RecID@1000 : RecordID);
    BEGIN
      IF GETLASTERRORTEXT <> '' THEN BEGIN
        LogSimpleError(STRSUBSTNO(ErrorForDataOccuredErr,GETLASTERRORTEXT,ReportCaption,RecID));
        CLEARLASTERROR;
      END;
    END;

    PROCEDURE GetReportRequestPageParameters@51(ReportID@1002 : Integer) XMLTxt : Text;
    VAR
      ObjectOptions@1000 : Record 2000000196;
      InStr@1001 : InStream;
    BEGIN
      IF IgnoreRequestParameters THEN
        EXIT('');

      IF NOT ObjectOptions.GET(LastUsedTxt,ReportID,ObjectOptions."Object Type"::Report,USERID,COMPANYNAME) THEN
        EXIT('');
      ObjectOptions.CALCFIELDS("Option Data");
      ObjectOptions."Option Data".CREATEINSTREAM(InStr);
      InStr.READTEXT(XMLTxt);
      EXIT(XMLTxt);
    END;

    LOCAL PROCEDURE SaveReportRequestPageParameters@40(ReportID@1000 : Integer;XMLText@1001 : Text);
    VAR
      ObjectOptions@1002 : Record 2000000196;
      OutStr@1003 : OutStream;
    BEGIN
      IF NOT IsObjectOptionsInsertDeleteAllowed THEN
        EXIT;

      IF IgnoreRequestParameters THEN
        EXIT;

      IF XMLText = '' THEN
        EXIT;

      WITH ObjectOptions DO BEGIN
        IF GET(LastUsedTxt,ReportID,"Object Type"::Report,USERID,COMPANYNAME) THEN
          DELETE;
        INIT;
        "Parameter Name" := LastUsedTxt;
        "Object Type" := "Object Type"::Report;
        "Object ID" := ReportID;
        "User Name" := USERID;
        "Company Name" := COMPANYNAME;
        "Created By" := USERID;
        "Option Data".CREATEOUTSTREAM(OutStr);
        OutStr.WRITETEXT(XMLText);
        INSERT;
      END;
    END;

    [EventSubscriber(Codeunit,9651,OnBeforeMergeDocument)]
    LOCAL PROCEDURE VerifyXmlContainsDatasetOnBeforeMergeDocument@47(ReportID@1000 : Integer;ReportAction@1002 : 'SaveAsPdf,SaveAsWord,SaveAsExcel,Preview,Print,SaveAsHtml';InStrXmlData@1003 : InStream;PrinterName@1004 : Text;OutStream@1005 : OutStream;VAR Handled@1006 : Boolean;IsFileNameBlank@1009 : Boolean);
    VAR
      DocumentReportMgt@1010 : Codeunit 9651;
      CancelVerification@1001 : Boolean;
    BEGIN
      OnBeforeVerifyXmlContainsDataset(CancelVerification);
      IF CancelVerification THEN
        EXIT;

      WordOutputXmlHasData := DocumentReportMgt.IsStreamHasDataset(InStrXmlData);

      WordOutputXmlHasDataVerified := TRUE;
    END;

    [External]
    PROCEDURE CheckForCustomLayoutReportingJob@1170000001();
    VAR
      CustomerLayoutStatement@1000 : Codeunit 8810;
    BEGIN
      CustomerLayoutStatement.CheckReportRunningInBackground;
    END;

    [External]
    PROCEDURE IsBackgound@1170000002() : Boolean;
    BEGIN
      EXIT(ClientTypeManagement.IsBackground);
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeVerifyXmlContainsDataset@57(VAR CancelVerification@1000 : Boolean);
    BEGIN
    END;

    LOCAL PROCEDURE IsObjectOptionsInsertDeleteAllowed@58() : Boolean;
    VAR
      ObjectOptions@1000 : Record 2000000196;
      User@1001 : Record 2000000120;
    BEGIN
      IF NOT ObjectOptions.WRITEPERMISSION THEN
        EXIT(FALSE);

      IF NOT User.GET(USERSECURITYID) THEN
        EXIT(TRUE);

      EXIT(User."License Type" <> User."License Type"::"Limited User");
    END;

    PROCEDURE SetIgnoreRequestParameters@59(IgnoreParams@1000 : Boolean);
    BEGIN
      IgnoreRequestParameters := IgnoreParams;
    END;

    PROCEDURE SetPredefinedRequestParameters@61(NewPredefinedRequestParameters@1000 : Text);
    BEGIN
      PredefinedRequestParameters := NewPredefinedRequestParameters;
    END;

    LOCAL PROCEDURE ConvertToRepInboxOutputType@73(VAR ReportInbox@1001 : Record 477;ReportID@1002 : Integer);
    BEGIN
      CASE OutputType OF
        OutputType::Print:
          SetReportInboxOutputTypeForPrint(ReportInbox,ReportID);
        OutputType::Email:
          IF PrintIfEmailIsMissing THEN
            SetReportInboxOutputTypeForPrint(ReportInbox,ReportID);
        OutputType::PDF:
          ReportInbox."Output Type" := ReportInbox."Output Type"::PDF;
        OutputType::Word:
          ReportInbox."Output Type" := ReportInbox."Output Type"::Word;
        OutputType::Excel:
          ReportInbox."Output Type" := ReportInbox."Output Type"::Excel;
        OutputType::XML,
        OutputType::Preview:
          ERROR(OutputNotSupportedErr);
      END;
    END;

    LOCAL PROCEDURE SetReportInboxOutputTypeForPrint@66(VAR ReportInbox@1001 : Record 477;ReportID@1002 : Integer);
    VAR
      LocalCusRepLayoutCode@1000 : Code[20];
    BEGIN
      LocalCusRepLayoutCode := ResolveCustomReportLayoutCode(CustomReportSelection);
      IF IsWordLayout(ReportID,LocalCusRepLayoutCode) THEN
        ReportInbox."Output Type" := ReportInbox."Output Type"::Word
      ELSE
        ReportInbox."Output Type" := ReportInbox."Output Type"::PDF;
    END;

    LOCAL PROCEDURE SendToReportInbox@63(IsZipFile@1000 : Boolean;ReportID@1005 : Integer);
    VAR
      ReportInbox@1004 : Record 477;
      InputFile@1003 : File;
      InStr@1002 : InStream;
      OutStr@1001 : OutStream;
    BEGIN
      ReportInbox."User ID" := USERID;
      IF IsZipFile THEN BEGIN
        ReportInbox.VALIDATE("Output Type",ReportInbox."Output Type"::Zip);
        InputFile.OPEN(ZipFileName);
      END ELSE BEGIN
        ConvertToRepInboxOutputType(ReportInbox,ReportID);
        InputFile.OPEN(TempNameValueBuffer.Value);
      END;

      InputFile.CREATEINSTREAM(InStr);
      ReportInbox."Report Output".CREATEOUTSTREAM(OutStr);
      COPYSTREAM(OutStr,InStr);
      ReportInbox.Description := ReportInboxReportNameTxt; // bad!
      ReportInbox."Report ID" := ReportID;
      ReportInbox."Report Name" := ReportInboxReportNameTxt; // bad!
      ReportInbox."Created Date-Time" := ROUNDDATETIME(CURRENTDATETIME,60000);
      IF NOT ReportInbox.INSERT(TRUE) THEN
        ReportInbox.MODIFY(TRUE);
    END;

    BEGIN
    {
      This codeunit implements batch printing and custom layout association on a per-object basis.
      Reports may be based on one table, but we may want to sepcific a layout per-customer, or per-vendor.
      This codeunit provides functions to help manage the association between the table that backs the report and the object we want custom layouts on.

      Example code below, for Customer Statements, backed by Customer and associating custom reports per-Customer:

      // Get the RecordRef of the table that will source the data for our report - Statements should be backed by Customer
      RecRef.OPEN(DATABASE::Customer);
      // Set up the association between the Table that is the source of the report and the association to the table we want layouts for
      // In this case, we are using Customer for the report and Customer for the layouts.
      CustomerLayoutReporting.ProcessReport(ReportSelections.Usage::"C.Statement",RecRef,'No.',DATABASE::Customer,'No.',TRUE);
    }
    END.
  }
}

