OBJECT Codeunit 367 CheckManagement
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVW114.03;
  }
  PROPERTIES
  {
    Permissions=TableData 21=rm,
                TableData 25=rm,
                TableData 271=rm,
                TableData 272=rim,
                TableData 5222=rm;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      CheckAlreadyExistsErr@1000 : TextConst '@@@="%1=The check number., %2=The Bank Account table name.";ENU=Check %1 already exists for this %2.;NOR=Sjekk %1 finnes allerede for denne %2.;SVE=Checken %1 finns redan f”r %2.';
      VoidingCheckMsg@1001 : TextConst '@@@="%1=The check number being voided.";ENU=Voiding check %1.;NOR=Kansellerer sjekk %1;SVE=Makulerar check %1.';
      GenJnlLine2@1002 : Record 81;
      BankAcc@1003 : Record 270;
      BankAccLedgEntry2@1004 : Record 271;
      SourceCodeSetup@1006 : Record 242;
      VendorLedgEntry@1009 : Record 25;
      GLEntry@1010 : Record 17;
      CustLedgEntry@1011 : Record 21;
      FALedgEntry@1012 : Record 5601;
      BankAccLedgEntry3@1013 : Record 271;
      EmployeeLedgerEntry@1005 : Record 5222;
      GenJnlPostLine@1014 : Codeunit 12;
      UpdateAnalysisView@1018 : Codeunit 410;
      NextCheckEntryNo@1016 : Integer;
      VoidingCheckErr@1017 : TextConst 'ENU=You cannot Financially Void checks posted in a non-balancing transaction.;NOR=Du kan ikke kansellere sjekker som er bokf›rt i en ikke-balansetransaksjon.;SVE=Du kan inte annullera bokf”rda checkar i en transaktion som inte balanserar.';
      AppliesIDCounter@1019 : Integer;
      PaymentOrRefundErr@1008 : TextConst '@@@="%1=Document Type for the payment., %2=Payment Document Type., %3=Refund Document Type.";ENU=%1 must be either %2 or %3.;NOR=%1 m† v‘re %2 eller %3.';
      BankAccountTypeErr@1015 : TextConst '@@@="%1=Account type., %2=Balancing Account type.";ENU=Either the %1 or the %2 must refer to a Bank Account.;NOR=%1 eller %2 m† referere til en bankkonto.';
      NoAppliedEntryErr@1007 : TextConst 'ENU=Cannot find an applied entry within the specified filter.;NOR=Finner ingen utlignet post innenfor det angitte filteret.;SVE=Det g†r inte att hitta n†gon kopplad transaktion med det angivna filtret.';

    [External]
    PROCEDURE InsertCheck@3(VAR CheckLedgEntry@1000 : Record 272;RecordIdToPrint@1001 : RecordID);
    VAR
      CheckLedgEntry2@1002 : Record 272;
    BEGIN
      IF NextCheckEntryNo = 0 THEN BEGIN
        CheckLedgEntry2.LOCKTABLE;
        CheckLedgEntry2.RESET;
        IF CheckLedgEntry2.FINDLAST THEN
          NextCheckEntryNo := CheckLedgEntry2."Entry No." + 1
        ELSE
          NextCheckEntryNo := 1;
      END;

      CheckLedgEntry2.RESET;
      CheckLedgEntry2.SETCURRENTKEY("Bank Account No.","Entry Status","Check No.");
      CheckLedgEntry2.SETRANGE("Bank Account No.",CheckLedgEntry."Bank Account No.");
      CheckLedgEntry2.SETFILTER(
        "Entry Status",'%1|%2|%3',
        CheckLedgEntry2."Entry Status"::Printed,
        CheckLedgEntry2."Entry Status"::Posted,
        CheckLedgEntry2."Entry Status"::"Financially Voided");
      CheckLedgEntry2.SETRANGE("Check No.",CheckLedgEntry."Document No.");
      IF CheckLedgEntry2.FINDFIRST THEN
        ERROR(CheckAlreadyExistsErr,CheckLedgEntry."Document No.",BankAcc.TABLECAPTION);

      CheckLedgEntry.Open := CheckLedgEntry.Amount <> 0;
      CheckLedgEntry."User ID" := USERID;
      CheckLedgEntry."Entry No." := NextCheckEntryNo;
      CheckLedgEntry."Record ID to Print" := RecordIdToPrint;
      CheckLedgEntry.INSERT;
      NextCheckEntryNo := NextCheckEntryNo + 1;
    END;

    [External]
    PROCEDURE VoidCheck@4(VAR GenJnlLine@1000 : Record 81);
    VAR
      Currency@1001 : Record 4;
      CheckLedgEntry2@1003 : Record 272;
      CheckAmountLCY@1002 : Decimal;
    BEGIN
      OnBeforeVoidCheck(GenJnlLine);

      GenJnlLine.TESTFIELD("Bank Payment Type",GenJnlLine2."Bank Payment Type"::"Computer Check");
      GenJnlLine.TESTFIELD("Check Printed",TRUE);
      GenJnlLine.TESTFIELD("Document No.");

      IF GenJnlLine."Bal. Account No." = '' THEN BEGIN
        GenJnlLine."Check Printed" := FALSE;
        GenJnlLine.DELETE(TRUE);
      END;

      CheckAmountLCY := GenJnlLine."Amount (LCY)";
      IF GenJnlLine."Currency Code" <> '' THEN
        Currency.GET(GenJnlLine."Currency Code");

      GenJnlLine2.RESET;
      GenJnlLine2.SETCURRENTKEY("Journal Template Name","Journal Batch Name","Posting Date","Document No.");
      GenJnlLine2.SETRANGE("Journal Template Name",GenJnlLine."Journal Template Name");
      GenJnlLine2.SETRANGE("Journal Batch Name",GenJnlLine."Journal Batch Name");
      GenJnlLine2.SETRANGE("Posting Date",GenJnlLine."Posting Date");
      GenJnlLine2.SETRANGE("Document No.",GenJnlLine."Document No.");
      IF GenJnlLine2.FIND('-') THEN
        REPEAT
          IF (GenJnlLine2."Line No." > GenJnlLine."Line No.") AND
             (CheckAmountLCY = -GenJnlLine2."Amount (LCY)") AND
             (GenJnlLine2."Currency Code" = '') AND (GenJnlLine."Currency Code" <> '') AND
             (GenJnlLine2."Account Type" = GenJnlLine2."Account Type"::"G/L Account") AND
             (GenJnlLine2."Account No." IN
              [Currency."Conv. LCY Rndg. Debit Acc.",Currency."Conv. LCY Rndg. Credit Acc."]) AND
             (GenJnlLine2."Bal. Account No." = '') AND NOT GenJnlLine2."Check Printed"
          THEN
            GenJnlLine2.DELETE // Rounding correction line
          ELSE BEGIN
            IF GenJnlLine."Bal. Account No." = '' THEN BEGIN
              IF GenJnlLine2."Account No." = '' THEN BEGIN
                GenJnlLine2."Account Type" := GenJnlLine2."Account Type"::"Bank Account";
                GenJnlLine2."Account No." := GenJnlLine."Account No.";
              END ELSE BEGIN
                GenJnlLine2."Bal. Account Type" := GenJnlLine2."Account Type"::"Bank Account";
                GenJnlLine2."Bal. Account No." := GenJnlLine."Account No.";
              END;
              GenJnlLine2.VALIDATE(Amount);
              GenJnlLine2."Bank Payment Type" := GenJnlLine."Bank Payment Type";
            END;
            GenJnlLine2."Document No." := '';
            GenJnlLine2."Document Date" := 0D;
            GenJnlLine2."Check Printed" := FALSE;
            GenJnlLine2.UpdateSource;
            OnBeforeVoidCheckGenJnlLine2Modify(GenJnlLine2,GenJnlLine);
            GenJnlLine2.MODIFY;
          END;
        UNTIL GenJnlLine2.NEXT = 0;

      CheckLedgEntry2.RESET;
      CheckLedgEntry2.SETCURRENTKEY("Bank Account No.","Entry Status","Check No.");
      IF GenJnlLine.Amount <= 0 THEN
        CheckLedgEntry2.SETRANGE("Bank Account No.",GenJnlLine."Account No.")
      ELSE
        CheckLedgEntry2.SETRANGE("Bank Account No.",GenJnlLine."Bal. Account No.");
      CheckLedgEntry2.SETRANGE("Entry Status",CheckLedgEntry2."Entry Status"::Printed);
      CheckLedgEntry2.SETRANGE("Check No.",GenJnlLine."Document No.");
      CheckLedgEntry2.FINDFIRST;
      CheckLedgEntry2."Original Entry Status" := CheckLedgEntry2."Entry Status";
      CheckLedgEntry2."Entry Status" := CheckLedgEntry2."Entry Status"::Voided;
      CheckLedgEntry2."Positive Pay Exported" := FALSE;
      CheckLedgEntry2.Open := FALSE;
      CheckLedgEntry2.MODIFY;

      OnAfterVoidCheck(GenJnlLine,CheckLedgEntry2);
    END;

    [External]
    PROCEDURE FinancialVoidCheck@5(VAR CheckLedgEntry@1000 : Record 272);
    VAR
      ConfirmFinancialVoid@1008 : Page 695;
      AmountToVoid@1003 : Decimal;
      CheckAmountLCY@1004 : Decimal;
      BalanceAmountLCY@1005 : Decimal;
    BEGIN
      OnBeforeFinancialVoidCheck(CheckLedgEntry);

      FinancialVoidCheckPreValidation(CheckLedgEntry);

      CLEAR(ConfirmFinancialVoid);
      ConfirmFinancialVoid.SetCheckLedgerEntry(CheckLedgEntry);
      IF ConfirmFinancialVoid.RUNMODAL <> ACTION::Yes THEN
        EXIT;

      AmountToVoid := CalcAmountToVoid(CheckLedgEntry);

      InitGenJnlLine(
        GenJnlLine2,CheckLedgEntry."Document No.",ConfirmFinancialVoid.GetVoidDate,
        GenJnlLine2."Account Type"::"Bank Account",CheckLedgEntry."Bank Account No.",
        STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No."));
      GenJnlLine2.VALIDATE(Amount,AmountToVoid);
      CheckAmountLCY := GenJnlLine2."Amount (LCY)";
      BalanceAmountLCY := 0;
      GenJnlLine2."Shortcut Dimension 1 Code" := BankAccLedgEntry2."Global Dimension 1 Code";
      GenJnlLine2."Shortcut Dimension 2 Code" := BankAccLedgEntry2."Global Dimension 2 Code";
      GenJnlLine2."Dimension Set ID" := BankAccLedgEntry2."Dimension Set ID";
      GenJnlLine2."Allow Zero-Amount Posting" := TRUE;
      OnFinancialVoidCheckOnBeforePostVoidCheckLine(GenJnlLine2);
      GenJnlPostLine.RunWithCheck(GenJnlLine2);
      OnFinancialVoidCheckOnAfterPostVoidCheckLine(GenJnlLine2,GenJnlPostLine);

      // Mark newly posted entry as cleared for bank reconciliation purposes.
      IF ConfirmFinancialVoid.GetVoidDate = CheckLedgEntry."Check Date" THEN
        ClearBankLedgerEntry(BankAccLedgEntry3);

      InitGenJnlLine(
        GenJnlLine2,CheckLedgEntry."Document No.",ConfirmFinancialVoid.GetVoidDate,
        CheckLedgEntry."Bal. Account Type",CheckLedgEntry."Bal. Account No.",
        STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No."));
      GenJnlLine2.VALIDATE("Currency Code",BankAcc."Currency Code");
      GenJnlLine2."Allow Zero-Amount Posting" := TRUE;
      CASE CheckLedgEntry."Bal. Account Type" OF
        CheckLedgEntry."Bal. Account Type"::"G/L Account":
          FinancialVoidPostGLAccount(GenJnlLine2,BankAccLedgEntry2,CheckLedgEntry,BalanceAmountLCY);
        CheckLedgEntry."Bal. Account Type"::Customer:
          BEGIN
            IF ConfirmFinancialVoid.GetVoidType = 0 THEN BEGIN    // Unapply entry
              IF UnApplyCustInvoices(CheckLedgEntry,ConfirmFinancialVoid.GetVoidDate) THEN
                GenJnlLine2."Applies-to ID" := CheckLedgEntry."Document No.";
            END;
            WITH CustLedgEntry DO BEGIN
              SETCURRENTKEY("Transaction No.");
              SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
              SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
              SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
              IF FINDSET THEN
                REPEAT
                  OnFinancialVoidCheckOnBeforePostCust(GenJnlLine2,CustLedgEntry,BalanceAmountLCY);
                  CALCFIELDS("Original Amount");
                  SetGenJnlLine(
                    GenJnlLine2,-"Original Amount","Currency Code",CheckLedgEntry."Document No.",
                    "Global Dimension 1 Code","Global Dimension 2 Code","Dimension Set ID");
                  BalanceAmountLCY := BalanceAmountLCY + GenJnlLine2."Amount (LCY)";
                  OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
                  GenJnlPostLine.RunWithCheck(GenJnlLine2);
                  OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
                UNTIL NEXT = 0;
            END;
          END;
        CheckLedgEntry."Bal. Account Type"::Vendor:
          BEGIN
            IF ConfirmFinancialVoid.GetVoidType = 0 THEN BEGIN    // Unapply entry
              IF UnApplyVendInvoices(CheckLedgEntry,ConfirmFinancialVoid.GetVoidDate) THEN
                GenJnlLine2."Applies-to ID" := CheckLedgEntry."Document No.";
            END;
            WITH VendorLedgEntry DO BEGIN
              SETCURRENTKEY("Transaction No.");
              SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
              SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
              SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
              IF FINDSET THEN
                REPEAT
                  OnFinancialVoidCheckOnBeforePostVend(GenJnlLine2,VendorLedgEntry,BalanceAmountLCY);
                  CALCFIELDS("Original Amount");
                  SetGenJnlLine(
                    GenJnlLine2,-"Original Amount","Currency Code",CheckLedgEntry."Document No.",
                    "Global Dimension 1 Code","Global Dimension 2 Code","Dimension Set ID");
                  BalanceAmountLCY := BalanceAmountLCY + GenJnlLine2."Amount (LCY)";
                  OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
                  GenJnlPostLine.RunWithCheck(GenJnlLine2);
                  OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
                UNTIL NEXT = 0;
            END;
          END;
        CheckLedgEntry."Bal. Account Type"::"Bank Account":
          WITH BankAccLedgEntry3 DO BEGIN
            SETCURRENTKEY("Transaction No.");
            SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
            SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
            SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
            SETFILTER("Entry No.",'<>%1',BankAccLedgEntry2."Entry No.");
            IF FINDSET THEN
              REPEAT
                GenJnlLine2.VALIDATE(Amount,-Amount);
                BalanceAmountLCY := BalanceAmountLCY + GenJnlLine2."Amount (LCY)";
                GenJnlLine2."Shortcut Dimension 1 Code" := "Global Dimension 1 Code";
                GenJnlLine2."Shortcut Dimension 2 Code" := "Global Dimension 2 Code";
                GenJnlLine2."Dimension Set ID" := "Dimension Set ID";
                OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
                GenJnlPostLine.RunWithCheck(GenJnlLine2);
                OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
              UNTIL NEXT = 0;
          END;
        CheckLedgEntry."Bal. Account Type"::"Fixed Asset":
          WITH FALedgEntry DO BEGIN
            SETCURRENTKEY("Transaction No.");
            SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
            SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
            SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
            IF FINDSET THEN
              REPEAT
                GenJnlLine2.VALIDATE(Amount,-Amount);
                BalanceAmountLCY := BalanceAmountLCY + GenJnlLine2."Amount (LCY)";
                GenJnlLine2."Shortcut Dimension 1 Code" := "Global Dimension 1 Code";
                GenJnlLine2."Shortcut Dimension 2 Code" := "Global Dimension 2 Code";
                GenJnlLine2."Dimension Set ID" := "Dimension Set ID";
                OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
                GenJnlPostLine.RunWithCheck(GenJnlLine2);
                OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
              UNTIL NEXT = 0;
          END;
        CheckLedgEntry."Bal. Account Type"::Employee:
          BEGIN
            IF ConfirmFinancialVoid.GetVoidType = 0 THEN BEGIN    // Unapply entry
              IF UnApplyEmpInvoices(CheckLedgEntry,ConfirmFinancialVoid.GetVoidDate) THEN
                GenJnlLine2."Applies-to ID" := CheckLedgEntry."Document No.";
            END;
            WITH EmployeeLedgerEntry DO BEGIN
              SETCURRENTKEY("Transaction No.");
              SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
              SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
              SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
              IF FINDSET THEN
                REPEAT
                  OnFinancialVoidCheckOnBeforePostEmp(GenJnlLine2,EmployeeLedgerEntry);
                  CALCFIELDS("Original Amount");
                  SetGenJnlLine(
                    GenJnlLine2,-"Original Amount","Currency Code",CheckLedgEntry."Document No.",
                    "Global Dimension 1 Code","Global Dimension 2 Code","Dimension Set ID");
                  BalanceAmountLCY := BalanceAmountLCY + GenJnlLine2."Amount (LCY)";
                  OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
                  GenJnlPostLine.RunWithCheck(GenJnlLine2);
                  OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
                UNTIL NEXT = 0;
            END;
          END;
        ELSE BEGIN
          GenJnlLine2."Bal. Account Type" := CheckLedgEntry."Bal. Account Type";
          GenJnlLine2.VALIDATE("Bal. Account No.",CheckLedgEntry."Bal. Account No.");
          GenJnlLine2."Shortcut Dimension 1 Code" := '';
          GenJnlLine2."Shortcut Dimension 2 Code" := '';
          GenJnlLine2."Dimension Set ID" := 0;
          OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine2,CheckLedgEntry);
          GenJnlPostLine.RunWithCheck(GenJnlLine2);
          OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
        END;
      END;

      IF ConfirmFinancialVoid.GetVoidDate = CheckLedgEntry."Check Date" THEN BEGIN
        BankAccLedgEntry2.Open := FALSE;
        BankAccLedgEntry2."Remaining Amount" := 0;
        BankAccLedgEntry2."Statement Status" := BankAccLedgEntry2."Statement Status"::Closed;
        BankAccLedgEntry2.MODIFY;
      END;

      // rounding error from currency conversion
      IF CheckAmountLCY + BalanceAmountLCY <> 0 THEN
        PostRoundingAmount(BankAcc,CheckLedgEntry,ConfirmFinancialVoid.GetVoidDate,-(CheckAmountLCY + BalanceAmountLCY));

      MarkCheckEntriesVoid(CheckLedgEntry,ConfirmFinancialVoid.GetVoidDate);
      COMMIT;
      UpdateAnalysisView.UpdateAll(0,TRUE);

      OnAfterFinancialVoidCheck(CheckLedgEntry);
    END;

    LOCAL PROCEDURE FinancialVoidPostGLAccount@33(VAR GenJnlLine@1006 : Record 81;BankAccLedgEntry2@1000 : Record 271;CheckLedgEntry@1003 : Record 272;VAR BalanceAmountLCY@1004 : Decimal);
    VAR
      GLEntry@1001 : Record 17;
      VATPostingSetup@1005 : Record 325;
    BEGIN
      WITH GLEntry DO BEGIN
        SETCURRENTKEY("Transaction No.");
        SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
        SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
        SETRANGE("Posting Date",BankAccLedgEntry2."Posting Date");
        SETFILTER("Entry No.",'<>%1',BankAccLedgEntry2."Entry No.");
        SETRANGE("G/L Account No.",CheckLedgEntry."Bal. Account No.");
        IF FINDSET THEN
          REPEAT
            GenJnlLine.VALIDATE("Account No.","G/L Account No.");
            GenJnlLine.Description := STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No.");
            GenJnlLine.VALIDATE(Amount,-Amount - "VAT Amount");
            BalanceAmountLCY := BalanceAmountLCY + GenJnlLine."Amount (LCY)";
            GenJnlLine."Shortcut Dimension 1 Code" := "Global Dimension 1 Code";
            GenJnlLine."Shortcut Dimension 2 Code" := "Global Dimension 2 Code";
            GenJnlLine."Dimension Set ID" := "Dimension Set ID";
            GenJnlLine."Gen. Posting Type" := "Gen. Posting Type";
            GenJnlLine."Gen. Bus. Posting Group" := "Gen. Bus. Posting Group";
            GenJnlLine."Gen. Prod. Posting Group" := "Gen. Prod. Posting Group";
            GenJnlLine."VAT Bus. Posting Group" := "VAT Bus. Posting Group";
            GenJnlLine."VAT Prod. Posting Group" := "VAT Prod. Posting Group";
            IF VATPostingSetup.GET("VAT Bus. Posting Group","VAT Prod. Posting Group") THEN
              GenJnlLine."VAT Calculation Type" := VATPostingSetup."VAT Calculation Type";
            OnFinancialVoidCheckOnBeforePostBalAccLine(GenJnlLine,CheckLedgEntry);
            GenJnlPostLine.RunWithCheck(GenJnlLine);
            OnFinancialVoidCheckOnAfterPostBalAccLine(GenJnlLine,CheckLedgEntry,GenJnlPostLine);
          UNTIL NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE UnApplyVendInvoices@6(VAR CheckLedgEntry@1000 : Record 272;VoidDate@1008 : Date) : Boolean;
    VAR
      BankAccountLedgerEntry@1001 : Record 271;
      OrigPaymentVendorLedgerEntry@1002 : Record 25;
      PayDetailedVendorLedgEntry@1003 : Record 380;
      GenJournalLine3@1004 : Record 81;
      AppliesID@1005 : Code[50];
    BEGIN
      // first, find first original payment line, if any
      BankAccountLedgerEntry.GET(CheckLedgEntry."Bank Account Ledger Entry No.");
      IF CheckLedgEntry."Bal. Account Type" = CheckLedgEntry."Bal. Account Type"::Vendor THEN BEGIN
        WITH OrigPaymentVendorLedgerEntry DO BEGIN
          SETCURRENTKEY("Transaction No.");
          SETRANGE("Transaction No.",BankAccountLedgerEntry."Transaction No.");
          SETRANGE("Document No.",BankAccountLedgerEntry."Document No.");
          SETRANGE("Posting Date",BankAccountLedgerEntry."Posting Date");
          IF NOT FINDFIRST THEN
            EXIT(FALSE);
        END;
      END ELSE
        EXIT(FALSE);

      AppliesID := CheckLedgEntry."Document No.";

      PayDetailedVendorLedgEntry.SETCURRENTKEY("Vendor Ledger Entry No.","Entry Type","Posting Date");
      PayDetailedVendorLedgEntry.SETRANGE("Vendor Ledger Entry No.",OrigPaymentVendorLedgerEntry."Entry No.");
      PayDetailedVendorLedgEntry.SETRANGE(Unapplied,FALSE);
      PayDetailedVendorLedgEntry.SETFILTER("Applied Vend. Ledger Entry No.",'<>%1',0);
      PayDetailedVendorLedgEntry.SETRANGE("Entry Type",PayDetailedVendorLedgEntry."Entry Type"::Application);
      IF NOT PayDetailedVendorLedgEntry.FINDSET THEN
        ERROR(NoAppliedEntryErr);
      REPEAT
        GenJournalLine3.CopyFromPaymentVendLedgEntry(OrigPaymentVendorLedgerEntry);
        GenJournalLine3."Posting Date" := VoidDate;
        GenJournalLine3.Description := STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No.");
        GenJournalLine3."Source Code" := SourceCodeSetup."Financially Voided Check";
        OnUnApplyVendInvoicesOnBeforePost(GenJournalLine3,VendorLedgEntry,PayDetailedVendorLedgEntry);
        GenJnlPostLine.UnapplyVendLedgEntry(GenJournalLine3,PayDetailedVendorLedgEntry);
      UNTIL PayDetailedVendorLedgEntry.NEXT = 0;

      WITH OrigPaymentVendorLedgerEntry DO BEGIN
        FINDSET(TRUE,FALSE);  // re-get the now-modified payment entry.
        REPEAT                // set up to be applied by upcoming voiding entry.
          MakeAppliesID(AppliesID,CheckLedgEntry."Document No.");
          "Applies-to ID" := AppliesID;
          CALCFIELDS("Remaining Amount");
          "Amount to Apply" := "Remaining Amount";
          "Accepted Pmt. Disc. Tolerance" := FALSE;
          "Accepted Payment Tolerance" := 0;
          MODIFY;
        UNTIL NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE UnApplyCustInvoices@7(VAR CheckLedgEntry@1000 : Record 272;VoidDate@1006 : Date) : Boolean;
    VAR
      BankAccountLedgerEntry@1001 : Record 271;
      OrigPaymentCustLedgerEntry@1003 : Record 21;
      PayDetailedCustLedgEntry@1004 : Record 379;
      GenJournalLine3@1005 : Record 81;
      AppliesID@1002 : Code[50];
    BEGIN
      // first, find first original payment line, if any
      BankAccountLedgerEntry.GET(CheckLedgEntry."Bank Account Ledger Entry No.");
      IF CheckLedgEntry."Bal. Account Type" = CheckLedgEntry."Bal. Account Type"::Customer THEN BEGIN
        WITH OrigPaymentCustLedgerEntry DO BEGIN
          SETCURRENTKEY("Transaction No.");
          SETRANGE("Transaction No.",BankAccountLedgerEntry."Transaction No.");
          SETRANGE("Document No.",BankAccountLedgerEntry."Document No.");
          SETRANGE("Posting Date",BankAccountLedgerEntry."Posting Date");
          IF NOT FINDFIRST THEN
            EXIT(FALSE);
        END;
      END ELSE
        EXIT(FALSE);

      AppliesID := CheckLedgEntry."Document No.";

      PayDetailedCustLedgEntry.SETCURRENTKEY("Cust. Ledger Entry No.","Entry Type","Posting Date");
      PayDetailedCustLedgEntry.SETRANGE("Cust. Ledger Entry No.",OrigPaymentCustLedgerEntry."Entry No.");
      PayDetailedCustLedgEntry.SETRANGE(Unapplied,FALSE);
      PayDetailedCustLedgEntry.SETFILTER("Applied Cust. Ledger Entry No.",'<>%1',0);
      PayDetailedCustLedgEntry.SETRANGE("Entry Type",PayDetailedCustLedgEntry."Entry Type"::Application);
      IF NOT PayDetailedCustLedgEntry.FINDSET THEN
        ERROR(NoAppliedEntryErr);
      REPEAT
        GenJournalLine3.CopyFromPaymentCustLedgEntry(OrigPaymentCustLedgerEntry);
        GenJournalLine3."Posting Date" := VoidDate;
        GenJournalLine3.Description := STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No.");
        GenJournalLine3."Source Code" := SourceCodeSetup."Financially Voided Check";
        OnUnApplyCustInvoicesOnBeforePost(GenJournalLine3,CustLedgEntry,PayDetailedCustLedgEntry);
        GenJnlPostLine.UnapplyCustLedgEntry(GenJournalLine3,PayDetailedCustLedgEntry);
      UNTIL PayDetailedCustLedgEntry.NEXT = 0;

      WITH OrigPaymentCustLedgerEntry DO BEGIN
        FINDSET(TRUE,FALSE);  // re-get the now-modified payment entry.
        REPEAT                // set up to be applied by upcoming voiding entry.
          MakeAppliesID(AppliesID,CheckLedgEntry."Document No.");
          "Applies-to ID" := AppliesID;
          CALCFIELDS("Remaining Amount");
          "Amount to Apply" := "Remaining Amount";
          "Accepted Pmt. Disc. Tolerance" := FALSE;
          "Accepted Payment Tolerance" := 0;
          MODIFY;
        UNTIL NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE UnApplyEmpInvoices@42(VAR CheckLedgEntry@1000 : Record 272;VoidDate@1008 : Date) : Boolean;
    VAR
      BankAccountLedgerEntry@1001 : Record 271;
      OrigPaymentEmployeeLedgerEntry@1002 : Record 5222;
      PayDetailedEmployeeLedgEntry@1003 : Record 5223;
      GenJournalLine3@1004 : Record 81;
      AppliesID@1005 : Code[50];
    BEGIN
      // first, find first original payment line, if any
      BankAccountLedgerEntry.GET(CheckLedgEntry."Bank Account Ledger Entry No.");
      IF CheckLedgEntry."Bal. Account Type" <> CheckLedgEntry."Bal. Account Type"::Employee THEN
        EXIT(FALSE);

      WITH OrigPaymentEmployeeLedgerEntry DO BEGIN
        SETCURRENTKEY("Transaction No.");
        SETRANGE("Transaction No.",BankAccountLedgerEntry."Transaction No.");
        SETRANGE("Document No.",BankAccountLedgerEntry."Document No.");
        SETRANGE("Posting Date",BankAccountLedgerEntry."Posting Date");
        IF NOT FINDFIRST THEN
          EXIT(FALSE);
      END;

      AppliesID := CheckLedgEntry."Document No.";

      PayDetailedEmployeeLedgEntry.SETCURRENTKEY("Employee Ledger Entry No.","Entry Type","Posting Date");
      PayDetailedEmployeeLedgEntry.SETRANGE("Employee Ledger Entry No.",OrigPaymentEmployeeLedgerEntry."Entry No.");
      PayDetailedEmployeeLedgEntry.SETRANGE(Unapplied,FALSE);
      PayDetailedEmployeeLedgEntry.SETFILTER("Applied Empl. Ledger Entry No.",'<>%1',0);
      PayDetailedEmployeeLedgEntry.SETRANGE("Entry Type",PayDetailedEmployeeLedgEntry."Entry Type"::Application);
      IF NOT PayDetailedEmployeeLedgEntry.FINDSET THEN
        ERROR(NoAppliedEntryErr);
      REPEAT
        GenJournalLine3.CopyFromPaymentEmpLedgEntry(OrigPaymentEmployeeLedgerEntry);
        GenJournalLine3."Posting Date" := VoidDate;
        GenJournalLine3.Description := STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No.");
        GenJournalLine3."Source Code" := SourceCodeSetup."Financially Voided Check";
        GenJnlPostLine.UnapplyEmplLedgEntry(GenJournalLine3,PayDetailedEmployeeLedgEntry);
      UNTIL PayDetailedEmployeeLedgEntry.NEXT = 0;

      WITH OrigPaymentEmployeeLedgerEntry DO BEGIN
        FINDSET(TRUE,FALSE);  // re-get the now-modified payment entry.
        REPEAT                // set up to be applied by upcoming voiding entry.
          MakeAppliesID(AppliesID,CheckLedgEntry."Document No.");
          "Applies-to ID" := AppliesID;
          CALCFIELDS("Remaining Amount");
          "Amount to Apply" := "Remaining Amount";
          MODIFY;
        UNTIL NEXT = 0;
      END;
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE MarkCheckEntriesVoid@8(VAR OriginalCheckLedgerEntry@1000 : Record 272;VoidDate@1001 : Date);
    VAR
      RelatedCheckLedgerEntry@1002 : Record 272;
      RelatedCheckLedgerEntry2@1003 : Record 272;
    BEGIN
      WITH RelatedCheckLedgerEntry DO BEGIN
        RESET;
        SETCURRENTKEY("Bank Account No.","Entry Status","Check No.");
        SETRANGE("Bank Account No.",OriginalCheckLedgerEntry."Bank Account No.");
        SETRANGE("Entry Status",OriginalCheckLedgerEntry."Entry Status"::Posted);
        SETRANGE("Statement Status",OriginalCheckLedgerEntry."Statement Status"::Open);
        SETRANGE("Check No.",OriginalCheckLedgerEntry."Check No.");
        SETRANGE("Check Date",OriginalCheckLedgerEntry."Check Date");
        SETFILTER("Entry No.",'<>%1',OriginalCheckLedgerEntry."Entry No.");
        IF FINDSET THEN
          REPEAT
            RelatedCheckLedgerEntry2 := RelatedCheckLedgerEntry;
            RelatedCheckLedgerEntry2."Original Entry Status" := "Entry Status";
            RelatedCheckLedgerEntry2."Entry Status" := "Entry Status"::"Financially Voided";
            RelatedCheckLedgerEntry2."Positive Pay Exported" := FALSE;
            IF VoidDate = OriginalCheckLedgerEntry."Check Date" THEN BEGIN
              RelatedCheckLedgerEntry2.Open := FALSE;
              RelatedCheckLedgerEntry2."Statement Status" := RelatedCheckLedgerEntry2."Statement Status"::Closed;
            END;
            RelatedCheckLedgerEntry2.MODIFY;
          UNTIL NEXT = 0;
      END;

      WITH OriginalCheckLedgerEntry DO BEGIN
        "Original Entry Status" := "Entry Status";
        "Entry Status" := "Entry Status"::"Financially Voided";
        "Positive Pay Exported" := FALSE;
        IF VoidDate = "Check Date" THEN BEGIN
          Open := FALSE;
          "Statement Status" := "Statement Status"::Closed;
        END;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE MakeAppliesID@9(VAR AppliesID@1000 : Code[50];CheckDocNo@1001 : Code[20]);
    BEGIN
      IF AppliesID = '' THEN
        EXIT;
      IF AppliesID = CheckDocNo THEN
        AppliesIDCounter := 0;
      AppliesIDCounter := AppliesIDCounter + 1;
      AppliesID :=
        COPYSTR(FORMAT(AppliesIDCounter) + CheckDocNo,1,MAXSTRLEN(AppliesID));
    END;

    LOCAL PROCEDURE CalcAmountToVoid@16(CheckLedgEntry@1000 : Record 272) AmountToVoid : Decimal;
    VAR
      CheckLedgEntry2@1001 : Record 272;
    BEGIN
      WITH CheckLedgEntry2 DO BEGIN
        RESET;
        SETRANGE("Bank Account No.",CheckLedgEntry."Bank Account No.");
        SETRANGE("Entry Status",CheckLedgEntry."Entry Status"::Posted);
        SETRANGE("Statement Status",CheckLedgEntry."Statement Status"::Open);
        SETRANGE("Check No.",CheckLedgEntry."Check No.");
        SETRANGE("Check Date",CheckLedgEntry."Check Date");
        CALCSUMS(Amount);
        AmountToVoid := Amount;
      END;

      OnAfterCalcAmountToVoid(CheckLedgEntry,AmountToVoid);
    END;

    LOCAL PROCEDURE InitGenJnlLine@2(VAR GenJnlLine@1000 : Record 81;DocumentNo@1001 : Code[20];PostingDate@1002 : Date;AccountType@1005 : Option;AccountNo@1003 : Code[20];Description@1004 : Text[50]);
    BEGIN
      GenJnlLine.INIT;
      GenJnlLine."System-Created Entry" := TRUE;
      GenJnlLine."Financial Void" := TRUE;
      GenJnlLine."Document No." := DocumentNo;
      GenJnlLine."Account Type" := AccountType;
      GenJnlLine."Posting Date" := PostingDate;
      GenJnlLine.VALIDATE("Account No.",AccountNo);
      GenJnlLine.Description := Description;
      GenJnlLine."Source Code" := SourceCodeSetup."Financially Voided Check";
    END;

    LOCAL PROCEDURE SetGenJnlLine@1(VAR GenJnlLine@1000 : Record 81;OriginalAmount@1001 : Decimal;CurrencyCode@1002 : Code[10];DocumentNo@1003 : Code[20];Dim1Code@1004 : Code[20];Dim2Code@1005 : Code[20];DimSetID@1006 : Integer);
    BEGIN
      GenJnlLine.VALIDATE(Amount,OriginalAmount);
      GenJnlLine.VALIDATE("Currency Code",CurrencyCode);
      MakeAppliesID(GenJnlLine."Applies-to ID",DocumentNo);
      GenJnlLine."Shortcut Dimension 1 Code" := Dim1Code;
      GenJnlLine."Shortcut Dimension 2 Code" := Dim2Code;
      GenJnlLine."Dimension Set ID" := DimSetID;
      GenJnlLine."Source Currency Code" := CurrencyCode;
    END;

    [External]
    PROCEDURE ProcessElectronicPayment@10(VAR GenJournalLine@1000 : Record 81;WhichProcess@1001 : ',Void,Transmit');
    VAR
      CheckLedgEntry2@1004 : Record 272;
      CheckLedgEntry3@1003 : Record 272;
      BankAccountNo@1002 : Code[20];
    BEGIN
      IF NOT (GenJournalLine."Bank Payment Type" IN
              [GenJournalLine."Bank Payment Type"::"Electronic Payment",
               GenJournalLine."Bank Payment Type"::"Electronic Payment-IAT"])
      THEN
        GenJournalLine.FIELDERROR("Bank Payment Type");
      GenJournalLine.TESTFIELD("Exported to Payment File",TRUE);
      IF NOT (GenJournalLine."Document Type" IN [GenJournalLine."Document Type"::Payment,GenJournalLine."Document Type"::Refund]) THEN
        ERROR(PaymentOrRefundErr,GenJournalLine.FIELDCAPTION("Document Type"),GenJournalLine."Document Type"::Payment,
          GenJournalLine."Document Type"::Refund);
      GenJournalLine.TESTFIELD("Document No.");
      IF GenJournalLine."Account Type" = GenJournalLine."Account Type"::"Bank Account" THEN BEGIN
        GenJournalLine.TESTFIELD("Account No.");
        BankAccountNo := GenJournalLine."Account No.";
      END ELSE
        IF GenJournalLine."Bal. Account Type" = GenJournalLine."Bal. Account Type"::"Bank Account" THEN BEGIN
          GenJournalLine.TESTFIELD("Bal. Account No.");
          BankAccountNo := GenJournalLine."Bal. Account No.";
        END ELSE
          ERROR(BankAccountTypeErr,GenJournalLine.FIELDCAPTION("Account Type"),GenJournalLine.FIELDCAPTION("Bal. Account Type"));

      CheckLedgEntry2.RESET;
      CheckLedgEntry2.SETRANGE("Bank Account No.",BankAccountNo);
      CheckLedgEntry2.SETRANGE("Entry Status",CheckLedgEntry2."Entry Status"::Exported);
      CheckLedgEntry2.SETRANGE("Check No.",GenJournalLine."Document No.");
      IF CheckLedgEntry2.FINDSET THEN
        REPEAT
          CheckLedgEntry3 := CheckLedgEntry2;
          CheckLedgEntry3."Original Entry Status" := CheckLedgEntry3."Entry Status";
          CASE WhichProcess OF
            WhichProcess::Void:
              BEGIN
                CheckLedgEntry3."Entry Status" := CheckLedgEntry3."Entry Status"::Voided;
                CheckLedgEntry3."Positive Pay Exported" := FALSE;
              END;
            WhichProcess::Transmit:
              CheckLedgEntry3."Entry Status" := CheckLedgEntry3."Entry Status"::Transmitted;
          END;
          CheckLedgEntry3.MODIFY;
        UNTIL CheckLedgEntry2.NEXT = 0;

      IF WhichProcess = WhichProcess::Void THEN
        RemoveCreditTransfers(GenJournalLine);
    END;

    LOCAL PROCEDURE RemoveCreditTransfers@11(VAR GenJournalLine@1000 : Record 81);
    VAR
      CreditTransferRegister@1001 : Record 1205;
      CreditTransferEntry@1002 : Record 1206;
      GenJnlShowCTEntries@1003 : Codeunit 16;
    BEGIN
      GenJnlShowCTEntries.SetFiltersOnCreditTransferEntry(GenJournalLine,CreditTransferEntry);
      IF CreditTransferEntry.FINDLAST THEN BEGIN
        IF CreditTransferRegister.GET(CreditTransferEntry."Credit Transfer Register No.") THEN
          CreditTransferRegister.DELETE;
        // For journal entries with multiple lines, the register would have already been deleted,
        // but subsequent lines still need to be deleted.
        CreditTransferEntry.DELETE;
        COMMIT;
      END;
    END;

    LOCAL PROCEDURE PostRoundingAmount@20(BankAcc@1001 : Record 270;CheckLedgEntry@1003 : Record 272;PostingDate@1004 : Date;RoundingAmount@1005 : Decimal);
    VAR
      GenJnlLine2@1000 : Record 81;
      Currency@1002 : Record 4;
    BEGIN
      Currency.GET(BankAcc."Currency Code");
      GenJnlLine2.INIT;
      GenJnlLine2."System-Created Entry" := TRUE;
      GenJnlLine2."Financial Void" := TRUE;
      GenJnlLine2."Document No." := CheckLedgEntry."Document No.";
      GenJnlLine2."Account Type" := GenJnlLine2."Account Type"::"G/L Account";
      GenJnlLine2."Posting Date" := PostingDate;
      IF RoundingAmount > 0 THEN
        GenJnlLine2.VALIDATE("Account No.",Currency.GetConvLCYRoundingDebitAccount)
      ELSE
        GenJnlLine2.VALIDATE("Account No.",Currency.GetConvLCYRoundingCreditAccount);
      GenJnlLine2.VALIDATE("Currency Code",BankAcc."Currency Code");
      GenJnlLine2.Description := STRSUBSTNO(VoidingCheckMsg,CheckLedgEntry."Check No.");
      GenJnlLine2."Source Code" := SourceCodeSetup."Financially Voided Check";
      GenJnlLine2."Allow Zero-Amount Posting" := TRUE;
      GenJnlLine2.VALIDATE(Amount,0);
      GenJnlLine2."Amount (LCY)" := RoundingAmount;
      GenJnlLine2."Shortcut Dimension 1 Code" := BankAccLedgEntry2."Global Dimension 1 Code";
      GenJnlLine2."Shortcut Dimension 2 Code" := BankAccLedgEntry2."Global Dimension 2 Code";
      GenJnlLine2."Dimension Set ID" := BankAccLedgEntry2."Dimension Set ID";
      OnPostRoundingAmountOnBeforeGenJnlPostLine(GenJnlLine2,CheckLedgEntry);
      GenJnlPostLine.RunWithCheck(GenJnlLine2);
      OnPostRoundingAmountOnAfterGenJnlPostLine(GenJnlLine2,CheckLedgEntry,GenJnlPostLine);
    END;

    [EventSubscriber(Table,81,OnAfterDeleteEvent)]
    LOCAL PROCEDURE CleanRecordIDToPrintOnAfterDeleteEventGenJournalLine@17(VAR Rec@1000 : Record 81;RunTrigger@1001 : Boolean);
    VAR
      CheckLedgerEntry@1002 : Record 272;
      DummyRecordID@1003 : RecordID;
    BEGIN
      IF Rec.ISTEMPORARY THEN
        EXIT;
      CheckLedgerEntry.SETRANGE("Record ID to Print",Rec.RECORDID);
      IF NOT CheckLedgerEntry.ISEMPTY THEN
        CheckLedgerEntry.MODIFYALL("Record ID to Print",DummyRecordID);
    END;

    LOCAL PROCEDURE FinancialVoidCheckPreValidation@22(VAR CheckLedgEntry@1000 : Record 272);
    VAR
      TransactionBalance@1001 : Decimal;
    BEGIN
      CheckLedgEntry.TESTFIELD("Entry Status",CheckLedgEntry."Entry Status"::Posted);
      CheckLedgEntry.TESTFIELD("Statement Status",CheckLedgEntry."Statement Status"::Open);
      CheckLedgEntry.TESTFIELD("Bal. Account No.");
      BankAcc.GET(CheckLedgEntry."Bank Account No.");
      BankAccLedgEntry2.GET(CheckLedgEntry."Bank Account Ledger Entry No.");
      SourceCodeSetup.GET;
      WITH GLEntry DO BEGIN
        SETCURRENTKEY("Transaction No.");
        SETRANGE("Transaction No.",BankAccLedgEntry2."Transaction No.");
        SETRANGE("Document No.",BankAccLedgEntry2."Document No.");
        CALCSUMS(Amount);
        TransactionBalance := Amount;
      END;
      IF TransactionBalance <> 0 THEN
        ERROR(VoidingCheckErr);
    END;

    LOCAL PROCEDURE ClearBankLedgerEntry@25(VAR BankAccountLedgerEntry@1000 : Record 271);
    BEGIN
      BankAccountLedgerEntry.RESET;
      BankAccountLedgerEntry.FINDLAST;
      BankAccountLedgerEntry.Open := FALSE;
      BankAccountLedgerEntry."Remaining Amount" := 0;
      BankAccountLedgerEntry."Statement Status" := BankAccLedgEntry2."Statement Status"::Closed;
      BankAccountLedgerEntry.MODIFY;
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterCalcAmountToVoid@23(VAR CheckLedgerEntry@1000 : Record 272;VAR AmountToVoid@1001 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterVoidCheck@13(VAR GenJnlLine@1000 : Record 81;VAR CheckLedgerEntry@1001 : Record 272);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterFinancialVoidCheck@15(VAR CheckLedgerEntry@1000 : Record 272);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeVoidCheck@12(VAR GenJnlLine@1000 : Record 81);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeFinancialVoidCheck@14(VAR CheckLedgerEntry@1000 : Record 272);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeVoidCheckGenJnlLine2Modify@18(VAR GenJournalLine2@1000 : Record 81;GenJournalLine@1001 : Record 81);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnBeforePostCust@19(VAR GenJournalLine@1000 : Record 81;VAR CustLedgerEntry@1001 : Record 21;VAR BalanceAmountLCY@1002 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnBeforePostVend@21(VAR GenJournalLine@1000 : Record 81;VAR VendorLedgerEntry@1001 : Record 25;VAR BalanceAmountLCY@1002 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnBeforePostEmp@40(VAR GenJournalLine@1000 : Record 81;VAR EmployeeLedgerEntry@1001 : Record 5222);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnAfterPostVoidCheckLine@28(VAR GenJournalLine@1000 : Record 81;VAR GenJnlPostLine@1002 : Codeunit 12);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnBeforePostVoidCheckLine@27(VAR GenJournalLine@1000 : Record 81);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnAfterPostBalAccLine@30(VAR GenJournalLine@1000 : Record 81;CheckLedgerEntry@1001 : Record 272;VAR GenJnlPostLine@1002 : Codeunit 12);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnFinancialVoidCheckOnBeforePostBalAccLine@29(VAR GenJournalLine@1000 : Record 81;CheckLedgerEntry@1001 : Record 272);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnPostRoundingAmountOnAfterGenJnlPostLine@32(VAR GenJournalLine@1000 : Record 81;CheckLedgerEntry@1001 : Record 272;VAR GenJnlPostLine@1002 : Codeunit 12);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnPostRoundingAmountOnBeforeGenJnlPostLine@31(VAR GenJournalLine@1000 : Record 81;CheckLedgerEntry@1001 : Record 272);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnUnApplyCustInvoicesOnBeforePost@26(VAR GenJournalLine@1000 : Record 81;VAR CustLedgerEntry@1001 : Record 21;VAR DetailedCustLedgEntry@1002 : Record 379);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnUnApplyVendInvoicesOnBeforePost@24(VAR GenJournalLine@1000 : Record 81;VAR VendorLedgerEntry@1001 : Record 25;VAR DetailedVendorLedgEntry@1002 : Record 380);
    BEGIN
    END;

    BEGIN
    END.
  }
}

