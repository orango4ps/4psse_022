OBJECT Codeunit 419 File Management
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVW114.04,4PS14.00,NAVNO;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Text000@1100528300 : TextConst 'ENU=Directory Name is no UNC path.';
      Text001@1004 : TextConst 'ENU=Default;NOR=Standard;SVE=Standard';
      Text002@1001 : TextConst 'ENU=You must enter a file path.;NOR=Du m† angi en filbane.;SVE=Du m†ste ange en fils”kv„g.';
      Text003@1005 : TextConst 'ENU=You must enter a file name.;NOR=Du m† angi et filnavn.;SVE=Du m†ste ange ett filnamn.';
      FileDoesNotExistErr@1007 : TextConst '@@@=%1 File Path;ENU=The file %1 does not exist.;NOR=Filen %1 eksisterer ikke.;SVE=Filen %1 finns inte.';
      Text006@1003 : TextConst 'ENU=Export;NOR=Eksporter;SVE=Exportera';
      Text007@1002 : TextConst 'ENU=Import;NOR=Importer;SVE=Importera';
      PathHelper@1011 : DotNet "'mscorlib'.System.IO.Path";
      DirectoryHelper@1013 : DotNet "'mscorlib'.System.IO.Directory" RUNONCLIENT;
      ClientFileHelper@1012 : DotNet "'mscorlib'.System.IO.File" RUNONCLIENT;
      ServerFileHelper@1015 : DotNet "'mscorlib'.System.IO.File";
      ServerDirectoryHelper@1030 : DotNet "'mscorlib'.System.IO.Directory";
      Text010@1008 : TextConst 'ENU=The file %1 has not been uploaded.;NOR=Filen %1 har ikke blitt lastet opp.;SVE=Filen %1 har inte laddats upp.';
      Text011@1009 : TextConst 'ENU=You must specify a source file name.;NOR=Du m† angi et kildefilnavn.;SVE=Du m†ste ange ett k„llfilsnamn.';
      Text012@1010 : TextConst 'ENU=You must specify a target file name.;NOR=Du m† angi et m†lfilnavn.;SVE=Du m†ste ange ett m†lfilsnamn.';
      Text013@1014 : TextConst 'ENU=The file name %1 already exists.;NOR=Filnavnet %1 finnes allerede.;SVE=Filnamnet %1 finns redan.';
      Text014@1100528602 : TextConst 'ENU=Pictures;SVE=Bilder';
      DirectoryDoesNotExistErr@1032 : TextConst '@@@="%1=Directory user is trying to upload does not exist";ENU=Directory %1 does not exist.;NOR=Katalogen %1 finnes ikke.;SVE=Katalog %1 finns inte.';
      CreatePathQst@1028 : TextConst 'ENU=The path %1 does not exist. Do you want to add it now?;NOR=Banen %1 finnes ikke. Vil du legge den til n†?;SVE=S”kv„gen %1 finns inte. Vill du l„gga till den nu?';
      AllFilesFilterTxt@1000 : TextConst '@@@={Locked};ENU=*.*;NOR=*.*;SVE=*.*';
      AllFilesDescriptionTxt@1024 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=All Files (*.*)|*.*;NOR=Alle filer (*.*)|*.*;SVE=Alla filer (*.*)|*.*';
      XMLFileType@1006 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XML Files (*.xml)|*.xml;NOR=XML-filer (*.xml)|*.xml;SVE=XML-filer (*.xml)|*.xml';
      WordFileType@1016 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Word Files (*.doc)|*.doc;NOR=Word-filer (*.doc)|*.doc;SVE=Word-filer (*.doc)|*.doc';
      Word2007FileType@1017 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="Word Files (*.docx;*.doc)|*.docx;*.doc";NOR="Word-filer (*.docx;*.doc)|*.docx;*.doc";SVE="Word-filer (*.docx;*.doc)|*.docx;*.doc"';
      AllWordTemplateFileType@1100528600 : TextConst 'ENU="All Word-Templates (*.dotx;*.dotm;*.dot)|*.dotx;*.dotm;*.dot"';
      ExcelFileType@1018 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Excel Files (*.xls)|*.xls;NOR=Excel-filer (*.xls)|*.xls;SVE=Excel-filer (*.xls)|*.xls';
      Excel2007FileType@1019 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="Excel Files (*.xlsx;*.xls)|*.xlsx;*.xls";NOR="Excel-filer (*.xlsx;*.xls)|*.xlsx;*.xls";SVE="Excel-filer (*.xlsx;*.xls)|*.xlsx;*.xls"';
      XSDFileType@1020 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XSD Files (*.xsd)|*.xsd;NOR=XSD-filer (*.xsd)|*.xsd;SVE=XSD-filer (*.xsd)|*.xsd';
      HTMFileType@1021 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=HTM Files (*.htm)|*.htm;NOR=HTM-filer (*.htm)|*.htm;SVE=HTML-filer (*.htm)|*.htm';
      XSLTFileType@1022 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=XSLT Files (*.xslt)|*.xslt;NOR=XSLT-filer (*.xslt)|*.xslt;SVE=XSLT-filer (*.xslt)|*.xslt';
      TXTFileType@1023 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU=Text Files (*.txt)|*.txt;NOR=Tekstfiler (*.txt)|*.txt;SVE=Textfiler (*.txt)|*.txt';
      RDLFileTypeTok@1031 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="SQL Report Builder (*.rdl;*.rdlc)|*.rdl;*.rdlc";NOR="SQL Report Builder (*.rdl;*.rdlc)|*.rdl;*.rdlc";SVE="SQL Report Builder (*.rdl;*.rdlc)|*.rdl;*.rdlc"';
      UnsupportedFileExtErr@1025 : TextConst 'ENU=Unsupported file extension (.%1). The supported file extensions are (%2).;NOR=Filtypen st›ttes ikke (.%1). Filtypene som st›ttes, er (%2).;SVE=Filnamnstill„gget st”ds inte (.%1). Filnamnstill„gg som st”ds „r (%2).';
      SingleFilterErr@1026 : TextConst 'ENU=Specify a file filter and an extension filter when using this function.;NOR=Angi et filfilter og et filtypefilter n†r du bruker denne funksjonen.;SVE=Ange ett filfilter och ett filnamnstill„ggsfilter n„r du anv„nder den h„r funktionen.';
      InvalidWindowsChrStringTxt@1027 : TextConst '@@@={Locked};ENU="""#%&*:<>?\/{|}~";NOR="""#%&*:<>?\/{|}~";SVE="""#%&*:<>?\/{|}~"';
      ZipArchive@1029 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchive";
      ZipArchiveMode@1033 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchiveMode";
      DownloadImageTxt@1034 : TextConst 'ENU=Download image;NOR=Last ned bilde;SVE=Ladda ned bild';
      CanNotRunDotNetOnClientErr@1035 : TextConst 'ENU=Sorry, this action is not available for the web-based versions of the app. You must use the Windows client.;NOR=Beklager. Denne handlingen ikke er tilgjengelig for de nettbaserte versjonene av appen. Du m† bruke Windows-klienten.';
      ChooseFileTitleMsg@1036 : TextConst 'ENU=Choose the file to upload.;NOR=Velg filen som skal lastes opp.';
      NotAllowedPathErr@1037 : TextConst '@@@="%1=the full path to a file. ex: C:\Windows\TextFile.txt ";ENU=Files outside of the current user''s folder cannot be accessed. Access is denied to file %1.;NOR=F†r ikke tilgang til filer utenfor den gjeldende brukerens mappe. Ingen tilgang til filen %1.';
      Text11012000@1100525000 : TextConst 'ENU=The operating system cannot find the file\%1 .\\Verify that the drive, directory, and file names are correct.;NOR=Operativsystemet kan ikke finne filen %1.\\Kontroller at disk, katalog og filnavn er korrekt;SVE=Operativsystemet kan inte hitta filen %1.\\Kontrollera enhet, katalog och namn „r korrekta';
      Text11012001@1100525001 : TextConst 'ENU=The %1 file already exists.\Do you want to replace the existing file?;NOR=Filen %1 finnes allerede.\Vil du erstatte den eksisterende filen?;SVE=Filen %1 finns redan.\Vill du ers„tta den befintliga filen?';
      Text11012002@1100525002 : TextConst 'ENU=The operating system cannot find the drive and directory that are specified for the file\%1 .\\Verify that the drive, directory, and file names are correct.;NOR=Operativsystemet kan ikke finne disken og katalogen som angis for filen\%1.\\Kontroller at enhet, katalog og filnavn er korrekt.;SVE=Operativsystemet kan inte hitta den enhet och katalog som anges f”r filen\%1.\\Kontrollera att enhet, katalog och filnamn „r korrekta.';
      Text11012003@1100525003 : TextConst 'ENU=The file %1 already exists.;NOR=Filen %1 finnes allerede.;SVE=Filen %1 finns redan.';
      Text11012005@1100525009 : TextConst 'ENU=Uploading file #1######## to the server...;NOR=Laster opp fil #1######## til serveren...';
      Text11012006@1100525010 : TextConst 'ENU=Downloading file #1######## from the server...;NOR=Laster ned fil #1######## fra serveren...';
      Text11012007@1100525011 : TextConst 'ENU=The operating system cannot find the folder %1 .;NOR=Operativsystemet kan ikke finne mappe %1.;SVE=Operativsystemet kan inte hitta katalogen %1.';
      Text11012008@1100525012 : TextConst 'ENU=Folder %1 already exists.;NOR=Mappen %1 finnes allerede.;SVE=Katalogen %1 finns redan.';
      Text11012012@1100525006 : TextConst 'ENU=Comma Separated Files (*.csv)|*.csv;NOR=Comma Separated Files (*.csv)|*.csv';
      AllowNewFileInOpenDialog@1100525007 : Boolean;
      Text11012013@1100525005 : TextConst 'ENU=RSU Files (*.rsu)|*.rsu;NOR=RSU Filer (*.rsu)|*.rsu';
      Text11012014@1100525004 : TextConst 'ENU=RSX Files (*.rsx)|*.rsx;NOR=RSX Filer (*.rsx)|*.rsx';
      Text11012014a@1100528500 : TextConst 'ENU=NSX Files (*.nsx)|*.nsx';
      Text11012015@1100525013 : TextConst 'ENU=ZSU Files (*.zsu)|*.zsu;NOR=ZSU Filer (*.zsu)|*.zsu';
      Text11012016@1100525008 : TextConst 'ENU=ZSX Files (*.zsx)|*.zsx;NOR=ZSX Filer (*.zsx)|*.zsx';
      Text11012017@1100525014 : TextConst 'ENU=DBF Files (*.dbf)|*.dbf;NOR=DBF Filer (*.dbf)|*.dbf';
      Text11012018@1100525015 : TextConst 'ENU=Microsoft Excel Files (*.xl*)|*.xl*;NOR=Microsoft Excel Filer (*.xl*)|*.xl*';
      Text11012019@1100525016 : TextConst 'ENU=License Files (*.lic)|*.lic;NOR=Lisensfiler (*.lic)|*.lic';
      Text11012020@1100525017 : TextConst 'ENU=Select Folder;NOR=Velg mappe;SVE=V„lj mapp';
      Text11012021@1100525018 : TextConst 'ENU=Select file or folder...;NOR=Velg fil eller mappe ...;SVE=V„lj fil eller mapp ...';
      Text11012022@1100528400 : TextConst 'ENU=PDF Files (*.pdf)|*.pdf;NOR=PDF-filer (*.pdf)|*.pdf;SVE=PDF-filer (*.pdf)|*.pdf';
      Text11012023@1100528700 : TextConst 'ENU=Operation is only supported in Windows Client.';
      Text11012024@1100527700 : TextConst 'ENU=The file name %1 already exists. Do you want do overwrite it?';
      AllWordDocFileType@1100525019 : TextConst '@@@="{Split=r''\|''}{Locked=s''1''}";ENU="Word Files (*.docm;*.docx;*.doc)|*.docm;*.docx;*.doc"';
      FileStorageType@1100527800 : ' ,File System on Premise,SharePoint Online,Azure File Storage,,,,,,,,PPT,DPTDUAL';

    [External]
    PROCEDURE BLOBImport@3(VAR BLOBRef@1000 : TEMPORARY Record 99008535;Name@1002 : Text) : Text;
    BEGIN
      EXIT(BLOBImportWithFilter(BLOBRef,Text007,Name,AllFilesDescriptionTxt,AllFilesFilterTxt));
    END;

    [External]
    PROCEDURE BLOBImportWithFilter@27(VAR TempBlob@1000 : Record 99008535;DialogCaption@1005 : Text;Name@1002 : Text;FileFilter@1003 : Text;ExtFilter@1008 : Text) : Text;
    VAR
      NVInStream@1001 : InStream;
      NVOutStream@1004 : OutStream;
      UploadResult@1006 : Boolean;
      ErrorMessage@1007 : Text;
    BEGIN
      // ExtFilter examples: 'csv,txt' if you only accept *.csv and *.txt or '*.*' if you accept any extensions
      CLEARLASTERROR;

      IF (FileFilter = '') XOR (ExtFilter = '') THEN
        ERROR(SingleFilterErr);

      // There is no way to check if NVInStream is null before using it after calling the
      // UPLOADINTOSTREAM therefore if result is false this is the only way we can throw the error.
      UploadResult := UPLOADINTOSTREAM(DialogCaption,'',FileFilter,Name,NVInStream);
      IF UploadResult THEN
        ValidateFileExtension(Name,ExtFilter);
      IF UploadResult THEN BEGIN
        TempBlob.Blob.CREATEOUTSTREAM(NVOutStream);
        COPYSTREAM(NVOutStream,NVInStream);
        EXIT(Name);
      END;
      ErrorMessage := GETLASTERRORTEXT;
      IF ErrorMessage <> '' THEN
        ERROR(ErrorMessage);

      EXIT('');
    END;

    LOCAL PROCEDURE BLOBExportLocal@68(VAR InStream@1000 : InStream;Name@1001 : Text;IsCommonDialog@1002 : Boolean) : Text;
    VAR
      ToFile@1004 : Text;
      Path@1006 : Text;
      IsDownloaded@1007 : Boolean;
    BEGIN
      IF IsCommonDialog THEN BEGIN
        IF STRPOS(Name,'*') = 0 THEN
          ToFile := Name
        ELSE
          ToFile := DELCHR(INSSTR(Name,Text001,1),'=','*');
        Path := PathHelper.GetDirectoryName(ToFile);
        ToFile := GetFileName(ToFile);
      END ELSE BEGIN
        ToFile := ClientTempFileName(GetExtension(Name));
        Path := Magicpath;
      END;
      IsDownloaded := DOWNLOADFROMSTREAM(InStream,Text006,Path,GetToFilterText('',Name),ToFile);
      IF IsDownloaded THEN
        EXIT(ToFile);
      EXIT('');
    END;

    [External]
    PROCEDURE BLOBExportWithEncoding@67(VAR TempBlob@1002 : TEMPORARY Record 99008535;Name@1001 : Text;CommonDialog@1000 : Boolean;Encoding@1004 : TextEncoding) : Text;
    VAR
      NVInStream@1003 : InStream;
    BEGIN
      TempBlob.Blob.CREATEINSTREAM(NVInStream,Encoding);
      EXIT(BLOBExportLocal(NVInStream,Name,CommonDialog));
    END;

    [External]
    PROCEDURE BLOBExport@4(VAR TempBlob@1002 : TEMPORARY Record 99008535;Name@1001 : Text;CommonDialog@1000 : Boolean) : Text;
    VAR
      NVInStream@1003 : InStream;
    BEGIN
      TempBlob.Blob.CREATEINSTREAM(NVInStream);
      EXIT(BLOBExportLocal(NVInStream,Name,CommonDialog));
    END;

    [Internal]
    PROCEDURE ServerTempFileName@5(FileExtension@1002 : Text) FileName : Text;
    VAR
      TempFile@1000 : File;
    BEGIN
      TempFile.CREATETEMPFILE;
      FileName := CreateFileNameWithExtension(TempFile.NAME,FileExtension);
      TempFile.CLOSE;
    END;

    [Internal]
    PROCEDURE ClientTempFileName@6(FileExtension@1002 : Text) ClientFileName : Text;
    VAR
      TempFile@1004 : File;
      ClientTempPath@1000 : Text;
    BEGIN
      // Returns the pseudo uniquely generated name of a non existing file in the client temp directory
      TempFile.CREATETEMPFILE;
      ClientFileName := CreateFileNameWithExtension(TempFile.NAME,FileExtension);
      TempFile.CLOSE;
      TempFile.CREATE(ClientFileName);
      TempFile.CLOSE;
      ClientTempPath := GetDirectoryName(DownloadTempFile(ClientFileName));
      IF ERASE(ClientFileName) THEN;
      ClientFileHelper.Delete(ClientTempPath + '\' + PathHelper.GetFileName(ClientFileName));
      ClientFileName := CreateFileNameWithExtension(ClientTempPath + '\' + FORMAT(CREATEGUID),FileExtension);
    END;

    [Internal]
    PROCEDURE CreateClientTempSubDirectory@54() ClientDirectory : Text;
    VAR
      ServerFile@1000 : File;
      ServerFileName@1001 : Text;
    BEGIN
      // Creates a new subdirectory in the client's TEMP folder
      ServerFile.CREATE(CREATEGUID);
      ServerFileName := ServerFile.NAME;
      ServerFile.CLOSE;
      ClientDirectory := GetDirectoryName(DownloadTempFile(ServerFileName));
      IF ERASE(ServerFileName) THEN;
      DeleteClientFile(CombinePath(ClientDirectory,GetFileName(ServerFileName)));
      ClientDirectory := CombinePath(ClientDirectory,CREATEGUID);
      CreateClientDirectory(ClientDirectory);
    END;

    [External]
    PROCEDURE DownloadTempFile@7(ServerFileName@1001 : Text) : Text;
    VAR
      FileName@1568 : Text;
      Path@1569 : Text;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        FileName := ServerTempFileName(GetExtension(ServerFileName));
        COPY(ServerFileName, FileName);
        EXIT(FileName);
      END;
      //**4PS.en
      FileName := ServerFileName;
      Path := Magicpath;
      DOWNLOAD(ServerFileName,'',Path,AllFilesDescriptionTxt,FileName);
      EXIT(FileName);
    END;

    [Internal]
    PROCEDURE UploadFileSilent@10(ClientFilePath@1001 : Text) : Text;
    BEGIN
      EXIT(
        UploadFileSilentToServerPath(ClientFilePath,''));
    END;

    [Internal]
    PROCEDURE UploadFileSilentToServerPath@73(ClientFilePath@1001 : Text;ServerFilePath@1005 : Text) : Text;
    VAR
      ClientFileAttributes@1004 : DotNet "'mscorlib'.System.IO.FileAttributes";
      ServerFileName@1006 : Text;
      TempClientFile@1000 : Text;
      FileName@1002 : Text;
      FileExtension@1003 : Text;
      DialogWindow@1100525000 : Dialog;
    BEGIN
      //**4PS.sn
      IF NOT ClientFileExists(ClientFilePath) THEN
        ERROR(FileDoesNotExistErr,ClientFilePath);
      IF NOT ClientAvailable THEN BEGIN
        FileExtension := GetExtension(ClientFilePath);
        ServerFileName := ServerTempFileName(FileExtension);
        COPY(ClientFilePath, ServerFileName);
        EXIT(ServerFileName);
      END;
      //**4PS.en
      IF NOT CanRunDotNetOnClient THEN
        ERROR(CanNotRunDotNetOnClientErr);

      //**4PS.so
      //IF NOT ClientFileHelper.Exists(ClientFilePath) THEN
      //  ERROR(FileDoesNotExistErr,ClientFilePath);
      //**4PS.eo
      //**4PS.sn
      IF GUIALLOWED THEN
        DialogWindow.OPEN(Text11012005, ClientFilePath);
      //**4PS.en

      FileName := GetFileName(ClientFilePath);
      FileExtension := GetExtension(FileName);

      TempClientFile := ClientTempFileName(FileExtension);
      ClientFileHelper.Copy(ClientFilePath,TempClientFile,TRUE);

      IF ServerFilePath <> '' THEN
        ServerFileName := ServerFilePath
      ELSE
        ServerFileName := ServerTempFileName(FileExtension);

      IF NOT UPLOAD('',Magicpath,AllFilesDescriptionTxt,GetFileName(TempClientFile),ServerFileName) THEN
        ERROR(Text010,ClientFilePath);

      ClientFileHelper.SetAttributes(TempClientFile,ClientFileAttributes.Normal);
      ClientFileHelper.Delete(TempClientFile);

      //**4PS.sn
      IF GUIALLOWED THEN
        DialogWindow.CLOSE;
      //**4PS.en

      EXIT(ServerFileName);
    END;

    [Internal]
    PROCEDURE UploadFileToServer@78(ClientFilePath@1001 : Text) : Text;
    BEGIN
      IF CanRunDotNetOnClient THEN
        EXIT(UploadFileSilentToServerPath(ClientFilePath,''));

      EXIT(UploadFile(ChooseFileTitleMsg,''));
    END;

    [Internal]
    PROCEDURE UploadFile@21(WindowTitle@1003 : Text[50];ClientFileName@1001 : Text) ServerFileName : Text;
    VAR
      Filter@1005 : Text;
    BEGIN
      Filter := GetToFilterText('',ClientFileName);

      IF PathHelper.GetFileNameWithoutExtension(ClientFileName) = '' THEN
        ClientFileName := '';

      ServerFileName := UploadFileWithFilter(WindowTitle,ClientFileName,Filter,AllFilesFilterTxt);
    END;

    [Internal]
    PROCEDURE UploadFileWithFilter@25(WindowTitle@1003 : Text[50];ClientFileName@1001 : Text;FileFilter@1000 : Text;ExtFilter@1004 : Text) ServerFileName : Text;
    VAR
      Uploaded@1002 : Boolean;
    BEGIN
      CLEARLASTERROR;

      IF (FileFilter = '') XOR (ExtFilter = '') THEN
        ERROR(SingleFilterErr);

      Uploaded := UPLOAD(WindowTitle,'',FileFilter,ClientFileName,ServerFileName);
      IF Uploaded THEN
        ValidateFileExtension(ClientFileName,ExtFilter);
      IF Uploaded THEN
        EXIT(ServerFileName);

      IF GETLASTERRORTEXT <> '' THEN
        ERROR('%1',GETLASTERRORTEXT);

      EXIT('');
    END;

    [External]
    PROCEDURE Magicpath@9() : Text;
    BEGIN
      EXIT('<TEMP>');   // MAGIC PATH makes sure we don't get a prompt
    END;

    [Internal]
    PROCEDURE DownloadHandler@2(FromFile@1000 : Text;DialogTitle@1001 : Text;ToFolder@1002 : Text;ToFilter@1003 : Text;ToFile@1004 : Text) : Boolean;
    VAR
      Downloaded@1005 : Boolean;
    BEGIN
      OnBeforeDownloadHandler(ToFolder,ToFile,FromFile);

      CLEARLASTERROR;
      Downloaded := DOWNLOAD(FromFile,DialogTitle,ToFolder,ToFilter,ToFile);
      IF NOT Downloaded THEN
        IF GETLASTERRORTEXT <> '' THEN
          ERROR('%1',GETLASTERRORTEXT);
      EXIT(Downloaded);
    END;

    [Internal]
    PROCEDURE DownloadToFile@13(ServerFileName@1002 : Text;ClientFileName@1000 : Text);
    VAR
      TempClientFileName@1001 : Text;
      DialogWindow@1100525000 : Dialog;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        FILE.COPY(ServerFileName, ClientFileName);
        EXIT;
      END;
      //**4PS.en
      IF CanRunDotNetOnClient THEN BEGIN
        ValidateFileNames(ServerFileName,ClientFileName);
        TempClientFileName := DownloadTempFile(ServerFileName);
        MoveFile(TempClientFileName,ClientFileName);
      END ELSE
        DownloadHandler(ServerFileName,'','','',ClientFileName);

      //**4PS.sn
      IF GUIALLOWED THEN
        DialogWindow.OPEN(Text11012006, ServerFileName);
      //**4PS.en

      TempClientFileName := DownloadTempFile(ServerFileName);
      MoveFile(TempClientFileName,ClientFileName);

      //**4PS.sn
      IF GUIALLOWED THEN
        DialogWindow.CLOSE;
      //**4PS.en
    END;

    [Internal]
    PROCEDURE AppendAllTextToClientFile@44(ServerFileName@1001 : Text;ClientFileName@1000 : Text);
    BEGIN
      ValidateFileNames(ServerFileName,ClientFileName);
      IsAllowedPath(ServerFileName,FALSE);
      IF ClientAvailable THEN BEGIN //**4PS.n
        ClientFileHelper.AppendAllText(ClientFileName,ServerFileHelper.ReadAllText(ServerFileName));
      END ELSE //**4PS.sn
        ServerFileHelper.AppendAllText(ClientFileName,ServerFileHelper.ReadAllText(ServerFileName));
      //**4PS.sn
    END;

    PROCEDURE AppendTextLineToClientFile@1100525032(ClientFileName@1000 : Text;TextLine@1100525000 : Text);
    BEGIN
      //**4PS
      IF ClientAvailable THEN
        ClientFileHelper.AppendAllText(ClientFileName, TextLine)
      ELSE
        ServerFileHelper.AppendAllText(ClientFileName, TextLine);
    END;

    [Internal]
    PROCEDURE MoveAndRenameClientFile@11(OldFilePath@1001 : Text;NewFileName@1004 : Text;NewSubDirectoryName@1002 : Text) NewFilePath : Text;
    VAR
      directory@1003 : Text;
      ServerDirectoryHelper@1100525000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
    BEGIN
      IF OldFilePath = '' THEN
        ERROR(Text002);

      IF NewFileName = '' THEN
        ERROR(Text003);

      //IF NOT ClientFileHelper.Exists(OldFilePath) THEN //**4PS.o
      IF NOT ClientFileExists(OldFilePath) THEN //**4PS.n
        ERROR(FileDoesNotExistErr,OldFilePath);

      // Get the directory from the OldFilePath, if directory is empty it will just use the current location.
      directory := GetDirectoryName(OldFilePath);

      // create the sub directory name is name is given
      IF NewSubDirectoryName <> '' THEN BEGIN
        directory := PathHelper.Combine(directory,NewSubDirectoryName);
        IF ClientAvailable THEN BEGIN //**4PS.n
          DirectoryHelper.CreateDirectory(directory);
        END ELSE //**4PS.n
          ServerDirectoryHelper.CreateDirectory(directory); //**4PS.n
      END;

      NewFilePath := PathHelper.Combine(directory,NewFileName);
      MoveFile(OldFilePath,NewFilePath);

      EXIT(NewFilePath);
    END;

    [Internal]
    PROCEDURE CreateClientFile@81(FilePathName@1000 : Text);
    VAR
      StreamWriter@1001 : DotNet "'mscorlib'.System.IO.StreamWriter" RUNONCLIENT;
    BEGIN
      IF NOT ClientFileHelper.Exists(FilePathName) THEN BEGIN
        StreamWriter := ClientFileHelper.CreateText(FilePathName);
        StreamWriter.Close;
      END;
    END;

    [Internal]
    PROCEDURE DeleteClientFile@12(FilePath@1001 : Text) : Boolean;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        IF NOT EXISTS(FilePath) THEN
          EXIT(FALSE);
        EXIT(ERASE(FilePath));
      END;
      //**4PS.en
      IF NOT ClientFileHelper.Exists(FilePath) THEN
        EXIT(FALSE);

      ClientFileHelper.Delete(FilePath);
      EXIT(TRUE);
    END;

    [Internal]
    PROCEDURE CopyClientFile@43(SourceFileName@1000 : Text;DestFileName@1001 : Text;OverWrite@1002 : Boolean);
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        ServerFileHelper.Copy(SourceFileName,DestFileName,OverWrite);
        EXIT;
      END;
      //**4PS.en
      ClientFileHelper.Copy(SourceFileName,DestFileName,OverWrite);
    END;

    [Internal]
    PROCEDURE ClientFileExists@14(FilePath@1001 : Text) : Boolean;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN
        EXIT(EXISTS(FilePath));
      //**4PS.en
      IF NOT CanRunDotNetOnClient THEN
        EXIT(FALSE);
      EXIT(ClientFileHelper.Exists(FilePath));
    END;

    [Internal]
    PROCEDURE ClientDirectoryExists@42(DirectoryPath@1001 : Text) : Boolean;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN
        EXIT(ServerFolderExists(DirectoryPath));
      //**4PS.en
      IF NOT CanRunDotNetOnClient THEN
        EXIT(FALSE);
      EXIT(DirectoryHelper.Exists(DirectoryPath));
    END;

    PROCEDURE DirectoryExistsOnDotNetClient@1080001(DirectoryPath@1080000 : Text) : Boolean;
    BEGIN
      //NAVNO9.00.00.43402
      IF NOT CanRunDotNetOnClient THEN
        EXIT(TRUE);
      EXIT(DirectoryHelper.Exists(DirectoryPath));
    END;

    [Internal]
    PROCEDURE CreateClientDirectory@49(DirectoryPath@1000 : Text);
    BEGIN
      IF NOT ClientDirectoryExists(DirectoryPath) THEN
        DirectoryHelper.CreateDirectory(DirectoryPath);
    END;

    [Internal]
    PROCEDURE DeleteClientDirectory@82(DirectoryPath@1000 : Text);
    BEGIN
      IF ClientDirectoryExists(DirectoryPath) THEN
        DirectoryHelper.Delete(DirectoryPath,TRUE);
    END;

    [Internal]
    PROCEDURE UploadClientDirectorySilent@57(DirectoryPath@1000 : Text;FileExtensionFilter@1002 : Text;IncludeSubDirectories@1003 : Boolean) ServerDirectoryPath : Text;
    VAR
      SearchOption@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.SearchOption" RUNONCLIENT;
      ArrayHelper@1005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array" RUNONCLIENT;
      ClientFilePath@1008 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String" RUNONCLIENT;
      ServerFilePath@1001 : Text;
      RelativeServerPath@1010 : Text;
      i@1006 : Integer;
      ArrayLength@1007 : Integer;
    BEGIN
      IF NOT ClientDirectoryExists(DirectoryPath) THEN
        ERROR(DirectoryDoesNotExistErr,DirectoryPath);

      IF IncludeSubDirectories THEN
        ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath,FileExtensionFilter,SearchOption.AllDirectories)
      ELSE
        ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath,FileExtensionFilter,SearchOption.TopDirectoryOnly);

      ArrayLength := ArrayHelper.GetLength(0);

      IF ArrayLength = 0 THEN
        EXIT;

      ServerDirectoryPath := ServerCreateTempSubDirectory;

      FOR i := 1 TO ArrayLength DO BEGIN
        ClientFilePath := ArrayHelper.GetValue(i - 1);
        RelativeServerPath := ClientFilePath.Replace(DirectoryPath,'');
        IF PathHelper.IsPathRooted(RelativeServerPath) THEN
          RelativeServerPath := DELCHR(RelativeServerPath,'<','\');
        ServerFilePath := CombinePath(ServerDirectoryPath,RelativeServerPath);
        ServerCreateDirectory(GetDirectoryName(ServerFilePath));
        UploadFileSilentToServerPath(ClientFilePath,ServerFilePath);
      END;
    END;

    [Internal]
    PROCEDURE MoveFile@15(SourceFileName@1001 : Text;TargetFileName@1002 : Text);
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        MoveServerFile(SourceFileName, TargetFileName);
        EXIT;
      END;
      //**4PS.en

      // System.IO.File.Move is not used due to a known issue in KB310316
      IF NOT ClientFileHelper.Exists(SourceFileName) THEN
        ERROR(FileDoesNotExistErr,SourceFileName);

      IF UPPERCASE(SourceFileName) = UPPERCASE(TargetFileName) THEN
        EXIT;

      ValidateClientPath(GetDirectoryName(TargetFileName));

      DeleteClientFile(TargetFileName);
      ClientFileHelper.Copy(SourceFileName, TargetFileName);
      ClientFileHelper.Delete(SourceFileName);
    END;

    [Internal]
    PROCEDURE CopyServerFile@32(SourceFileName@1001 : Text;TargetFileName@1002 : Text;Overwrite@1000 : Boolean);
    BEGIN
      IsAllowedPath(SourceFileName,FALSE);
      IsAllowedPath(TargetFileName,FALSE);
      ServerFileHelper.Copy(SourceFileName,TargetFileName,Overwrite);
    END;

    [External]
    PROCEDURE ServerFileExists@33(FilePath@1001 : Text) : Boolean;
    BEGIN
      EXIT(EXISTS(FilePath));
    END;

    [Internal]
    PROCEDURE DeleteServerFile@34(FilePath@1001 : Text) : Boolean;
    BEGIN
      IsAllowedPath(FilePath,FALSE);
      IF NOT EXISTS(FilePath) THEN
        EXIT(FALSE);

      ServerFileHelper.Delete(FilePath);
      EXIT(TRUE);
    END;

    [Internal]
    PROCEDURE ServerDirectoryExists@48(DirectoryPath@1000 : Text) : Boolean;
    BEGIN
      EXIT(ServerDirectoryHelper.Exists(DirectoryPath));
    END;

    [Internal]
    PROCEDURE ServerCreateDirectory@47(DirectoryPath@1000 : Text);
    BEGIN
      IF NOT ServerDirectoryExists(DirectoryPath) THEN
        ServerDirectoryHelper.CreateDirectory(DirectoryPath);
    END;

    [Internal]
    PROCEDURE ServerCreateTempSubDirectory@59() DirectoryPath : Text;
    VAR
      ServerTempFile@1001 : Text;
    BEGIN
      ServerTempFile := ServerTempFileName('tmp');
      DirectoryPath := CombinePath(GetDirectoryName(ServerTempFile),FORMAT(CREATEGUID));
      ServerCreateDirectory(DirectoryPath);
      DeleteServerFile(ServerTempFile);
    END;

    [Internal]
    PROCEDURE ServerRemoveDirectory@55(DirectoryPath@1000 : Text;Recursive@1001 : Boolean);
    BEGIN
      IF ServerDirectoryExists(DirectoryPath) THEN
        ServerDirectoryHelper.Delete(DirectoryPath,Recursive);
    END;

    [External]
    PROCEDURE GetFileName@16(FilePath@1001 : Text) : Text;
    BEGIN
      EXIT(PathHelper.GetFileName(FilePath));
    END;

    [External]
    PROCEDURE GetSafeFileName@69(FileName@1000 : Text) : Text;
    VAR
      DotNetString@1001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      Result@1005 : Text;
      Str@1006 : Text;
    BEGIN
      DotNetString := FileName;
      FOREACH Str IN DotNetString.Split(PathHelper.GetInvalidFileNameChars) DO
        Result += Str;
      EXIT(Result);
    END;

    [External]
    PROCEDURE GetFileNameWithoutExtension@35(FilePath@1000 : Text) : Text;
    BEGIN
      EXIT(PathHelper.GetFileNameWithoutExtension(FilePath));
    END;

    [External]
    PROCEDURE HasExtension@74(FilePath@1000 : Text) : Boolean;
    BEGIN
      EXIT(PathHelper.HasExtension(FilePath));
    END;

    [External]
    PROCEDURE GetFileNameMimeType@77(FileName@1000 : Text) : Text;
    VAR
      MimeMapping@1001 : DotNet "'System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Web.MimeMapping";
    BEGIN
      EXIT(MimeMapping.GetMimeMapping(FileName));
    END;

    [External]
    PROCEDURE GetDirectoryName@8(FileName@1001 : Text) : Text;
    BEGIN
      IF FileName = '' THEN
        EXIT(FileName);

      FileName := DELCHR(FileName,'<');
      EXIT(PathHelper.GetDirectoryName(FileName));
    END;

    [Internal]
    PROCEDURE GetClientDirectoryFilesList@51(VAR NameValueBuffer@1002 : Record 823;DirectoryPath@1000 : Text);
    VAR
      ArrayHelper@1001 : DotNet "'mscorlib'.System.Array" RUNONCLIENT;
      i@1003 : Integer;
    BEGIN
      NameValueBuffer.RESET;
      NameValueBuffer.DELETEALL;

      ArrayHelper := DirectoryHelper.GetFiles(DirectoryPath);
      FOR i := 1 TO ArrayHelper.GetLength(0) DO BEGIN
        NameValueBuffer.ID := i;
        EVALUATE(NameValueBuffer.Name,ArrayHelper.GetValue(i - 1));
        NameValueBuffer.INSERT;
      END;
    END;

    [Internal]
    PROCEDURE GetServerDirectoryFilesList@64(VAR NameValueBuffer@1000 : Record 823;DirectoryPath@1001 : Text);
    VAR
      ArrayHelper@1002 : DotNet "'mscorlib'.System.Array";
      i@1003 : Integer;
    BEGIN
      NameValueBuffer.RESET;
      NameValueBuffer.DELETEALL;

      ArrayHelper := ServerDirectoryHelper.GetFiles(DirectoryPath);
      FOR i := 1 TO ArrayHelper.GetLength(0) DO BEGIN
        NameValueBuffer.ID := i;
        EVALUATE(NameValueBuffer.Name,ArrayHelper.GetValue(i - 1));
        NameValueBuffer.Value := COPYSTR(GetFileNameWithoutExtension(NameValueBuffer.Name),1,250);
        NameValueBuffer.INSERT;
      END;
    END;

    [Internal]
    PROCEDURE GetServerDirectoryFilesListInclSubDirs@72(VAR TempNameValueBuffer@1000 : TEMPORARY Record 823;DirectoryPath@1001 : Text);
    BEGIN
      TempNameValueBuffer.RESET;
      TempNameValueBuffer.DELETEALL;

      GetServerDirectoryFilesListInclSubDirsInner(TempNameValueBuffer,DirectoryPath);
    END;

    LOCAL PROCEDURE GetServerDirectoryFilesListInclSubDirsInner@80(VAR NameValueBuffer@1000 : Record 823;DirectoryPath@1001 : Text);
    VAR
      ArrayHelper@1002 : DotNet "'mscorlib'.System.Array";
      FileSystemEntry@1004 : Text;
      Index@1003 : Integer;
      LastId@1005 : Integer;
    BEGIN
      ArrayHelper := ServerDirectoryHelper.GetFileSystemEntries(DirectoryPath);
      FOR Index := 1 TO ArrayHelper.GetLength(0) DO BEGIN
        IF NameValueBuffer.FINDLAST THEN
          LastId := NameValueBuffer.ID;
        EVALUATE(FileSystemEntry,ArrayHelper.GetValue(Index - 1));
        IF ServerDirectoryExists(FileSystemEntry) THEN
          GetServerDirectoryFilesListInclSubDirsInner(NameValueBuffer,FileSystemEntry)
        ELSE BEGIN
          NameValueBuffer.ID := LastId + 1;
          NameValueBuffer.Name := COPYSTR(FileSystemEntry,1,250);
          NameValueBuffer.Value := COPYSTR(GetFileNameWithoutExtension(NameValueBuffer.Name),1,250);
          NameValueBuffer.INSERT;
        END;
      END;
    END;

    [TryFunction]
    [Internal]
    PROCEDURE GetClientFileProperties@53(FullFileName@1000 : Text;VAR ModifyDate@1001 : Date;VAR ModifyTime@1002 : Time;VAR Size@1003 : BigInteger);
    VAR
      FileInfo@1004 : DotNet "'mscorlib'.System.IO.FileInfo" RUNONCLIENT;
      ModifyDateTime@1005 : DateTime;
    BEGIN
      //**4PS.sn
      IF NOT ClientAvailable THEN BEGIN
        GetServerFileProperties(FullFileName,ModifyDate,ModifyTime,Size);
        EXIT;
      END;
      //**4PS.en
      ModifyDateTime := ClientFileHelper.GetLastWriteTime(FullFileName);
      ModifyDate := DT2DATE(ModifyDateTime);
      ModifyTime := DT2TIME(ModifyDateTime);
      Size := FileInfo.FileInfo(FullFileName).Length;
    END;

    [TryFunction]
    [Internal]
    PROCEDURE GetServerFileProperties@76(FullFileName@1000 : Text;VAR ModifyDate@1001 : Date;VAR ModifyTime@1002 : Time;VAR Size@1003 : BigInteger);
    VAR
      FileInfo@1004 : DotNet "'mscorlib'.System.IO.FileInfo";
      ModifyDateTime@1005 : DateTime;
    BEGIN
      ModifyDateTime := ServerDirectoryHelper.GetLastWriteTime(FullFileName);
      ModifyDate := DT2DATE(ModifyDateTime);
      ModifyTime := DT2TIME(ModifyDateTime);
      Size := FileInfo.FileInfo(FullFileName).Length;
    END;

    [Internal]
    PROCEDURE CombinePath@50(BasePath@1000 : Text;Suffix@1001 : Text) : Text;
    BEGIN
      EXIT(PathHelper.Combine(BasePath,Suffix));
    END;

    [Internal]
    PROCEDURE BLOBImportFromServerFile@17(VAR TempBlob@1001 : Record 99008535;FilePath@1000 : Text);
    VAR
      OutStream@1004 : OutStream;
      InStream@1003 : InStream;
      InputFile@1002 : File;
    BEGIN
      IsAllowedPath(FilePath,FALSE);

      IF NOT FILE.EXISTS(FilePath) THEN
        ERROR(FileDoesNotExistErr,FilePath);

      InputFile.OPEN(FilePath);
      InputFile.CREATEINSTREAM(InStream);
      TempBlob.Blob.CREATEOUTSTREAM(OutStream);
      COPYSTREAM(OutStream,InStream);
      InputFile.CLOSE;
    END;

    [Internal]
    PROCEDURE BLOBExportToServerFile@18(VAR TempBlob@1001 : Record 99008535;FilePath@1000 : Text);
    VAR
      OutStream@1004 : OutStream;
      InStream@1003 : InStream;
      OutputFile@1002 : File;
    BEGIN
      IF FILE.EXISTS(FilePath) THEN
        ERROR(Text013,FilePath);

      OutputFile.WRITEMODE(TRUE);
      OutputFile.CREATE(FilePath);
      OutputFile.CREATEOUTSTREAM(OutStream);
      TempBlob.Blob.CREATEINSTREAM(InStream);
      COPYSTREAM(OutStream,InStream);
      OutputFile.CLOSE;
    END;

    [Internal]
    PROCEDURE InstreamExportToServerFile@75(Instream@1001 : InStream;FileExt@1000 : Text) FileName : Text;
    VAR
      OutStream@1004 : OutStream;
      OutputFile@1002 : File;
    BEGIN
      FileName := COPYSTR(ServerTempFileName(FileExt),1,250);
      OutputFile.WRITEMODE(TRUE);
      OutputFile.CREATE(FileName);
      OutputFile.CREATEOUTSTREAM(OutStream);
      COPYSTREAM(OutStream,Instream);
      OutputFile.CLOSE;
    END;

    [Internal]
    PROCEDURE CreateAndWriteToServerFile@79(FileContent@1001 : Text;FileExt@1000 : Text) FileName : Text;
    VAR
      File@1002 : File;
      OutStream@1003 : OutStream;
    BEGIN
      FileName := COPYSTR(ServerTempFileName(FileExt),1,250);
      File.CREATE(FileName);
      File.CREATEOUTSTREAM(OutStream);
      OutStream.WRITETEXT(FileContent);
      File.CLOSE;
    END;

    [External]
    PROCEDURE GetToFilterText@19(FilterString@1002 : Text;FileName@1000 : Text) : Text;
    VAR
      OutExt@1001 : Text;
    BEGIN
      IF FilterString <> '' THEN
        EXIT(FilterString);
      CASE UPPERCASE(GetExtension(FileName)) OF
        'DOC':
          OutExt := WordFileType;
        'DOCX':
          OutExt := Word2007FileType;
        'DOTX':
          OutExt := AllWordTemplateFileType;
        'XLS':
          OutExt := ExcelFileType;
        'XLSX':
          OutExt := Excel2007FileType;
        'XSLT':
          OutExt := XSLTFileType;
        'XML':
          OutExt := XMLFileType;
        'XSD':
          OutExt := XSDFileType;
        'HTM':
          OutExt := HTMFileType;
        'TXT':
          OutExt := TXTFileType;
        'RDL':
          OutExt := RDLFileTypeTok;
        'RDLC':
          OutExt := RDLFileTypeTok;
      //**4PS.sn
        'CSV':
          OutExt := Text11012012;
        'RSU':
          OutExt := Text11012013;
        'RSX':
          OutExt := Text11012014;
        'NSX':
          OutExt := Text11012014a;  //DP02278
        'ZSU':
          OutExt := Text11012015;
        'ZSX':
          OutExt := Text11012016;
        'DBF':
          OutExt := Text11012017;
        'XLT':
          OutExt := Text11012018;
        'LIC':
          OutExt := Text11012019;
        'PDF':
          OutExt := Text11012022;
        'DOCM':
          OutExt := AllWordDocFileType;
        'DOTM':
          OutExt := AllWordTemplateFileType;
      //**4PS.en
      END;

      OnAfterGetToFilterTextSetOutExt(FileName,OutExt);

      IF OutExt = '' THEN
        EXIT(AllFilesDescriptionTxt);
      EXIT(OutExt + '|' + AllFilesDescriptionTxt);  // Also give the option of the general selection
    END;

    [External]
    PROCEDURE GetExtension@20(Name@1000 : Text) : Text;
    VAR
      FileExtension@1002 : Text;
    BEGIN
      FileExtension := PathHelper.GetExtension(Name);

      IF FileExtension <> '' THEN
        FileExtension := DELCHR(FileExtension,'<','.');

      EXIT(FileExtension);
    END;

    [External]
    PROCEDURE OpenFileDialog@1(WindowTitle@1000 : Text[50];DefaultFileName@1001 : Text;FilterString@1002 : Text) : Text;
    VAR
      OpenFileDialog@1006 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.OpenFileDialog" RUNONCLIENT;
      DialogResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      IF IsWebClient THEN
        EXIT(UploadFile(WindowTitle,DefaultFileName));

      OpenFileDialog := OpenFileDialog.OpenFileDialog;
      OpenFileDialog.ShowReadOnly := FALSE;
      OpenFileDialog.FileName := GetFileName(DefaultFileName);
      OpenFileDialog.Title := WindowTitle;
      OpenFileDialog.Filter := GetToFilterText(FilterString,DefaultFileName);
      OpenFileDialog.InitialDirectory := GetDirectoryName(DefaultFileName);
      //**4PS.sn
      IF AllowNewFileInOpenDialog THEN
        OpenFileDialog.CheckFileExists := FALSE;
      //**4PS.en

      DialogResult := OpenFileDialog.ShowDialog;
      IF DialogResult.CompareTo(DialogResult.OK) = 0 THEN
        EXIT(OpenFileDialog.FileName);
      EXIT('');
    END;

    [Internal]
    PROCEDURE SaveFileDialog@23(WindowTitle@1000 : Text[50];DefaultFileName@1001 : Text;FilterString@1002 : Text) : Text;
    VAR
      SaveFileDialog@1008 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.SaveFileDialog" RUNONCLIENT;
      DialogResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      IF IsWebClient THEN
        EXIT('');
      SaveFileDialog := SaveFileDialog.SaveFileDialog;
      SaveFileDialog.CheckPathExists := TRUE;
      SaveFileDialog.OverwritePrompt := TRUE;
      SaveFileDialog.FileName := GetFileName(DefaultFileName);
      SaveFileDialog.Title := WindowTitle;
      SaveFileDialog.Filter := GetToFilterText(FilterString,DefaultFileName);
      SaveFileDialog.InitialDirectory := GetDirectoryName(DefaultFileName);

      DialogResult := SaveFileDialog.ShowDialog;
      IF DialogResult.CompareTo(DialogResult.OK) = 0 THEN
        EXIT(SaveFileDialog.FileName);
      EXIT('');
    END;

    [External]
    PROCEDURE SelectFolderDialog@52(WindowTitle@1001 : Text;VAR SelectedFolder@1003 : Text) : Boolean;
    VAR
      FolderBrowser@1000 : DotNet "'System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.FolderBrowserDialog" RUNONCLIENT;
      DialogResult@1002 : DotNet "'System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      FolderBrowser := FolderBrowser.FolderBrowserDialog;
      FolderBrowser.ShowNewFolderButton := TRUE;
      FolderBrowser.Description := WindowTitle;

      DialogResult := FolderBrowser.ShowDialog;
      IF DialogResult = 1 THEN BEGIN
        SelectedFolder := FolderBrowser.SelectedPath;
        EXIT(TRUE);
      END;
    END;

    [External]
    PROCEDURE CanRunDotNetOnClient@41() : Boolean;
    VAR
      ClientTypeManagement@1001 : Codeunit 4030;
    BEGIN
      //EXIT(ClientTypeManagement.GetCurrentClientType = CLIENTTYPE::Windows); //**4PS.o
      EXIT((ClientTypeManagement.GetCurrentClientType = CLIENTTYPE::Windows) OR (ClientTypeManagement.GetCurrentClientType = CLIENTTYPE::SOAP)); //**4PS.n
    END;

    [External]
    PROCEDURE IsWebClient@46() : Boolean;
    VAR
      ClientTypeManagement@1001 : Codeunit 4030;
    BEGIN
      EXIT(ClientTypeManagement.GetCurrentClientType IN [CLIENTTYPE::Web,CLIENTTYPE::Tablet,CLIENTTYPE::Phone,CLIENTTYPE::Desktop]);
    END;

    [External]
    PROCEDURE IsWindowsClient@39() : Boolean;
    VAR
      ClientTypeManagement@1000 : Codeunit 4030;
    BEGIN
      EXIT(ClientTypeManagement.GetCurrentClientType = CLIENTTYPE::Windows);
    END;

    [External]
    PROCEDURE IsValidFileName@22(FileName@1000 : Text) : Boolean;
    VAR
      String@1001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
    BEGIN
      IF FileName = '' THEN
        EXIT(FALSE);

      String := GetFileName(FileName);
      IF String.IndexOfAny(PathHelper.GetInvalidFileNameChars) <> -1 THEN
        EXIT(FALSE);

      String := GetDirectoryName(FileName);
      IF String.IndexOfAny(PathHelper.GetInvalidPathChars) <> -1 THEN
        EXIT(FALSE);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE ValidateFileNames@24(ServerFileName@1000 : Text;ClientFileName@1001 : Text);
    BEGIN
      IF NOT IsValidFileName(ServerFileName) THEN
        ERROR(Text011);

      IF NOT IsValidFileName(ClientFileName) THEN
        ERROR(Text012);
    END;

    [External]
    PROCEDURE ValidateFileExtension@26(FilePath@1000 : Text;ValidExtensions@1001 : Text);
    VAR
      FileExt@1003 : Text;
      LowerValidExts@1004 : Text;
    BEGIN
      IF STRPOS(ValidExtensions,AllFilesFilterTxt) <> 0 THEN
        EXIT;

      FileExt := LOWERCASE(GetExtension(GetFileName(FilePath)));
      LowerValidExts := LOWERCASE(ValidExtensions);

      IF STRPOS(LowerValidExts,FileExt) = 0 THEN
        ERROR(UnsupportedFileExtErr,FileExt,LowerValidExts);
    END;

    LOCAL PROCEDURE ValidateClientPath@45(FilePath@1000 : Text);
    VAR
      ConfirmManagement@1001 : Codeunit 27;
    BEGIN
      IF FilePath = '' THEN
        EXIT;
      IF DirectoryHelper.Exists(FilePath) THEN
        EXIT;

      IF ConfirmManagement.ConfirmProcess(STRSUBSTNO(CreatePathQst,FilePath),TRUE) THEN
        DirectoryHelper.CreateDirectory(FilePath)
      ELSE
        ERROR('');
    END;

    LOCAL PROCEDURE CreateFileNameWithExtension@58(FileNameWithoutExtension@1000 : Text;Extension@1001 : Text) FileName : Text;
    BEGIN
      FileName := FileNameWithoutExtension;
      IF Extension <> '' THEN BEGIN
        IF Extension[1] <> '.' THEN
          FileName := FileName + '.';
        FileName := FileName + Extension;
      END
    END;

    [External]
    PROCEDURE Ansi2SystemEncoding@28(Destination@1000 : OutStream;Source@1001 : InStream);
    VAR
      StreamReader@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamReader";
      Encoding@1003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
      EncodedTxt@1002 : Text;
    BEGIN
      StreamReader := StreamReader.StreamReader(Source,Encoding.Default,TRUE);
      EncodedTxt := StreamReader.ReadToEnd;
      Destination.WRITETEXT(EncodedTxt);
    END;

    [External]
    PROCEDURE Ansi2SystemEncodingTxt@29(Destination@1001 : OutStream;Source@1000 : Text);
    VAR
      StreamWriter@1004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamWriter";
      Encoding@1003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.Encoding";
    BEGIN
      StreamWriter := StreamWriter.StreamWriter(Destination,Encoding.Default);
      StreamWriter.Write(Source);
      StreamWriter.Close;
    END;

    [External]
    PROCEDURE BrowseForFolderDialog@30(WindowTitle@1000 : Text[50];DefaultFolderName@1001 : Text;ShowNewFolderButton@1002 : Boolean) : Text;
    VAR
      FolderBrowserDialog@1006 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.FolderBrowserDialog" RUNONCLIENT;
      DialagResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      FolderBrowserDialog := FolderBrowserDialog.FolderBrowserDialog;
      FolderBrowserDialog.Description := WindowTitle;
      FolderBrowserDialog.SelectedPath := DefaultFolderName;
      FolderBrowserDialog.ShowNewFolderButton := ShowNewFolderButton;

      DialagResult := FolderBrowserDialog.ShowDialog;
      IF DialagResult.CompareTo(DialagResult.OK) = 0 THEN
        EXIT(FolderBrowserDialog.SelectedPath);
      EXIT(DefaultFolderName);
    END;

    [External]
    PROCEDURE StripNotsupportChrInFileName@31(InText@1000 : Text) : Text;
    BEGIN
      EXIT(DELCHR(InText,'=',InvalidWindowsChrStringTxt));
    END;

    [Internal]
    PROCEDURE CreateZipArchiveObject@36() FilePath : Text;
    BEGIN
      FilePath := ServerTempFileName('zip');
      OpenZipFile(FilePath);
    END;

    [Internal]
    PROCEDURE OpenZipFile@62(ServerZipFilePath@1035 : Text);
    VAR
      Zipfile@1001 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFile";
      ZipAchiveMode@1000 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchiveMode";
    BEGIN
      IsAllowedPath(ServerZipFilePath,FALSE);
      ZipArchive := Zipfile.Open(ServerZipFilePath,ZipAchiveMode.Create);
    END;

    [Internal]
    PROCEDURE AddFileToZipArchive@37(SourceFileFullPath@1000 : Text;PathInZipFile@1001 : Text);
    VAR
      Zip@1002 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFileExtensions";
    BEGIN
      IsAllowedPath(SourceFileFullPath,FALSE);
      Zip.CreateEntryFromFile(ZipArchive,SourceFileFullPath,PathInZipFile);
    END;

    [Internal]
    PROCEDURE CloseZipArchive@38();
    BEGIN
      IF NOT ISNULL(ZipArchive) THEN
        ZipArchive.Dispose;
    END;

    [Internal]
    PROCEDURE IsGZip@40(ServerSideFileName@1000 : Text) : Boolean;
    VAR
      FileStream@1005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileStream";
      FileMode@1006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileMode";
      ID@1007 : ARRAY [2] OF Integer;
    BEGIN
      IsAllowedPath(ServerSideFileName,FALSE);

      FileStream := FileStream.FileStream(ServerSideFileName,FileMode.Open);
      ID[1] := FileStream.ReadByte;
      ID[2] := FileStream.ReadByte;
      FileStream.Close;

      // from GZIP file format specification version 4.3
      // Member header and trailer
      // ID1 (IDentification 1)
      // ID2 (IDentification 2)
      // These have the fixed values ID1 = 31 (0x1f, \037), ID2 = 139 (0x8b, \213), to identify the file as being in gzip format.

      EXIT((ID[1] = 31) AND (ID[2] = 139));
    END;

    [TryFunction]
    [Internal]
    PROCEDURE ExtractZipFile@56(ZipFilePath@1001 : Text;DestinationFolder@1006 : Text);
    VAR
      Zip@1004 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFileExtensions";
      ZipFile@1000 : DotNet "'System.IO.Compression.FileSystem, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipFile";
    BEGIN
      IsAllowedPath(ZipFilePath,FALSE);

      IF NOT ServerFileHelper.Exists(ZipFilePath) THEN
        ERROR(FileDoesNotExistErr,ZipFilePath);

      // Create directory if it doesn't exist
      ServerCreateDirectory(DestinationFolder);

      ZipArchive := ZipFile.Open(ZipFilePath,ZipArchiveMode.Read);
      Zip.ExtractToDirectory(ZipArchive,DestinationFolder);
      CloseZipArchive;
    END;

    [Internal]
    PROCEDURE ExtractZipFileAndGetFileList@63(ServerZipFilePath@1000 : Text;VAR NameValueBuffer@1001 : Record 823);
    VAR
      ServerDestinationFolder@1002 : Text;
    BEGIN
      ServerDestinationFolder := ServerCreateTempSubDirectory;
      ExtractZipFile(ServerZipFilePath,ServerDestinationFolder);
      GetServerDirectoryFilesList(NameValueBuffer,ServerDestinationFolder);
    END;

    [Internal]
    PROCEDURE ExportImage@70(ImagetPath@1000 : Text;ToFile@1005 : Text);
    VAR
      NameValueBuffer@1004 : Record 823;
      TempNameValueBuffer@1003 : TEMPORARY Record 823;
      FileManagement@1002 : Codeunit 419;
    BEGIN
      NameValueBuffer.DELETEALL;
      FileManagement.GetServerDirectoryFilesList(TempNameValueBuffer,TEMPORARYPATH);
      TempNameValueBuffer.SETFILTER(Name,STRSUBSTNO('%1*',ImagetPath));
      TempNameValueBuffer.FINDFIRST;
      ToFile := StripNotsupportChrInFileName(ToFile);
      DOWNLOAD(TempNameValueBuffer.Name,DownloadImageTxt,'','',ToFile);
      IF FileManagement.DeleteServerFile(TempNameValueBuffer.Name) THEN;
    END;

    [Internal]
    PROCEDURE IsClientDirectoryEmpty@60(Path@1000 : Text) : Boolean;
    BEGIN
      IF DirectoryHelper.Exists(Path) THEN
        EXIT(DirectoryHelper.GetFiles(Path).Length = 0);
      EXIT(FALSE);
    END;

    [Internal]
    PROCEDURE IsServerDirectoryEmpty@61(Path@1000 : Text) : Boolean;
    BEGIN
      IF ServerDirectoryHelper.Exists(Path) THEN
        EXIT(ServerDirectoryHelper.GetFiles(Path).Length = 0);
      EXIT(FALSE);
    END;

    [External]
    PROCEDURE IsWebOrDeviceClient@65() : Boolean;
    VAR
      ClientTypeManagement@1000 : Codeunit 4030;
    BEGIN
      EXIT(ClientTypeManagement.GetCurrentClientType IN [CLIENTTYPE::Web,CLIENTTYPE::Phone,CLIENTTYPE::Tablet,CLIENTTYPE::Desktop]);
    END;

    [Internal]
    PROCEDURE GetFileContent@66(FilePath@1000 : Text) Result : Text;
    VAR
      FileHandle@1001 : File;
      InStr@1002 : InStream;
    BEGIN
      IF NOT FILE.EXISTS(FilePath) THEN
        EXIT;

      FileHandle.OPEN(FilePath,TEXTENCODING::UTF8);
      FileHandle.CREATEINSTREAM(InStr);

      InStr.READTEXT(Result);
    END;

    [External]
    PROCEDURE AddStreamToZipStream@71(ZipStream@1000 : OutStream;StreamToAdd@1001 : InStream;PathInArchive@1002 : Text);
    VAR
      ZipArchiveLocal@1004 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchive";
      ZipArchiveEntry@1003 : DotNet "'System.IO.Compression, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Compression.ZipArchiveEntry";
      StreamReader@1005 : DotNet "'mscorlib'.System.IO.StreamReader";
      StreamWriter@1006 : DotNet "'mscorlib'.System.IO.StreamWriter";
      Encoding@1007 : DotNet "'mscorlib'.System.Text.Encoding";
    BEGIN
      ZipArchiveLocal := ZipArchiveLocal.ZipArchive(ZipStream,ZipArchiveMode.Update,TRUE);
      ZipArchiveEntry := ZipArchiveLocal.CreateEntry(PathInArchive);
      StreamReader := StreamReader.StreamReader(StreamToAdd,Encoding.Default);
      StreamWriter := StreamWriter.StreamWriter(ZipArchiveEntry.Open,StreamReader.CurrentEncoding);
      StreamWriter.Write(StreamReader.ReadToEnd);
      StreamWriter.Close;
      StreamReader.Close;
    END;

    [External]
    PROCEDURE IsAllowedPath@84(Path@1000 : Text;SkipError@1001 : Boolean) : Boolean;
    VAR
      MembershipEntitlement@1002 : Record 2000000195;
      WebRequestHelper@1003 : Codeunit 1299;
    BEGIN
      IF NOT MembershipEntitlement.ISEMPTY THEN
        IF NOT WebRequestHelper.IsHttpUrl(Path) THEN BEGIN
          CLEARLASTERROR;
          IF NOT FILE.ISPATHTEMPORARY(Path) THEN BEGIN
            IF SkipError THEN
              EXIT(FALSE);
            ERROR(NotAllowedPathErr,Path);
          END;
        END;
      EXIT(TRUE);
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterGetToFilterTextSetOutExt@83(FileName@1000 : Text;VAR OutExt@1001 : Text);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeDownloadHandler@85(VAR ToFolder@1000 : Text;ToFileName@1001 : Text;FromFileName@1002 : Text);
    BEGIN
    END;

    PROCEDURE BLOBImport4PS@1100525008(VAR TempBlob@1100525002 : Record 99008535;FileAbsPathName@1100525000 : Text;UserDialog@1100525008 : Boolean) : Text;
    VAR
      NVInStream@1100525007 : InStream;
      NVOutStream@1100525001 : OutStream;
      ShortFileName@1100525005 : Text;
      ShortFileName2@1100525003 : Text;
      TempFileAbsPathName@1100525500 : Text;
    BEGIN
      //**4PS
      IF NOT ClientAvailable AND
         NOT UserDialog
      THEN BEGIN
        BLOBImportFromServerFile(TempBlob, FileAbsPathName);
        EXIT(FileAbsPathName);
      END;

      CLEAR(TempBlob);
      IF UserDialog THEN
        EXIT(BLOBImport(TempBlob, FileAbsPathName))
      ELSE BEGIN
        ShortFileName := CopyClientFileToTempFolder(FileAbsPathName);
        ShortFileName2 := ShortFileName;
        UPLOADINTOSTREAM('', Magicpath, '', ShortFileName2, NVInStream);
        TempBlob.Blob.CREATEOUTSTREAM(NVOutStream);
        COPYSTREAM(NVOutStream, NVInStream);
        TempFileAbsPathName := ClientTempFolderName + ShortFileName;
        IF TempFileAbsPathName <> FileAbsPathName THEN
          DeleteClientFile4PS(TempFileAbsPathName, TRUE);
        EXIT(FileAbsPathName);
      END;
    END;

    PROCEDURE BLOBExport4PS@1100525001(VAR TempBlob@1002 : TEMPORARY Record 99008535;FileAbsPathName@1001 : Text;CommonDialog@1000 : Boolean;ConfirmReplaceExistingFile@1100525002 : Boolean) : Text;
    VAR
      NVInStream@1003 : InStream;
      TempFileAbsPathName@1100525001 : Text;
      ToFile@1100525003 : Text;
      ServerTempFileAbsPathName@1100528400 : Text;
    BEGIN
      //**4PS
      IF (NOT CommonDialog AND
         NOT ConfirmReplaceExistingFile)
      THEN BEGIN
        ServerTempFileAbsPathName := ServerTempFileName('');
        BLOBExportToServerFile(TempBlob, ServerTempFileAbsPathName);
        DownloadToFile(ServerTempFileAbsPathName, FileAbsPathName);
        ERASE(ServerTempFileAbsPathName);
        EXIT(FileAbsPathName);
      END;

      IF CommonDialog THEN
        ToFile := BLOBExport(TempBlob, FileAbsPathName, CommonDialog)
      ELSE BEGIN
        IF NOT TempBlob.Blob.HASVALUE THEN
          EXIT;
        TempBlob.Blob.CREATEINSTREAM(NVInStream);
        DOWNLOADFROMSTREAM(NVInStream, '', Magicpath, '', TempFileAbsPathName);
        IF NOT ClientDirectoryExists(
          GetDirectoryName(FileAbsPathName))
        THEN
          ERROR(Text11012002, FileAbsPathName);
        IF ClientFileExists(FileAbsPathName) THEN BEGIN
          IF ExistingFileMustBeReplaced(
            FileAbsPathName, ConfirmReplaceExistingFile)
          THEN BEGIN
            DeleteClientFile(FileAbsPathName);
            CopyClientFile(TempFileAbsPathName, FileAbsPathName, TRUE);
          END;
        END ELSE
          CopyClientFile(TempFileAbsPathName, FileAbsPathName, TRUE);
        DeleteClientFile(TempFileAbsPathName);
        ToFile := FileAbsPathName;
      END;
      CLEAR(TempBlob);
      EXIT(ToFile);
    END;

    LOCAL PROCEDURE MoveServerFile@1100525063(SourceFileName@1001 : Text;TargetFileName@1002 : Text);
    BEGIN
      //**4PS
      IF NOT EXISTS(SourceFileName) THEN
        ERROR(FileDoesNotExistErr, SourceFileName);
      IF EXISTS(TargetFileName) THEN
        ERASE(TargetFileName);
      COPY(SourceFileName, TargetFileName);
      ERASE(SourceFileName);
    END;

    PROCEDURE ServerTempFolderName@1100525500() FolderName : Text[1024];
    VAR
      FileName@1100525000 : Text[1024];
    BEGIN
      //**4PS
      FileName := ServerTempFileName('txt');
      FolderName := GetDirectoryName(FileName);
      IF COPYSTR(FolderName, STRLEN(FolderName), 1) <> '\' THEN
        FolderName := STRSUBSTNO('%1%2', FolderName, '\');
    END;

    PROCEDURE CreateServerFolder@1100525027(FolderAbsPathName@1100525000 : Text[1024]);
    VAR
      ServerDirectoryHelper@1100525002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
      ParentFolderAbsPathName@1100525001 : Text[1024];
    BEGIN
      //**4PS
      IF FolderAbsPathName <> '' THEN
        IF COPYSTR(FolderAbsPathName, STRLEN(FolderAbsPathName), 1) = '\' THEN
          FolderAbsPathName := COPYSTR(FolderAbsPathName, 1, STRLEN(FolderAbsPathName)-1);

      ParentFolderAbsPathName := GetDirectoryName(FolderAbsPathName);

      IF ServerFolderExists(FolderAbsPathName) THEN
        ERROR(Text11012008, FolderAbsPathName);
      IF NOT ServerFolderExists(ParentFolderAbsPathName) THEN
        ERROR(Text11012007, ParentFolderAbsPathName);
      ServerDirectoryHelper.CreateDirectory(FolderAbsPathName);
    END;

    PROCEDURE CreateServerFolderRecursively@1100525025(FolderAbsPathName@1100525000 : Text[1024]);
    BEGIN
      //**4PS
      FolderAbsPathName := DELCHR(FolderAbsPathName, '>', '\');
      IF NOT ServerFolderExists(FolderAbsPathName) THEN
        IF STRPOS(FolderAbsPathName, '\') > 0 THEN BEGIN
          CreateServerFolderRecursively(GetDirectoryName(FolderAbsPathName));
          CreateServerFolder(FolderAbsPathName);
        END ELSE
          CheckIfServerFolderExists(FolderAbsPathName); // "Root" folder (for example C:) should exist.
    END;

    PROCEDURE ServerFolderExists@1100525030(FolderAbsPathName@1001 : Text) : Boolean;
    VAR
      ServerDirectoryHelper@1100525000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
    BEGIN
      //**4PS
      EXIT(ServerDirectoryHelper.Exists(FolderAbsPathName));
    END;

    PROCEDURE CheckIfServerFolderExists@1100525031(FolderAbsPathName@1100525000 : Text[1024]);
    BEGIN
      //**4PS
      IF NOT ServerFolderExists(FolderAbsPathName) THEN
        ERROR(Text11012007, FolderAbsPathName);
    END;

    PROCEDURE ServerFolderIsEmpty@1100525029(FolderAbsPathName@1100525002 : Text[1024];SearchPattern@1100525000 : Text) : Boolean;
    VAR
      ServerDirectoryHelper@1100525003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
      FileArray@1100525005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      DirectoryArray@1100525004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
    BEGIN
      //**4PS
      IF NOT ServerFolderExists(FolderAbsPathName) THEN
        EXIT(TRUE);

      IF SearchPattern <> '' THEN
        FileArray := ServerDirectoryHelper.GetFiles(FolderAbsPathName, SearchPattern)
      ELSE
        FileArray := ServerDirectoryHelper.GetFiles(FolderAbsPathName);
      DirectoryArray := ServerDirectoryHelper.GetDirectories(FolderAbsPathName);
      IF (FileArray.Length = 0) AND
         (DirectoryArray.Length = 0)
      THEN
        EXIT(TRUE);
    END;

    PROCEDURE ClientTempFolderName@1100525020() FolderName : Text[1024];
    VAR
      FileName@1100525000 : Text[1024];
    BEGIN
      //**4PS
      // This function does not call ClientTempFileName, because ClientTempFileName will create
      // a file in ClientTempFolder, but does not delete this file.
      FileName := CreateClientTempFile;
      FolderName := GetDirectoryName(FileName);
      IF ClientFileExists(FileName) THEN
        DeleteClientFile(FileName);
      IF COPYSTR(FolderName, STRLEN(FolderName), 1) <> '\' THEN
        FolderName := STRSUBSTNO('%1%2', FolderName, '\');
    END;

    PROCEDURE CopyClientFile4PS@1100525018(SourceFileAbsPathName@1100525000 : Text[1024];DestinationFileAbsPathName@1100525002 : Text[1024];ThrowError@1100525001 : Boolean) : Boolean;
    VAR
      OperatingSystemMgt@1100409000 : Codeunit 11012364;
      Command@1100525003 : Text[1024];
    BEGIN
      //**4PS
      IF ClientAvailable THEN BEGIN
        IF ThrowError THEN BEGIN
          IF NOT ClientFileExists(SourceFileAbsPathName) THEN
            ERROR(Text11012000, SourceFileAbsPathName);
          IF NOT ClientDirectoryExists(
            GetDirectoryName(DestinationFileAbsPathName))
          THEN
            ERROR(Text11012002, DestinationFileAbsPathName);
          IF ClientFileExists(DestinationFileAbsPathName) THEN
            ERROR(Text11012003, DestinationFileAbsPathName);
          CopyClientFile(SourceFileAbsPathName, DestinationFileAbsPathName, FALSE);
          EXIT(TRUE);
        END ELSE BEGIN
          IF NOT ClientFileExists(SourceFileAbsPathName) THEN
            EXIT(FALSE);
          IF NOT ClientDirectoryExists(
            GetDirectoryName(DestinationFileAbsPathName))
          THEN
            EXIT(FALSE);
          IF ClientFileExists(DestinationFileAbsPathName) THEN
            EXIT(FALSE);
          Command := STRSUBSTNO('copy "%1" "%2"', SourceFileAbsPathName, DestinationFileAbsPathName);
          EXIT(OperatingSystemMgt.ExecuteBatchFileOnClient(Command));
        END;
      END ELSE
        IF ThrowError THEN BEGIN
          COPY(SourceFileAbsPathName, DestinationFileAbsPathName);
          EXIT(TRUE);
        END ELSE
          EXIT(COPY(SourceFileAbsPathName, DestinationFileAbsPathName));
    END;

    PROCEDURE CreateClientFolder@1100525026(FolderAbsPathName@1100525000 : Text[1024]) : Boolean;
    VAR
      ParentFolderAbsPathName@1100525001 : Text[1024];
    BEGIN
      //**4PS
      IF NOT ClientAvailable THEN BEGIN
        CreateServerFolder(FolderAbsPathName);
        EXIT;
      END;

      IF FolderAbsPathName <> '' THEN
        IF COPYSTR(FolderAbsPathName, STRLEN(FolderAbsPathName), 1) = '\' THEN
          FolderAbsPathName := COPYSTR(FolderAbsPathName, 1, STRLEN(FolderAbsPathName)-1);

      ParentFolderAbsPathName := GetDirectoryName(FolderAbsPathName);

      IF ClientDirectoryExists(FolderAbsPathName) THEN
        ERROR(Text11012008, FolderAbsPathName);
      IF NOT ClientDirectoryExists(ParentFolderAbsPathName) THEN
        ERROR(Text11012007, ParentFolderAbsPathName);
      DirectoryHelper.CreateDirectory(FolderAbsPathName);
      EXIT(TRUE);
    END;

    PROCEDURE CreateClientFolderRecursively@1100525010(FolderAbsPathName@1100525000 : Text[1024]);
    BEGIN
      //**4PS
      IF NOT ClientAvailable THEN BEGIN
        CreateServerFolderRecursively(FolderAbsPathName);
        EXIT;
      END;

      FolderAbsPathName := DELCHR(FolderAbsPathName, '>', '\');
      IF NOT ClientDirectoryExists(FolderAbsPathName) THEN
        IF STRPOS(FolderAbsPathName, '\') > 0 THEN BEGIN
          CreateClientFolderRecursively(GetDirectoryName(FolderAbsPathName));
          CreateClientFolder(FolderAbsPathName);
        END ELSE
          CheckIfClientFolderExists(FolderAbsPathName); // "Root" folder (for example C:) should exist.
    END;

    PROCEDURE DeleteClientFolder@1100525003(FolderAbsPathName@1100525000 : Text[1024]);
    VAR
      ServerDirectoryHelper@1100525001 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
    BEGIN
      //**4PS
      IF NOT ClientDirectoryExists(FolderAbsPathName) THEN
        ERROR(Text11012007, FolderAbsPathName);
      IF ClientAvailable THEN
        DirectoryHelper.Delete(FolderAbsPathName, TRUE)
      ELSE
        ServerDirectoryHelper.Delete(FolderAbsPathName, TRUE);
    END;

    PROCEDURE DeleteClientFile4PS@1100525006(FileAbsPathName@1100525000 : Text[1024];ThrowError@1100525002 : Boolean) : Boolean;
    VAR
      OperatingSystemMgt@1100409000 : Codeunit 11012364;
      Command@1100525001 : Text[1024];
    BEGIN
      //**4PS
      IF ClientAvailable THEN BEGIN
        IF ThrowError THEN BEGIN
          IF NOT ClientFileExists(FileAbsPathName) THEN
            ERROR(Text11012000, FileAbsPathName);
          EXIT(DeleteClientFile(FileAbsPathName));
        END ELSE BEGIN
          IF NOT ClientFileExists(FileAbsPathName) THEN
            EXIT(FALSE);
          Command := STRSUBSTNO('del "%1"', FileAbsPathName);
          IF NOT OperatingSystemMgt.ExecuteBatchFileOnClient(Command) THEN
            EXIT(FALSE);
          EXIT(NOT ClientFileExists(FileAbsPathName));
        END;
      END ELSE
        IF ThrowError THEN BEGIN
          ERASE(FileAbsPathName);
          EXIT(TRUE);
        END ELSE
          EXIT(ERASE(FileAbsPathName));
    END;

    PROCEDURE RenameClientFile@1100525002(SourceFileAbsPathName@1100525000 : Text[1024];DestinationFileAbsPathName@1100525002 : Text[1024];ThrowError@1100525001 : Boolean) : Boolean;
    VAR
      OperatingSystemMgt@1100409000 : Codeunit 11012364;
      SourceDirectoryName@1100525007 : Text[1024];
      SourceFileName@1100525006 : Text[1024];
      DestinationDirectoryName@1100525005 : Text[1024];
      DestinationFileName@1100525004 : Text[1024];
      Command@1100525003 : Text[1024];
    BEGIN
      //**4PS
      IF ClientAvailable THEN BEGIN
        IF ThrowError THEN BEGIN
          IF NOT ClientFileExists(SourceFileAbsPathName) THEN
            ERROR(Text11012000, SourceFileAbsPathName);
          IF NOT ClientDirectoryExists(
            GetDirectoryName(DestinationFileAbsPathName))
          THEN
            ERROR(Text11012002, DestinationFileAbsPathName);
          MoveFile(SourceFileAbsPathName, DestinationFileAbsPathName);
          EXIT(TRUE);
        END ELSE BEGIN
          IF (DestinationFileAbsPathName <> SourceFileAbsPathName) AND
             ClientFileExists(DestinationFileAbsPathName)
          THEN
            EXIT(FALSE);
          SplitFileAbsPathName(SourceFileAbsPathName, SourceDirectoryName, SourceFileName);
          SplitFileAbsPathName(DestinationFileAbsPathName, DestinationDirectoryName, DestinationFileName);
          IF SourceDirectoryName <> DestinationDirectoryName THEN BEGIN
            Command := STRSUBSTNO('move "%1" "%2"', SourceFileAbsPathName, DestinationDirectoryName);
            IF NOT OperatingSystemMgt.ExecuteBatchFileOnClient(Command) THEN
              EXIT(FALSE);
          END;
          // When SourceFileName = DestinationFileName, the function ExecuteBatchFileOnClient must be
          // called, because this situation occurs when this function is called from
          // FileIsInUseOnClient.
          Command := STRSUBSTNO('rename "%1" "%2"', DestinationDirectoryName + SourceFileName, DestinationFileName);
          EXIT(OperatingSystemMgt.ExecuteBatchFileOnClient(Command));
        END;
      END ELSE
        IF ThrowError THEN BEGIN
          RENAME(SourceFileAbsPathName, DestinationFileAbsPathName);
          EXIT(TRUE);
        END ELSE
          EXIT(RENAME(SourceFileAbsPathName, DestinationFileAbsPathName));
    END;

    PROCEDURE ClientFileIsInUse@1100525019(FileAbsPathName@1100525000 : Text[1024]) : Boolean;
    BEGIN
      //**4PS
      CheckIfClientFileExists(FileAbsPathName);
      // Since we could not find a method 'IsInUse' of the FileSystemObject,
      // we used the RenameFileOnClient function to determine if the file
      // is in use or not.
      // When for example an Excel file is edited with Excel, it is impossible
      // to rename the file, even if the new name is equal to the old name.
      EXIT(NOT RenameClientFile(FileAbsPathName, FileAbsPathName, FALSE));
    END;

    PROCEDURE ClientFolderIsEmpty@1100525024(FolderAbsPathName@1100525002 : Text[1024];SearchPattern@1100525000 : Text) : Boolean;
    VAR
      ClientDirectoryHelper@1100525003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory" RUNONCLIENT;
      FileArray@1100525005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array" RUNONCLIENT;
      DirectoryArray@1100525004 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array" RUNONCLIENT;
    BEGIN
      //**4PS
      IF NOT ClientAvailable THEN
        EXIT(ServerFolderIsEmpty(FolderAbsPathName, SearchPattern));

      IF NOT ClientDirectoryExists(FolderAbsPathName) THEN
        EXIT(TRUE);

      IF SearchPattern <> '' THEN
        FileArray := ClientDirectoryHelper.GetFiles(FolderAbsPathName, SearchPattern)
      ELSE
        FileArray := ClientDirectoryHelper.GetFiles(FolderAbsPathName);
      DirectoryArray := ClientDirectoryHelper.GetDirectories(FolderAbsPathName);
      IF (FileArray.Length = 0) AND
         (DirectoryArray.Length = 0)
      THEN
        EXIT(TRUE);
    END;

    PROCEDURE CheckIfClientFileExists@1100525007(FileAbsPathName@1100525000 : Text[1024]);
    BEGIN
      //**4PS
      IF NOT ClientFileExists(FileAbsPathName) THEN
        ERROR(Text11012000, FileAbsPathName);
    END;

    PROCEDURE CheckIfClientFolderExists@1100525023(FolderAbsPathName@1100525000 : Text[1024]);
    VAR
      AzureFileStorageManagement@1100527800 : Codeunit 11012350;
    BEGIN
      //**4PS
      CASE GetFileStorageType OF
        FileStorageType::"File System on Premise":
          IF NOT ClientDirectoryExists(FolderAbsPathName) THEN
            ERROR(Text11012007, FolderAbsPathName);
        FileStorageType::"Azure File Storage":
          IF NOT AzureFileStorageManagement.DirectoryExistsByResource(FolderAbsPathName) THEN
            ERROR(Text11012007, FolderAbsPathName);
      END;
    END;

    LOCAL PROCEDURE CopyClientFileToTempFolder@1100525017(FileAbsPathName@1100525000 : Text[1024]) : Text[1024];
    VAR
      ShortFileName@1100525005 : Text[1024];
      ClientTempDestFileAbsPathName@1100528700 : Text;
    BEGIN
      //**4PS
      IF NOT ClientFileExists(FileAbsPathName) THEN
        ERROR(Text11012000, FileAbsPathName);

      ShortFileName := GetFileName(FileAbsPathName);
      IF (FileAbsPathName <> ClientTempFolderName + ShortFileName) THEN
        ClientTempDestFileAbsPathName := ClientTempFolderName + ShortFileName
      ELSE
        ClientTempDestFileAbsPathName := ClientTempFileName(GetExtension(FileAbsPathName));

      CopyClientFile(FileAbsPathName, ClientTempDestFileAbsPathName, TRUE);
      EXIT(ShortFileName);
    END;

    LOCAL PROCEDURE CreateClientTempFile@1100525004() : Text[1024];
    VAR
      FileVar@1100525002 : File;
      IStream@1100525000 : InStream;
      TempFullFileName@1100525003 : Text[1024];
    BEGIN
      //**4PS
      FileVar.CREATETEMPFILE;

      IF ClientAvailable THEN BEGIN
        FileVar.CREATEINSTREAM(IStream);
        DOWNLOADFROMSTREAM(IStream, '', Magicpath,  '', TempFullFileName);
        FileVar.CLOSE;
      END ELSE BEGIN
        TempFullFileName := FileVar.NAME;
        FileVar.CLOSE;
        FileVar.CREATE(TempFullFileName);
        FileVar.CLOSE;
      END;

      EXIT(TempFullFileName);
    END;

    PROCEDURE ExistingFileMustBeReplaced@1100525005(FileAbsPathName@1100525000 : Text[1024];ConfirmReplaceExistingFile@1100525001 : Boolean) : Boolean;
    BEGIN
      //**4PS
      IF NOT ConfirmReplaceExistingFile THEN
        EXIT(TRUE);

      EXIT(CONFIRM(Text11012001, FALSE, FileAbsPathName));
    END;

    PROCEDURE OpenMultiselectFileDialog@1100525000(WindowTitle@1000 : Text[50];DefaultFileName@1001 : Text;FilterString@1002 : Text;VAR FileNames@1100525002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array") : Boolean;
    VAR
      OpenFileDialog@1006 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.OpenFileDialog" RUNONCLIENT;
      DialagResult@1003 : DotNet "'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Windows.Forms.DialogResult" RUNONCLIENT;
    BEGIN
      //**4PS
      CLEAR(FileNames);
      OpenFileDialog := OpenFileDialog.OpenFileDialog;
      OpenFileDialog.ShowReadOnly := FALSE;
      OpenFileDialog.FileName := GetFileName(DefaultFileName);
      OpenFileDialog.Title := WindowTitle;
      OpenFileDialog.Filter := GetToFilterText(FilterString,DefaultFileName);
      OpenFileDialog.InitialDirectory := GetDirectoryName(DefaultFileName);
      OpenFileDialog.Multiselect := TRUE;

      DialagResult := OpenFileDialog.ShowDialog;
      IF DialagResult.CompareTo(DialagResult.OK) = 0 THEN BEGIN
        FileNames := OpenFileDialog.FileNames;
        EXIT(TRUE);
      END;
    END;

    PROCEDURE GetFileNamesOfClientFolder@1100525012(FolderAbsPathName@1100525001 : Text;FileNameFilter@1100525002 : Text;VAR FileArray@1100525000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array");
    VAR
      ServerDirectoryHelper@1100525003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
    BEGIN
      //**4PS
      IF ClientAvailable THEN BEGIN
        IF FileNameFilter = '' THEN
          FileArray := DirectoryHelper.GetFiles(FolderAbsPathName)
        ELSE
          FileArray := DirectoryHelper.GetFiles(FolderAbsPathName, FileNameFilter);
      END ELSE BEGIN
        IF FileNameFilter = '' THEN
          FileArray := ServerDirectoryHelper.GetFiles(FolderAbsPathName)
        ELSE
          FileArray := ServerDirectoryHelper.GetFiles(FolderAbsPathName, FileNameFilter);
      END
    END;

    PROCEDURE GetDirectoryNamesOfClientFolder@1100528600(FolderAbsPathName@1100525001 : Text;DirectoryNameFilter@1100525002 : Text;VAR DirectoryArray@1100525000 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array");
    VAR
      ServerDirectoryHelper@1100525003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Directory";
    BEGIN
      //**4PS
      IF ClientAvailable THEN BEGIN
        IF DirectoryNameFilter = '' THEN
          DirectoryArray := DirectoryHelper.GetDirectories(FolderAbsPathName)
        ELSE
          DirectoryArray := DirectoryHelper.GetDirectories(FolderAbsPathName, DirectoryNameFilter);
      END ELSE BEGIN
        IF DirectoryNameFilter = '' THEN
          DirectoryArray := ServerDirectoryHelper.GetDirectories(FolderAbsPathName)
        ELSE
          DirectoryArray := ServerDirectoryHelper.GetDirectories(FolderAbsPathName, DirectoryNameFilter);
      END
    END;

    PROCEDURE SetAllowNewFileInOpenDialog@1100525009();
    BEGIN
      //**4PS
      AllowNewFileInOpenDialog := TRUE;
    END;

    PROCEDURE GetDirectoryNameWithBackSlash@1100525011(FileAbsPathName@1100525000 : Text) : Text;
    BEGIN
      //**4PS
       EXIT(GetFolderURIFromFileURI(FileStorageType::"File System on Premise",FileAbsPathName));
    END;

    PROCEDURE SelectDirectoryNameWithBackSlash@1100525013(VAR DirectoryName@1100525000 : Text) : Boolean;
    BEGIN
      //**4PS
      IF NOT SelectDirectoryName(DirectoryName) THEN
        EXIT;

      AddBackSlashToDirectoryName(DirectoryName);
      EXIT(TRUE);
    END;

    PROCEDURE AddBackSlashToDirectoryName@1100525022(VAR DirectoryName@1100525000 : Text);
    BEGIN
      //**4PS
      IF DirectoryName = '' THEN
        EXIT;

      IF (COPYSTR(DirectoryName, STRLEN(DirectoryName), 1) <> '\') THEN
        DirectoryName := STRSUBSTNO('%1\', DirectoryName);
    END;

    PROCEDURE SelectDirectoryName@1100525014(VAR DirectoryName@1100525000 : Text) : Boolean;
    VAR
      DefaultFileName@1100525001 : Text;
      NewFileName@1100525002 : Text;
    BEGIN
      //**4PS
      IF DirectoryName <> '' THEN BEGIN
        IF (COPYSTR(DirectoryName, STRLEN(DirectoryName), 1) = '\') THEN
          DefaultFileName := DirectoryName + Text11012020
        ELSE
          DefaultFileName := DirectoryName + '\' + Text11012020;
      END ELSE
        DefaultFileName := Text11012020;

      NewFileName := SaveFileDialog(Text11012021, DefaultFileName, '');
      IF NewFileName <> '' THEN BEGIN
        DirectoryName := GetDirectoryName(NewFileName);
        EXIT(TRUE);
      END;
    END;

    PROCEDURE SelectFile@1100525015(Extension@1100525004 : Text[30];VAR DirectoryNameWithBackSlash@1100525000 : Text;VAR ShortFileName@1100525001 : Text;VAR FileAbsPathName@1100525002 : Text) : Boolean;
    VAR
      FileMgt@1100525003 : Codeunit 419;
      FilterString@1100525005 : Text;
      DefaultFileName@1100525006 : Text;
      SelectedFileName@1100525007 : Text;
    BEGIN
      //**4PS
      FileMgt.SetAllowNewFileInOpenDialog;

      IF Extension <> '' THEN
        IF COPYSTR(Extension, 1, 1) <> '.' THEN
          Extension := '.' + Extension;
      FilterString := FileMgt.GetToFilterText('', Extension);

      DefaultFileName := ComposeDefaultFileName(
        Extension, DirectoryNameWithBackSlash, ShortFileName, FileAbsPathName);

      SelectedFileName := FileMgt.OpenFileDialog(Text11012021, DefaultFileName, FilterString);
      IF SelectedFileName = '' THEN
        EXIT(FALSE);

      FileAbsPathName := SelectedFileName;
      SplitFileAbsPathName(FileAbsPathName, DirectoryNameWithBackSlash, ShortFileName);
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE ComposeDefaultFileName@1100525021(Extension@1100525004 : Text[30];DirectoryNameWithBackSlash@1100525000 : Text;ShortFileName@1100525001 : Text;FileAbsPathName@1100525002 : Text) : Text;
    BEGIN
      //**4PS
      IF FileAbsPathName <> '' THEN
        EXIT(FileAbsPathName);

      IF ShortFileName <> '' THEN
        EXIT(DirectoryNameWithBackSlash + ShortFileName);

      IF Extension <> '' THEN
        EXIT(DirectoryNameWithBackSlash + '*' + Extension);

      EXIT(DirectoryNameWithBackSlash + '*.*');
    END;

    PROCEDURE SplitFileAbsPathName@1100525016(FileAbsPathName@1100525000 : Text;VAR DirectoryNameWithBackSlash@1100525002 : Text;VAR ShortFileName@1100525001 : Text);
    BEGIN
      //**4PS
      SplitFileURI(FileStorageType::"File System on Premise",FileAbsPathName,DirectoryNameWithBackSlash,ShortFileName);
    END;

    PROCEDURE SplitFileAbsPathNameForMainStorage@1100527800(FileAbsPathName@1100525000 : Text;VAR DirectoryNameWithBackSlash@1100525002 : Text;VAR ShortFileName@1100525001 : Text);
    BEGIN
      //**4PS
      SplitFileURI(GetFileStorageType,FileAbsPathName,DirectoryNameWithBackSlash,ShortFileName);
    END;

    PROCEDURE ClientAvailable@1100525028() : Boolean;
    BEGIN
      //**4PS
      EXIT(GUIALLOWED AND NOT IsWebClient);
    END;

    PROCEDURE ClientFileLastWriteTime@1100528601(ClientFilePath@1100528600 : Text;VAR LastWriteDate@1100528601 : Date;VAR LastWriteTime@1100528602 : Time);
    VAR
      LastWriteDateTime@1100528603 : DateTime;
    BEGIN
      //**4PS
      LastWriteDateTime := ClientFileHelper.GetLastWriteTime(ClientFilePath);
      LastWriteDate := DT2DATE(LastWriteDateTime);
      LastWriteTime := DT2TIME(LastWriteDateTime);
    END;

    PROCEDURE ChangeExtension@1100528700(Path@1100528700 : Text;Extension@1100528701 : Text) : Text;
    BEGIN
      //**4PS
      EXIT(PathHelper.ChangeExtension(Path, Extension));
    END;

    PROCEDURE TestIsWindowsClient@1100528701();
    BEGIN
      //**4PS
      IF NOT IsWindowsClient THEN
        ERROR(Text11012023);
    END;

    PROCEDURE GetUniqueClientFileName@1100528702(ClientFileName@1100528700 : Text) : Text;
    VAR
      Directory@1100528701 : Text;
      ShortFileName@1100528702 : Text;
      Extension@1100528703 : Text;
      I@1100528704 : Integer;
    BEGIN
      IF ClientFileName = '' THEN
        EXIT;

      I := 0;
      Directory := GetDirectoryName(ClientFileName);
      ShortFileName := GetFileNameWithoutExtension(ClientFileName);
      Extension := GetExtension(ClientFileName);
      WHILE ClientFileExists(ClientFileName) DO BEGIN
        I += 1;
        ClientFileName := Directory + '\' + ShortFileName + '_' + FORMAT(I) + '.' + Extension;
      END;

      EXIT(ClientFileName);
    END;

    PROCEDURE GetPossiblePicturesExtensions@1100528602(VAR OFilters@1100528600 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList");
    BEGIN
      //**4PS
      IF ISNULL(OFilters) THEN
        OFilters := OFilters.ArrayList();
      OFilters.Add('bmp');
      OFilters.Add('jpe');
      OFilters.Add('jpeg');
      OFilters.Add('jpg');
      OFilters.Add('gif');
      OFilters.Add('png');
      OFilters.Add('tif');
      OFilters.Add('tiff');
    END;

    PROCEDURE GetPictureFilterText@1100528605() : Text;
    VAR
      Extensions@1100528600 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Collections.ArrayList";
      FilterString@1100528603 : Text;
      i@1100528601 : Integer;
    BEGIN
      //**4PS
      GetPossiblePicturesExtensions(Extensions);
      FOR i := 0 TO Extensions.Count -1 DO BEGIN
        IF FilterString <> '' THEN
          FilterString += ';';
        FilterString += STRSUBSTNO('%1%2', '*.', Extensions.Item(i));
      END;
      EXIT(STRSUBSTNO('%1|%2', Text014, FilterString));
    END;

    PROCEDURE GetServerDirectoryFilesListByExtension@1100529600(VAR NameValueBuffer@1100529600 : TEMPORARY Record 823;DirectoryPath@1100529601 : Text;FileExtension@1100529602 : Text[10]);
    VAR
      ArrayHelper@1100529604 : DotNet "'mscorlib'.System.Array";
      i@1100529605 : Integer;
      FileName@1100529603 : Text;
    BEGIN
      //**4PS
      NameValueBuffer.RESET;
      NameValueBuffer.DELETEALL;

      IF NOT ServerDirectoryExists(DirectoryPath) THEN
        EXIT;

      ArrayHelper := ServerDirectoryHelper.GetFiles(DirectoryPath);
      FOR i := 1 TO ArrayHelper.GetLength(0) DO
        IF EVALUATE(FileName, ArrayHelper.GetValue(i - 1)) THEN
          IF STRPOS(GetExtension(FileName), FileExtension) <> 0 THEN BEGIN
            NameValueBuffer.ID := i;
            NameValueBuffer.Name := COPYSTR(FileName, 1, MAXSTRLEN(NameValueBuffer.Name));
            NameValueBuffer.Value := COPYSTR(GetFileName(FileName), 1, MAXSTRLEN(NameValueBuffer.Value));
            NameValueBuffer.INSERT;
          END;
    END;

    PROCEDURE CheckUncPath@1100528300(PathName@1100528300 : Text);
    BEGIN
      IF (COPYSTR(PathName, 1, 2) <> '//') THEN
        ERROR(Text000);
    END;

    LOCAL PROCEDURE GetFileStorageType@1100525035() : Integer;
    VAR
      DocumentManagement@1100527800 : Codeunit 11012406;
    BEGIN
      EXIT(DocumentManagement.GetMainStorageType);
    END;

    PROCEDURE StorageFileExists@1100525039(FilePath@1001 : Text;StorageType@1100528600 : Option) : Boolean;
    VAR
      AzureFileStorageManagement@1100525000 : Codeunit 11012350;
    BEGIN
      //**4PS.sn
      //d365mg.n
      CASE StorageType OF
        FileStorageType::"File System on Premise":
          EXIT(ServerFileExists(FilePath));
        FileStorageType::"Azure File Storage":
          EXIT(AzureFileStorageManagement.FileExistsByResource(FilePath));
      END;
    END;

    PROCEDURE GetFileNameFromURI@1100527803(StorageType@1100527801 : Integer;FilePath@1100527800 : Text) : Text;
    VAR
      AzureFileStorageManagement@1100527802 : Codeunit 11012350;
    BEGIN
      CASE StorageType OF
        FileStorageType::"File System on Premise",
        FileStorageType::"SharePoint Online":
          EXIT(PathHelper.GetFileName(FilePath));
        FileStorageType::"Azure File Storage":
          EXIT(AzureFileStorageManagement.GetFileFromResource(FilePath));
      END;
    END;

    PROCEDURE GetFolderURIFromFileURI@1100527802(StorageType@1100527801 : Integer;FileAbsPathName@1100525000 : Text) : Text;
    VAR
      AzureFileStorageManagement@1100527800 : Codeunit 11012350;
      DirectoryName@1100525001 : Text;
    BEGIN
      //**4PS
      IF FileAbsPathName = '' THEN
        EXIT('');

      CASE StorageType OF
        FileStorageType::"File System on Premise":
          BEGIN
            DirectoryName := GetDirectoryName(FileAbsPathName);
            AddBackSlashToDirectoryName(DirectoryName);
          END;
        FileStorageType::"Azure File Storage":
          BEGIN
            DirectoryName := AzureFileStorageManagement.GetPathFromResource(FileAbsPathName, TRUE);
            DirectoryName := AzureFileStorageManagement.AddSlashToResource(DirectoryName);
          END;
      END;
      EXIT(DirectoryName);
    END;

    PROCEDURE AddDelimiterToDirectoryName@1100525044(VAR DirectoryName@1100525000 : Text);
    VAR
      AzureFileStorageManagement@1100525001 : Codeunit 11012350;
      StringFunctions@1100527800 : Codeunit 11012273;
    BEGIN
      CASE GetFileStorageType OF
        FileStorageType::"File System on Premise":
          AddBackSlashToDirectoryName(DirectoryName);
        FileStorageType::"Azure File Storage":
          DirectoryName := AzureFileStorageManagement.AddSlashToResource(DirectoryName);
        FileStorageType::"SharePoint Online":
          StringFunctions.CheckEndingSlash(DirectoryName);
      END;
    END;

    PROCEDURE SelectStorageDirectoryName@1100525038(VAR DirectoryName@1100525000 : Text) Result : Boolean;
    VAR
      AzureFileStorageManagement@1100525001 : Codeunit 11012350;
      SelectedDirectoryName@1100525002 : Text;
    BEGIN
      //d365mg.n
      CASE GetFileStorageType OF
        FileStorageType::"File System on Premise":
          Result := SelectDirectoryName(DirectoryName);
        FileStorageType::"Azure File Storage":
          BEGIN
            SelectedDirectoryName := AzureFileStorageManagement.SelectEntryByResource(DirectoryName, 1, TRUE, TRUE);
            Result := SelectedDirectoryName <> '';
            IF Result THEN
              DirectoryName := SelectedDirectoryName;
          END;
      END;
    END;

    PROCEDURE SplitFileURI@1100527801(StorageType@1100527801 : Integer;FileAbsPathName@1100525000 : Text;VAR DirectoryNameWithSlashOrBackSlash@1100525002 : Text;VAR ShortFileName@1100525001 : Text);
    VAR
      AzureFileStorageManagement@1100527800 : Codeunit 11012350;
    BEGIN
      //**4PS
      CASE StorageType OF
        FileStorageType::"File System on Premise":
          BEGIN
            DirectoryNameWithSlashOrBackSlash := GetDirectoryNameWithBackSlash(FileAbsPathName);
            ShortFileName := GetFileName(FileAbsPathName);
          END;
        FileStorageType::"Azure File Storage", FileStorageType::"SharePoint Online":
          BEGIN
            DirectoryNameWithSlashOrBackSlash := AzureFileStorageManagement.AddSlashToResource(AzureFileStorageManagement.GetPathFromResource(FileAbsPathName, TRUE));
            ShortFileName := AzureFileStorageManagement.GetFileFromResource(FileAbsPathName);
          END;
      END;
    END;

    PROCEDURE ReadFileContentToOutStream@1100527810(FileName@1100527800 : Text;OStream@1100527801 : OutStream);
    VAR
      InputFile@1100527802 : File;
      IStream@1100527803 : InStream;
    BEGIN
      //**4PS
      InputFile.OPEN(FileName);
      InputFile.CREATEINSTREAM(IStream);
      COPYSTREAM(OStream,IStream);
      InputFile.CLOSE;
    END;

    PROCEDURE WriteFileContentFromOutStream@1100527806(FileName@1100527800 : Text;VAR OStream@1100528402 : OutStream);
    VAR
      FileStream@1100528401 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileStream";
      FileMode@1100528400 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.FileMode";
      MemoryStream@1100528403 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
    BEGIN
      //**4PS
      FileStream := FileStream.FileStream(FileName, FileMode.CreateNew);
      MemoryStream := OStream;
      MemoryStream.WriteTo(FileStream);
      FileStream.Close;
      FileStream.Dispose;
    END;

    PROCEDURE ReadFileContentToMemoryStream@1100527805(File@1100527803 : Text;VAR MemoryStream@1100527800 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream") : Boolean;
    VAR
      Bytes@1100527802 : DotNet "'mscorlib, Version=4.0.97.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      IOFile@1100527801 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.File";
    BEGIN
      //**4PS
      IF IOFile.Exists(File) THEN BEGIN
        Bytes := IOFile.ReadAllBytes(File);
        MemoryStream.Write(Bytes,0,Bytes.Length);
        MemoryStream.Flush();
        EXIT(TRUE);
      END;
    END;

    PROCEDURE ReadFileContentToMemoryStreamFromClient@1100527809(File@1100527803 : Text;VAR MemoryStream@1100527800 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream") : Boolean;
    VAR
      Bytes@1100527802 : DotNet "'mscorlib, Version=4.0.97.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      IOFile@1100527801 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.File" RUNONCLIENT;
    BEGIN
      //**4PS
      IF NOT ClientAvailable THEN
        EXIT(ReadFileContentToMemoryStream(File, MemoryStream));

      IF IOFile.Exists(File) THEN BEGIN
        Bytes := IOFile.ReadAllBytes(File);
        MemoryStream.Write(Bytes,0,Bytes.Length);
        MemoryStream.Flush();
        EXIT(TRUE);
      END;
    END;

    PROCEDURE ReadFileContentToBase64BigText@1100527807(File@1100527803 : Text;VAR Base64@1100527800 : BigText) : Boolean;
    VAR
      Bytes@1100527802 : DotNet "'mscorlib, Version=4.0.97.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      IOFile@1100527801 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.File";
      Convert@1100527804 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Convert";
    BEGIN
      //**4PS
      IF IOFile.Exists(File) THEN BEGIN
        Bytes := IOFile.ReadAllBytes(File);
        Base64.ADDTEXT(Convert.ToBase64String(Bytes));
        EXIT(TRUE);
      END;
    END;

    PROCEDURE ReadFileContentToBase64@1100527808(File@1100527803 : Text;VAR Base64@1100527800 : Text) : Boolean;
    VAR
      Bytes@1100527802 : DotNet "'mscorlib, Version=4.0.97.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Array";
      IOFile@1100527801 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.File";
      Convert@1100527804 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Convert";
    BEGIN
      //**4PS
      IF IOFile.Exists(File) THEN BEGIN
        Bytes := IOFile.ReadAllBytes(File);
        Base64 := Convert.ToBase64String(Bytes);
        EXIT(TRUE);
      END;
    END;

    BEGIN
    END.
  }
}

