OBJECT Codeunit 99000774 Calculate Routing Line
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVW114.04;
  }
  PROPERTIES
  {
    Permissions=TableData 5405=r,
                TableData 5406=r,
                TableData 5409=im,
                TableData 5410=rimd,
                TableData 99000754=r,
                TableData 99000757=r,
                TableData 99000758=r,
                TableData 99000765=r,
                TableData 99000866=r;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Text000@1000 : TextConst 'DEU=Fehler beim Berechnen von %1. Kalender ist fÅr %2 %3 nicht verfÅgbar fÅr %4 %5.;ENU=Error when calculating %1. Calendar is not available %2 %3 for %4 %5.;NLD=Fout bij %1 berekening. Agenda is niet beschikbaar %2 %3 voor %4 %5.;NOR=Feil ved beregning av %1. Kalenderen er ikke tilgjengelig %2 %3 for %4 %5.;SVE=Fel vid berÑkning av %1. Kalender Ñr inte tillgÑnglig %2 %3 fîr %4 %5.';
      Text001@1001 : TextConst 'DEU=rÅckwÑrts;ENU=backward;NLD=achterwaartse;NOR=bakover;SVE=bakÜt';
      Text002@1002 : TextConst 'DEU=Vorher;ENU=before;NLD=voor;NOR=fõr;SVE=fîre';
      Text003@1003 : TextConst 'DEU=vorwÑrts;ENU=forward;NLD=voorwaartse;NOR=fremover;SVE=framÜt';
      Text004@1004 : TextConst 'DEU=nach;ENU=after;NLD=na;NOR=etter;SVE=efter';
      Text005@1005 : TextConst 'DEU=Die Summe aus RÅst-, Transport- und Wartezeit Åberschreitet die verfÅgbare Zeit innerhalb des Intervalls.;ENU=The sum of setup, move and wait time exceeds the available time in the period.;NLD=De som van insteltijd, transporttijd en wachttijd overschrijdt de beschikbare tijd in de periode.;NOR=Den sammenlagte oppstillings-, transport- og ventetiden overstiger den disponible tiden i perioden.;SVE=Summan av omstÑllnings-, transport- och vÑntetid îverskrider tillgÑnglig tid i perioden.';
      Text006@1006 : TextConst 'DEU=fixer Plan;ENU=fixed schedule;NLD=vaste planning;NOR=fast timeplan;SVE=fast plan';
      Text007@1007 : TextConst 'DEU=Die Startzeit muss vor der Endzeit liegen.;ENU=Starting time must be before ending time.;NLD=Begintijd moet voor eindtijd vallen.;NOR=Starttidspunktet mÜ vëre fõr sluttidspunktet.;SVE=Starttid mÜste vara fîre sluttid.';
      MfgSetup@1008 : Record 99000765;
      Workcenter@1009 : Record 99000754;
      Workcenter2@1010 : Record 99000754;
      MachineCenter@1011 : Record 99000758;
      ProdOrder@1012 : Record 5405;
      ProdOrderLine@1013 : Record 5406;
      ProdOrderRoutingLine@1014 : Record 5409;
      ProdOrderCapNeed@1015 : Record 5410;
      ProdOrderCapNeed2@1016 : Record 5410;
      CalendarEntry@1017 : Record 99000757;
      CalendarMgt@1018 : Codeunit 99000755;
      UOMMgt@1037 : Codeunit 5402;
      NextCapNeedLineNo@1020 : Integer;
      ProdStartingTime@1021 : Time;
      ProdEndingTime@1022 : Time;
      ProdStartingDate@1023 : Date;
      ProdEndingDate@1024 : Date;
      MaxLotSize@1025 : Decimal;
      TotalLotSize@1026 : Decimal;
      ProdOrderQty@1027 : Decimal;
      TotalScrap@1028 : Decimal;
      LotSize@1029 : Decimal;
      RemainNeedQty@1030 : Decimal;
      ConCurrCap@1031 : Decimal;
      RunStartingDateTime@1032 : DateTime;
      RunEndingDateTime@1033 : DateTime;
      FirstInBatch@1034 : Boolean;
      FirstEntry@1035 : Boolean;
      UpdateDates@1036 : Boolean;
      WaitTimeOnly@1019 : Boolean;
      CurrentWorkCenterNo@1038 : Code[20];
      CurrentTimeFactor@1039 : Decimal;
      CurrentRounding@1040 : Decimal;

    LOCAL PROCEDURE TestForError@15(DirectionTxt@1000 : Text[30];BefAfterTxt@1001 : Text[30];Date@1002 : Date);
    BEGIN
      IF RemainNeedQty <> 0 THEN
        ERROR(
          Text000,
          DirectionTxt,
          BefAfterTxt,
          Date,
          ProdOrderRoutingLine.Type,
          ProdOrderRoutingLine."No.");
    END;

    LOCAL PROCEDURE CreateCapNeed@7(NeedDate@1000 : Date;StartingTime@1001 : Time;EndingTime@1002 : Time;NeedQty@1003 : Decimal;TimeType@1004 : 'Setup Time,Run Time';Direction@1005 : 'Forward,Backward');
    BEGIN
      ProdOrderCapNeed.INIT;
      ProdOrderCapNeed.Status := ProdOrder.Status;
      ProdOrderCapNeed."Prod. Order No." := ProdOrder."No.";
      ProdOrderCapNeed."Routing No." := ProdOrderRoutingLine."Routing No.";
      ProdOrderCapNeed."Routing Reference No." := ProdOrderRoutingLine."Routing Reference No.";
      ProdOrderCapNeed."Line No." := NextCapNeedLineNo;
      ProdOrderCapNeed.Type := ProdOrderRoutingLine.Type;
      ProdOrderCapNeed."No." := ProdOrderRoutingLine."No.";
      ProdOrderCapNeed."Work Center No." := ProdOrderRoutingLine."Work Center No.";
      ProdOrderCapNeed."Operation No." := ProdOrderRoutingLine."Operation No.";
      ProdOrderCapNeed."Work Center Group Code" := ProdOrderRoutingLine."Work Center Group Code";
      ProdOrderCapNeed.Date := NeedDate;
      ProdOrderCapNeed."Starting Time" := StartingTime;
      ProdOrderCapNeed."Ending Time" := EndingTime;
      ProdOrderCapNeed."Needed Time" := NeedQty;
      ProdOrderCapNeed."Needed Time (ms)" := NeedQty * CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code");
      ProdOrderCapNeed."Concurrent Capacities" := ConCurrCap;
      ProdOrderCapNeed.Efficiency := CalendarEntry.Efficiency;
      ProdOrderCapNeed."Requested Only" := FALSE;
      ProdOrderCapNeed.Active := TRUE;
      IF ProdOrder.Status <> ProdOrder.Status::Simulated THEN BEGIN
        ProdOrderCapNeed."Allocated Time" := NeedQty;
        ProdOrderRoutingLine."Expected Capacity Need" :=
          ProdOrderRoutingLine."Expected Capacity Need" + ProdOrderCapNeed."Needed Time (ms)";
      END;

      ProdOrderCapNeed."Time Type" := TimeType;
      IF TimeType = TimeType::"Run Time" THEN
        ProdOrderCapNeed."Lot Size" := LotSize;

      IF TimeType = TimeType::"Run Time" THEN
        IF RemainNeedQty = 0 THEN BEGIN
          IF FirstInBatch THEN
            ProdOrderCapNeed."Send-Ahead Type" := ProdOrderCapNeed."Send-Ahead Type"::Both
          ELSE
            CASE Direction OF
              Direction::Forward:
                ProdOrderCapNeed."Send-Ahead Type" := ProdOrderCapNeed."Send-Ahead Type"::Output;
              Direction::Backward:
                ProdOrderCapNeed."Send-Ahead Type" := ProdOrderCapNeed."Send-Ahead Type"::Input;
            END;
        END ELSE
          IF FirstInBatch THEN
            CASE Direction OF
              Direction::Forward:
                ProdOrderCapNeed."Send-Ahead Type" := ProdOrderCapNeed."Send-Ahead Type"::Input;
              Direction::Backward:
                ProdOrderCapNeed."Send-Ahead Type" := ProdOrderCapNeed."Send-Ahead Type"::Output;
            END;

      ProdOrderCapNeed.UpdateDatetime;

      ProdOrderCapNeed.INSERT;

      NextCapNeedLineNo := NextCapNeedLineNo + 1;
    END;

    LOCAL PROCEDURE CreateLoadBack@16(TimeType@1000 : 'Setup Time,Run Time,Wait Time,Move Time,Queue Time';Write@1001 : Boolean);
    VAR
      OldCalendarEntry@1006 : Record 99000757;
      AvQtyBase@1002 : Decimal;
      RelevantEfficiency@1003 : Decimal;
      xConCurrCap@1005 : Decimal;
      RemainNeedQtyBase@1009 : Decimal;
      StartingTime@1004 : Time;
      StopLoop@1008 : Boolean;
    BEGIN
      xConCurrCap := 1;
      IF (RemainNeedQty = 0) AND ((NOT FirstEntry) OR (NOT Write) OR WaitTimeOnly) THEN
        EXIT;
      IF CalendarEntry.FIND('+') THEN BEGIN
        IF (TimeType = TimeType::"Wait Time") AND (CalendarEntry.Date < ProdEndingDate) THEN BEGIN
          CalendarEntry.Date := ProdEndingDate;
          CreateCalendarEntry(CalendarEntry);
        END;
        GetCurrentWorkCenterTimeFactorAndRounding(CalendarEntry."Work Center No.");
        RemainNeedQtyBase := ROUND(RemainNeedQty * CurrentTimeFactor,CurrentRounding);
        REPEAT
          OldCalendarEntry := CalendarEntry;
          ConCurrCap := ProdOrderRoutingLine."Concurrent Capacities";
          IF (ConCurrCap = 0) OR (CalendarEntry.Capacity < ConCurrCap) THEN
            ConCurrCap := CalendarEntry.Capacity;
          IF TimeType <> TimeType::"Run Time" THEN
            RemainNeedQtyBase := ROUND(RemainNeedQtyBase * ConCurrCap / xConCurrCap,CurrentRounding);
          xConCurrCap := ConCurrCap;
          AvQtyBase :=
            CalcAvailQtyBase(
              CalendarEntry,ProdEndingDate,ProdEndingTime,TimeType,ConCurrCap,FALSE,CurrentTimeFactor,CurrentRounding);

          IF AvQtyBase > RemainNeedQtyBase THEN
            AvQtyBase := RemainNeedQtyBase;
          IF TimeType IN [TimeType::"Setup Time",TimeType::"Run Time"] THEN
            RelevantEfficiency := CalendarEntry.Efficiency
          ELSE
            RelevantEfficiency := 100;
          StartingTime :=
            CalendarMgt.CalcTimeSubtract(
              CalendarEntry."Ending Time",
              ROUND(AvQtyBase * 100 / RelevantEfficiency / ConCurrCap,1,'>'));
          RemainNeedQtyBase := RemainNeedQtyBase - AvQtyBase;
          IF Write THEN BEGIN
            RemainNeedQty := ROUND(RemainNeedQtyBase / CurrentTimeFactor,CurrentRounding);
            CreateCapNeed(
              CalendarEntry.Date,StartingTime,CalendarEntry."Ending Time",
              ROUND(AvQtyBase / CurrentTimeFactor,CurrentRounding),TimeType,1);
            FirstInBatch := FALSE;
            FirstEntry := FALSE;
          END;
          IF UpdateDates AND
             ((CalendarEntry."Capacity (Effective)" <> 0) OR (TimeType = TimeType::"Wait Time"))
          THEN BEGIN
            ProdOrderRoutingLine."Ending Time" := CalendarEntry."Ending Time";
            ProdOrderRoutingLine."Ending Date" := CalendarEntry.Date;
            UpdateDates := FALSE;
          END;
          ProdEndingTime := StartingTime;
          ProdEndingDate := CalendarEntry.Date;
          ProdOrderRoutingLine."Starting Time" := StartingTime;
          ProdOrderRoutingLine."Starting Date" := CalendarEntry.Date;

          IF (RemainNeedQtyBase = 0) AND ((NOT FirstEntry) OR (NOT Write)) THEN
            StopLoop := TRUE
          ELSE
            IF TimeType = TimeType::"Wait Time" THEN BEGIN
              StopLoop := FALSE;
              ReturnNextCalendarEntry(CalendarEntry,OldCalendarEntry,0);
            END ELSE BEGIN
              CalendarEntry := OldCalendarEntry;
              StopLoop := CalendarEntry.NEXT(-1) = 0;
            END;
        UNTIL StopLoop;
        RemainNeedQty := ROUND(RemainNeedQtyBase / CurrentTimeFactor,CurrentRounding);
      END;
    END;

    LOCAL PROCEDURE CreateLoadForward@6(TimeType@1000 : 'Setup Time,Run Time,Wait Time,Move Time,Queue Time';Write@1001 : Boolean;LoadFactor@1002 : Decimal);
    VAR
      OldCalendarEntry@1007 : Record 99000757;
      AvQtyBase@1003 : Decimal;
      RelevantEfficiency@1004 : Decimal;
      xConCurrCap@1006 : Decimal;
      RemainNeedQtyBase@1010 : Decimal;
      EndingTime@1005 : Time;
      StopLoop@1009 : Boolean;
    BEGIN
      xConCurrCap := 1;
      IF (RemainNeedQty = 0) AND ((NOT FirstEntry) OR (NOT Write) OR WaitTimeOnly) THEN
        EXIT;
      IF CalendarEntry.FIND('-') THEN BEGIN
        IF (TimeType = TimeType::"Wait Time") AND (CalendarEntry.Date > ProdStartingDate) THEN BEGIN
          CalendarEntry.Date := ProdStartingDate;
          CreateCalendarEntry(CalendarEntry);
        END;
        IF CalendarEntry."Capacity (Effective)" = 0 THEN BEGIN
          CalendarEntry."Starting Time" := ProdStartingTime;
          CalendarEntry.Date := ProdStartingDate;
        END;
        IF CalendarEntry."Work Center No." = Workcenter."No." THEN
          GetCurrentWorkCenterTimeFactorAndRounding(Workcenter."No.")
        ELSE
          GetCurrentWorkCenterTimeFactorAndRounding(CalendarEntry."Work Center No.");
        RemainNeedQtyBase := ROUND(RemainNeedQty * CurrentTimeFactor,CurrentRounding);
        REPEAT
          OldCalendarEntry := CalendarEntry;
          ConCurrCap := ProdOrderRoutingLine."Concurrent Capacities";
          IF (ConCurrCap = 0) OR (CalendarEntry.Capacity < ConCurrCap) THEN
            ConCurrCap := CalendarEntry.Capacity;
          IF TimeType <> TimeType::"Run Time" THEN
            RemainNeedQtyBase := ROUND(RemainNeedQtyBase * ConCurrCap / xConCurrCap,CurrentRounding);
          xConCurrCap := ConCurrCap;
          AvQtyBase :=
            CalcAvailQtyBase(
              CalendarEntry,ProdStartingDate,ProdStartingTime,TimeType,ConCurrCap,TRUE,CurrentTimeFactor,CurrentRounding);

          IF AvQtyBase * LoadFactor > RemainNeedQtyBase THEN
            AvQtyBase := ROUND(RemainNeedQtyBase / LoadFactor,CurrentRounding);

          IF TimeType IN [TimeType::"Setup Time",TimeType::"Run Time"] THEN
            RelevantEfficiency := CalendarEntry.Efficiency
          ELSE
            RelevantEfficiency := 100;
          EndingTime :=
            CalendarEntry."Starting Time" + ROUND(AvQtyBase * 100 / RelevantEfficiency / ConCurrCap,1,'>');

          IF AvQtyBase * LoadFactor >= 0 THEN
            RemainNeedQtyBase := RemainNeedQtyBase - AvQtyBase * LoadFactor;
          IF Write THEN BEGIN
            RemainNeedQty := ROUND(RemainNeedQtyBase / CurrentTimeFactor,CurrentRounding);
            CreateCapNeed(
              CalendarEntry.Date,CalendarEntry."Starting Time",EndingTime,
              ROUND(AvQtyBase * LoadFactor / CurrentTimeFactor,CurrentRounding),TimeType,0);
            FirstInBatch := FALSE;
            FirstEntry := FALSE;
          END;
          IF UpdateDates AND
             ((CalendarEntry."Capacity (Effective)" <> 0) OR (TimeType = TimeType::"Wait Time"))
          THEN BEGIN
            ProdOrderRoutingLine."Starting Time" := CalendarEntry."Starting Time";
            ProdOrderRoutingLine."Starting Date" := CalendarEntry.Date;
            UpdateDates := FALSE;
          END;
          IF (EndingTime = 000000T) AND (AvQtyBase <> 0) THEN
            // Ending Time reached 24:00:00 so we need to move date as well
            CalendarEntry.Date := CalendarEntry.Date + 1;
          ProdStartingTime := EndingTime;
          ProdStartingDate := CalendarEntry.Date;
          ProdOrderRoutingLine."Ending Time" := EndingTime;
          ProdOrderRoutingLine."Ending Date" := CalendarEntry.Date;

          IF ProdOrderRoutingLine."Schedule Manually" THEN BEGIN
            IF TimeType = TimeType::"Setup Time" THEN
              RunStartingDateTime := CREATEDATETIME(ProdStartingDate,ProdStartingTime);
            IF RemainNeedQtyBase < 0 THEN
              RemainNeedQtyBase := 0;
          END;

          IF (RemainNeedQtyBase = 0) AND ((NOT FirstEntry) OR (NOT Write)) AND (AvQtyBase * LoadFactor >= 0) THEN
            StopLoop := TRUE
          ELSE
            IF TimeType = TimeType::"Wait Time" THEN BEGIN
              StopLoop := FALSE;
              ReturnNextCalendarEntry(CalendarEntry,OldCalendarEntry,1);
            END ELSE BEGIN
              CalendarEntry := OldCalendarEntry;
              StopLoop := CalendarEntry.NEXT = 0;
            END;
        UNTIL StopLoop;
        RemainNeedQty := ROUND(RemainNeedQtyBase / CurrentTimeFactor,CurrentRounding);
      END;
    END;

    LOCAL PROCEDURE AvailableCapacity@13(CapType@1001 : 'Work Center,Machine Center';CapNo@1002 : Code[20];StartingDateTime@1003 : DateTime;EndingDateTime@1004 : DateTime) AvQty@1000 : Decimal;
    VAR
      CalendarEntry2@1005 : Record 99000757;
      ConCurrCapacity@1006 : Decimal;
      Overlap@1007 : Decimal;
      TotalDuration@1008 : Decimal;
    BEGIN
      CalendarEntry2.SetCapacityFilters(CapType,CapNo);
      CalendarEntry2.SETFILTER("Starting Date-Time",'<=%1',EndingDateTime);
      CalendarEntry2.SETFILTER("Ending Date-Time",'>=%1',StartingDateTime);

      IF CalendarEntry2.FIND('-') THEN
        REPEAT
          ConCurrCapacity := ProdOrderRoutingLine."Concurrent Capacities";
          IF (ConCurrCapacity = 0) OR (CalendarEntry2.Capacity < ConCurrCapacity) THEN
            ConCurrCapacity := CalendarEntry2.Capacity;

          Overlap := 0;
          IF StartingDateTime > CalendarEntry2."Starting Date-Time" THEN
            Overlap := CalcDuration(CalendarEntry2."Starting Date-Time",StartingDateTime);
          IF EndingDateTime < CalendarEntry2."Ending Date-Time" THEN
            Overlap := Overlap + CalcDuration(EndingDateTime,CalendarEntry2."Ending Date-Time");

          TotalDuration := CalcDuration(CalendarEntry2."Starting Date-Time",CalendarEntry2."Ending Date-Time");

          AvQty := AvQty +
            ROUND(
              ((TotalDuration - Overlap) / TotalDuration) *
              CalendarEntry2."Capacity (Effective)" / CalendarEntry2.Capacity * ConCurrCapacity,
              Workcenter."Calendar Rounding Precision");
        UNTIL CalendarEntry2.NEXT = 0;
      EXIT(AvQty);
    END;

    LOCAL PROCEDURE LoadCapBack@11(CapType@1000 : 'Work Center,Machine Center';CapNo@1001 : Code[20];TimeType@1002 : 'Setup Time,Run Time,Wait Time,Move Time,Queue Time';Write@1003 : Boolean);
    BEGIN
      ProdOrderRoutingLine."Starting Date" := ProdEndingDate;
      ProdOrderRoutingLine."Starting Time" := ProdEndingTime;

      CalendarEntry.SetCapacityFilters(CapType,CapNo);
      CalendarEntry.SETRANGE("Ending Date-Time",0DT,CREATEDATETIME(ProdEndingDate + 1,ProdEndingTime));
      CalendarEntry.SETRANGE("Starting Date-Time",0DT,CREATEDATETIME(ProdEndingDate,ProdEndingTime));

      CreateLoadBack(TimeType,Write);

      IF RemainNeedQty = 0 THEN
        EXIT;

      TestForError(Text001,Text002,ProdOrderRoutingLine."Starting Date");
    END;

    LOCAL PROCEDURE LoadCapForward@12(CapType@1000 : 'Work Center,Machine Center';CapNo@1001 : Code[20];TimeType@1002 : 'Setup Time,Run Time,Wait Time,Move Time,Queue Time';Write@1003 : Boolean);
    VAR
      TotalAvailCapacity@1004 : Decimal;
      LoadFactor@1005 : Decimal;
    BEGIN
      ProdOrderRoutingLine."Ending Date" := ProdStartingDate;
      ProdOrderRoutingLine."Ending Time" := ProdStartingTime;

      CalendarEntry.SetCapacityFilters(CapType,CapNo);
      CalendarEntry.SETFILTER("Starting Date-Time",'>=%1',CREATEDATETIME(ProdStartingDate - 1,ProdStartingTime));
      IF TimeType = TimeType::"Wait Time" THEN
        CalendarEntry.SETFILTER("Ending Date-Time",'>=%1',CREATEDATETIME(ProdStartingDate,000000T))
      ELSE
        CalendarEntry.SETFILTER("Ending Date-Time",'>=%1',CREATEDATETIME(ProdStartingDate,ProdStartingTime));

      IF ProdOrderRoutingLine."Schedule Manually" AND (TimeType = TimeType::"Run Time") THEN BEGIN
        IF (RunEndingDateTime < RunStartingDateTime) OR
           ((RunEndingDateTime = RunStartingDateTime) AND
            (ProdOrderRoutingLine."Run Time" <> 0) AND
            (ProdOrderRoutingLine."Input Quantity" <> 0))
        THEN
          ERROR(Text005);
        TotalAvailCapacity :=
          AvailableCapacity(CapType,CapNo,RunStartingDateTime,RunEndingDateTime);
        IF TotalAvailCapacity = 0 THEN BEGIN
          TestForError(Text006,Text002,DT2DATE(RunEndingDateTime));
          LoadFactor := 0;
        END ELSE
          LoadFactor := ROUND(RemainNeedQty / TotalAvailCapacity,Workcenter."Calendar Rounding Precision",'>');
      END ELSE
        LoadFactor := 1;

      CreateLoadForward(TimeType,Write,LoadFactor);

      IF RemainNeedQty = 0 THEN
        EXIT;

      TestForError(Text003,Text004,ProdOrderRoutingLine."Ending Date");
    END;

    LOCAL PROCEDURE CalcMoveAndWaitBack@4();
    BEGIN
      UpdateDates := TRUE;

      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Move Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Move Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");

      LoadCapBack(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.",3,FALSE);
      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Wait Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Wait Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      LoadCapBack(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.",2,FALSE);
    END;

    LOCAL PROCEDURE GetSendAheadStartingTime@5(ProdOrderRoutingLine2@1000 : Record 5409;VAR SendAheadLotSize@1002 : Decimal) : Boolean;
    VAR
      xProdOrderRoutingLine@1001 : Record 5409;
      ResidualLotSize@1003 : Decimal;
      ResidualProdStartDateTime@1004 : DateTime;
    BEGIN
      ProdStartingDate := ProdOrderRoutingLine2."Starting Date";
      ProdStartingTime := ProdOrderRoutingLine2."Starting Time";
      SendAheadLotSize := MaxLotSize;
      IF TotalLotSize = MaxLotSize THEN
        EXIT(TRUE);

      WITH ProdOrderRoutingLine DO BEGIN
        IF ("Send-Ahead Quantity" = 0) OR
           ("Send-Ahead Quantity" >= MaxLotSize)
        THEN BEGIN
          TotalLotSize := SendAheadLotSize;
          EXIT(FALSE);
        END;

        SendAheadLotSize := "Send-Ahead Quantity";
        IF MaxLotSize < (TotalLotSize + SendAheadLotSize) THEN BEGIN
          SendAheadLotSize := MaxLotSize - TotalLotSize;
          TotalLotSize := MaxLotSize;
        END ELSE BEGIN
          IF TotalLotSize = 0 THEN BEGIN
            ResidualLotSize := MaxLotSize - SendAheadLotSize * ROUND(MaxLotSize / SendAheadLotSize,1,'<');
            IF ResidualLotSize = 0 THEN
              ResidualLotSize := SendAheadLotSize;
          END;
          TotalLotSize := TotalLotSize + SendAheadLotSize;
        END;

        ProdOrderCapNeed2.RESET;
        ProdOrderCapNeed2.SETCURRENTKEY(Status,"Prod. Order No.","Routing Reference No.","Operation No.",Date,"Starting Time");
        ProdOrderCapNeed2.SETRANGE(Status,Status);
        ProdOrderCapNeed2.SETRANGE("Prod. Order No.","Prod. Order No.");
        ProdOrderCapNeed2.SETRANGE("Requested Only",FALSE);
        ProdOrderCapNeed2.SETRANGE("Routing No.","Routing No.");
        ProdOrderCapNeed2.SETRANGE("Routing Reference No.","Routing Reference No.");
        ProdOrderCapNeed2.SETRANGE("Operation No.","Operation No.");
        IF ProdOrderCapNeed2.FINDFIRST THEN
          EXIT(FALSE);

        Workcenter2.GET(ProdOrderRoutingLine2."Work Center No.");
        RemainNeedQty :=
          ROUND(
            (ResidualLotSize * ProdOrderRoutingLine2.RunTimePer) *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
            Workcenter2."Calendar Rounding Precision");

        xProdOrderRoutingLine := ProdOrderRoutingLine;
        ProdOrderRoutingLine := ProdOrderRoutingLine2;
        ProdEndingDate := "Ending Date";
        ProdEndingTime := "Ending Time";
        LoadCapBack(Type,"No.",1,FALSE);
        ProdOrderRoutingLine := xProdOrderRoutingLine;

        "Starting Date" := ProdEndingDate;
        "Starting Time" := ProdEndingTime;
        ResidualProdStartDateTime := CREATEDATETIME(ProdEndingDate,ProdEndingTime);

        Workcenter.GET("Work Center No.");
        RemainNeedQty :=
          ROUND(
            (MaxLotSize - SendAheadLotSize) * RunTimePer *
            CalendarMgt.TimeFactor("Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");

        LoadCapForward(Type,"No.",1,FALSE);

        UpdateDatetime;
        IF "Ending Date-Time" > ResidualProdStartDateTime THEN BEGIN
          "Ending Date" := DT2DATE(ResidualProdStartDateTime);
          "Ending Time" := DT2TIME(ResidualProdStartDateTime);
          IF "Ending Time" > CalendarEntry."Ending Time" THEN
            "Ending Time" := CalendarEntry."Ending Time";
          ProdStartingDate := "Ending Date";
          ProdStartingTime := "Ending Time";
        END;
      END;
      EXIT(FALSE);
    END;

    LOCAL PROCEDURE CalcRoutingLineBack@1(CalculateEndDate@1000 : Boolean);
    VAR
      ProdOrderRoutingLine2@1001 : Record 5409;
      ProdOrderRoutingLine3@1002 : Record 5409;
      ConstrainedCapacity@1003 : Record 99000866;
      ParentWorkCenter@1004 : Record 99000866;
      TmpProdOrderRtngLine@1008 : TEMPORARY Record 5409;
      SendAheadLotSize@1005 : Decimal;
      ParentIsConstrained@1006 : Boolean;
      ResourceIsConstrained@1007 : Boolean;
    BEGIN
      CalendarEntry.SETRANGE(Date,0D,ProdOrderRoutingLine."Ending Date");

      ProdEndingTime := ProdOrderRoutingLine."Ending Time";
      ProdEndingDate := ProdOrderRoutingLine."Ending Date";
      ProdStartingTime := ProdOrderRoutingLine."Ending Time";
      ProdStartingDate := ProdOrderRoutingLine."Ending Date";

      FirstEntry := TRUE;

      IF (ProdOrderRoutingLine."Next Operation No." <> '') AND
         CalculateEndDate
      THEN BEGIN
        CLEAR(ProdOrderRoutingLine3);

        TmpProdOrderRtngLine.RESET;
        TmpProdOrderRtngLine.DELETEALL;

        SetRoutingLineFilters(ProdOrderRoutingLine,ProdOrderRoutingLine2);
        ProdOrderRoutingLine2.SETFILTER("Operation No.",ProdOrderRoutingLine."Next Operation No.");
        IF ProdOrderRoutingLine2.FIND('-') THEN
          REPEAT
            TotalLotSize := 0;
            GetSendAheadStartingTime(ProdOrderRoutingLine2,SendAheadLotSize);

            TmpProdOrderRtngLine.COPY(ProdOrderRoutingLine2);
            TmpProdOrderRtngLine.INSERT;

            SetMinDateTime(ProdEndingDate,ProdEndingTime,ProdStartingDate,ProdStartingTime);
            ProdOrderRoutingLine3 := ProdOrderRoutingLine2;
          UNTIL ProdOrderRoutingLine2.NEXT = 0;
        IF ProdOrderRoutingLine3."Prod. Order No." <> '' THEN BEGIN
          Workcenter2.GET(ProdOrderRoutingLine3."Work Center No.");
          ProdOrderRoutingLine3."Critical Path" := TRUE;
          ProdOrderRoutingLine3.UpdateDatetime;
          ProdOrderRoutingLine3.MODIFY;
          IF ProdOrderRoutingLine3.Type = ProdOrderRoutingLine3.Type::"Machine Center" THEN BEGIN
            MachineCenter.GET(ProdOrderRoutingLine3."No.");
            Workcenter2."Queue Time" := MachineCenter."Queue Time";
            Workcenter2."Queue Time Unit of Meas. Code" :=
              MachineCenter."Queue Time Unit of Meas. Code";
          END;
          UpdateDates := FALSE;
          RemainNeedQty :=
            ROUND(
              Workcenter2."Queue Time" *
              CalendarMgt.TimeFactor(Workcenter2."Queue Time Unit of Meas. Code") /
              CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
              Workcenter2."Calendar Rounding Precision");

          LoadCapBack(ProdOrderRoutingLine2.Type,ProdOrderRoutingLine2."No.",4,FALSE);
        END ELSE
          ProdOrderRoutingLine3 := ProdOrderRoutingLine2;
      END ELSE BEGIN
        TotalLotSize := MaxLotSize;
        SendAheadLotSize := MaxLotSize;
      END;

      // In case of Parallel Routing and the last operation is finished
      IF ProdEndingDate = CalendarMgt.GetMaxDate THEN BEGIN
        ProdOrderRoutingLine."Ending Date" := ProdOrderLine."Ending Date";
        ProdOrderRoutingLine."Ending Time" := ProdOrderLine."Ending Time";

        ProdEndingTime := ProdOrderRoutingLine."Ending Time";
        ProdEndingDate := ProdOrderRoutingLine."Ending Date";
        ProdStartingTime := ProdOrderRoutingLine."Ending Time";
        ProdStartingDate := ProdOrderRoutingLine."Ending Date";

        TotalLotSize := MaxLotSize;
        SendAheadLotSize := MaxLotSize;
      END;

      UpdateDates := TRUE;

      CalcMoveAndWaitBack;

      IF ProdOrderRoutingLine."Schedule Manually" THEN // Move and wait time has been calculated
        EXIT;

      REPEAT
        LotSize := SendAheadLotSize;
        RemainNeedQty :=
          LotSize *
          ProdOrderRoutingLine.RunTimePer;
        RemainNeedQty :=
          ROUND(
            RemainNeedQty *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine."Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");

        WITH ProdOrderRoutingLine DO BEGIN
          ResourceIsConstrained := ConstrainedCapacity.GET(Type,"No.");
          ParentIsConstrained := ParentWorkCenter.GET(Type::"Work Center","Work Center No.");
          IF NOT "Schedule Manually" AND
             (ResourceIsConstrained OR ParentIsConstrained)
          THEN
            FinitelyLoadCapBack(1,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained)
          ELSE
            LoadCapBack(Type,"No.",1,TRUE);
        END;

        ProdEndingDate := ProdOrderRoutingLine."Starting Date";
        ProdEndingTime := ProdOrderRoutingLine."Starting Time";
      UNTIL FindSendAheadStartingTime(TmpProdOrderRtngLine,SendAheadLotSize);

      ProdEndingDate := ProdOrderRoutingLine."Starting Date";
      ProdEndingTime := ProdOrderRoutingLine."Starting Time";
      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Setup Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Setup Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");

      WITH ProdOrderRoutingLine DO BEGIN
        ResourceIsConstrained := ConstrainedCapacity.GET(Type,"No.");
        ParentIsConstrained := ParentWorkCenter.GET(Type::"Work Center","Work Center No.");
        IF NOT "Schedule Manually" AND
           (ResourceIsConstrained OR ParentIsConstrained)
        THEN
          FinitelyLoadCapBack(0,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained)
        ELSE
          LoadCapBack(Type,"No.",0,TRUE);

        "Starting Date" := ProdEndingDate;
        "Starting Time" := ProdEndingTime;

        IF "Ending Date" = CalendarMgt.GetMaxDate THEN BEGIN
          "Ending Date" := "Starting Date";
          "Ending Time" := "Starting Time";
        END;

        UpdateDatetime;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE GetSendAheadEndingTime@8(ProdOrderRoutingLine2@1000 : Record 5409;VAR SendAheadLotSize@1002 : Decimal) : Boolean;
    VAR
      xProdOrderRoutingLine@1009 : Record 5409;
      SetupTime@1006 : Decimal;
      RunTime@1007 : Decimal;
      WaitTime@1005 : Decimal;
      MoveTime@1004 : Decimal;
      SendAheadTimes@1008 : Integer;
      ResidualLotSize@1003 : Decimal;
      ResidualProdStartDateTime@1001 : DateTime;
    BEGIN
      ProdEndingTime := ProdOrderRoutingLine2."Ending Time";
      ProdEndingDate := ProdOrderRoutingLine2."Ending Date";
      SendAheadLotSize := MaxLotSize;
      IF TotalLotSize = MaxLotSize THEN
        EXIT(TRUE);

      WITH ProdOrderRoutingLine DO BEGIN
        IF (ProdOrderRoutingLine2."Send-Ahead Quantity" = 0) OR
           (ProdOrderRoutingLine2."Send-Ahead Quantity" >= MaxLotSize)
        THEN BEGIN
          TotalLotSize := SendAheadLotSize;
          EXIT(FALSE);
        END;
        SendAheadLotSize := ProdOrderRoutingLine2."Send-Ahead Quantity";
        IF MaxLotSize < (TotalLotSize + SendAheadLotSize) THEN BEGIN
          SendAheadLotSize := MaxLotSize - TotalLotSize;
          TotalLotSize := MaxLotSize;
        END ELSE BEGIN
          IF TotalLotSize = 0 THEN BEGIN
            ResidualLotSize := MaxLotSize MOD SendAheadLotSize;
            IF ResidualLotSize = 0 THEN
              ResidualLotSize := SendAheadLotSize;
          END;
          TotalLotSize += SendAheadLotSize;
        END;

        ProdOrderCapNeed2.RESET;
        ProdOrderCapNeed2.SETCURRENTKEY(Status,"Prod. Order No.","Routing Reference No.","Operation No.",Date,"Starting Time");
        ProdOrderCapNeed2.SETRANGE(Status,Status);
        ProdOrderCapNeed2.SETRANGE("Prod. Order No.","Prod. Order No.");
        ProdOrderCapNeed2.SETRANGE("Requested Only",FALSE);
        ProdOrderCapNeed2.SETRANGE("Routing No.","Routing No.");
        ProdOrderCapNeed2.SETRANGE("Routing Reference No.","Routing Reference No.");
        ProdOrderCapNeed2.SETRANGE("Operation No.","Operation No.");
        IF ProdOrderCapNeed2.FINDFIRST THEN
          EXIT(FALSE);

        Workcenter2.GET(ProdOrderRoutingLine2."Work Center No.");
        SetupTime :=
          ROUND(
            ProdOrderRoutingLine2."Setup Time" *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Setup Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
            Workcenter2."Calendar Rounding Precision");
        RunTime :=
          ROUND(
            SendAheadLotSize * ProdOrderRoutingLine2.RunTimePer *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
            Workcenter2."Calendar Rounding Precision");
        WaitTime :=
          ROUND(
            ProdOrderRoutingLine2."Wait Time" *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Wait Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
            Workcenter2."Calendar Rounding Precision");
        MoveTime :=
          ROUND(
            ProdOrderRoutingLine2."Move Time" *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Move Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
            Workcenter2."Calendar Rounding Precision");

        xProdOrderRoutingLine := ProdOrderRoutingLine;
        ProdOrderRoutingLine := ProdOrderRoutingLine2;
        ProdStartingDate := "Starting Date";
        ProdStartingTime := "Starting Time";
        RemainNeedQty := SetupTime;
        LoadCapForward(Type,"No.",0,FALSE);
        RemainNeedQty := RunTime;
        LoadCapForward(Type,"No.",1,FALSE);
        RemainNeedQty := WaitTime;
        LoadCapForward(Type,"No.",2,FALSE);
        RemainNeedQty := MoveTime;
        LoadCapForward(Type,"No.",3,FALSE);
        ProdOrderRoutingLine := xProdOrderRoutingLine;

        "Starting Date" := ProdStartingDate;
        "Starting Time" := ProdStartingTime;

        Workcenter.GET("Work Center No.");
        SetupTime :=
          ROUND(
            "Setup Time" *
            CalendarMgt.TimeFactor("Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");
        RunTime :=
          ROUND(
            (MaxLotSize - ResidualLotSize) * RunTimePer *
            CalendarMgt.TimeFactor("Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");
        WaitTime :=
          ROUND(
            "Wait Time" *
            CalendarMgt.TimeFactor("Wait Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");
        MoveTime :=
          ROUND(
            "Move Time" *
            CalendarMgt.TimeFactor("Move Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");

        SendAheadTimes := 0;
        IF "Send-Ahead Quantity" <> 0 THEN
          SendAheadTimes := (MaxLotSize - ResidualLotSize) DIV "Send-Ahead Quantity";

        RemainNeedQty := SetupTime;
        LoadCapForward(Type,"No.",0,FALSE);
        RemainNeedQty := RunTime;
        LoadCapForward(Type,"No.",1,FALSE);
        RemainNeedQty := WaitTime * SendAheadTimes;
        LoadCapForward(Type,"No.",2,FALSE);
        RemainNeedQty := MoveTime * SendAheadTimes;
        LoadCapForward(Type,"No.",3,FALSE);
        ResidualProdStartDateTime := CREATEDATETIME(ProdStartingDate,ProdStartingTime);

        ProdOrderRoutingLine2.UpdateDatetime;
        IF ProdOrderRoutingLine2."Ending Date-Time" > ResidualProdStartDateTime THEN BEGIN
          ProdEndingDate := ProdOrderRoutingLine2."Ending Date";
          ProdEndingTime := ProdOrderRoutingLine2."Ending Time";
          RemainNeedQty := MoveTime * SendAheadTimes;
          LoadCapBack(Type,"No.",3,FALSE);
          RemainNeedQty := WaitTime * SendAheadTimes;
          LoadCapBack(Type,"No.",2,FALSE);
          RemainNeedQty := RunTime;
          LoadCapBack(Type,"No.",1,FALSE);
          RemainNeedQty := SetupTime;
          LoadCapBack(Type,"No.",0,FALSE);
        END;

        ProdStartingDate := "Starting Date";
        ProdStartingTime := "Starting Time";
        ProdEndingDate := "Starting Date";
        ProdEndingTime := "Starting Time";
      END;
      EXIT(FALSE);
    END;

    LOCAL PROCEDURE CalcRoutingLineForward@3(CalculateStartDate@1000 : Boolean);
    VAR
      ProdOrderRoutingLine2@1001 : Record 5409;
      ProdOrderRoutingLine3@1002 : Record 5409;
      ConstrainedCapacity@1003 : Record 99000866;
      ParentWorkCenter@1004 : Record 99000866;
      TmpProdOrderRtngLine@1009 : TEMPORARY Record 5409;
      SendAheadLotSize@1005 : Decimal;
      InputQtyDiffTime@1008 : Decimal;
      ParentIsConstrained@1006 : Boolean;
      ResourceIsConstrained@1007 : Boolean;
    BEGIN
      CalendarEntry.SETRANGE(Date,ProdOrderRoutingLine."Starting Date",DMY2DATE(31,12,9999));

      ProdStartingTime := ProdOrderRoutingLine."Starting Time";
      ProdStartingDate := ProdOrderRoutingLine."Starting Date";
      ProdEndingTime := ProdOrderRoutingLine."Starting Time";
      ProdEndingDate := ProdOrderRoutingLine."Starting Date";

      InputQtyDiffTime := 0;

      FirstEntry := TRUE;

      IF (ProdOrderRoutingLine."Previous Operation No." <> '') AND
         CalculateStartDate
      THEN BEGIN
        CLEAR(ProdOrderRoutingLine3);

        TmpProdOrderRtngLine.RESET;
        TmpProdOrderRtngLine.DELETEALL;

        SetRoutingLineFilters(ProdOrderRoutingLine,ProdOrderRoutingLine2);
        ProdOrderRoutingLine2.SETFILTER("Operation No.",ProdOrderRoutingLine."Previous Operation No.");
        IF ProdOrderRoutingLine2.FIND('-') THEN
          REPEAT
            TotalLotSize := 0;
            GetSendAheadEndingTime(ProdOrderRoutingLine2,SendAheadLotSize);

            TmpProdOrderRtngLine.COPY(ProdOrderRoutingLine2);
            TmpProdOrderRtngLine.INSERT;

            SetMaxDateTime(ProdStartingDate,ProdStartingTime,ProdEndingDate,ProdEndingTime);
            ProdOrderRoutingLine3 := ProdOrderRoutingLine2;

            IF (ProdOrderRoutingLine2."Send-Ahead Quantity" > 0) AND
               (ProdOrderRoutingLine2."Input Quantity" > ProdOrderRoutingLine."Input Quantity")
            THEN BEGIN
              Workcenter2.GET(ProdOrderRoutingLine2."Work Center No.");
              InputQtyDiffTime :=
                (ProdOrderRoutingLine2."Input Quantity" - ProdOrderRoutingLine."Input Quantity") *
                ProdOrderRoutingLine2.RunTimePer;
              InputQtyDiffTime :=
                ROUND(
                  InputQtyDiffTime *
                  CalendarMgt.TimeFactor(ProdOrderRoutingLine2."Run Time Unit of Meas. Code") /
                  CalendarMgt.TimeFactor(Workcenter2."Unit of Measure Code"),
                  Workcenter2."Calendar Rounding Precision");
            END;
          UNTIL ProdOrderRoutingLine2.NEXT = 0
        ELSE
          // parallel routing with finished first operation
          IF ProdStartingDate = 0D THEN BEGIN
            ProdOrderRoutingLine2.GET(ProdOrderRoutingLine.Status,
              ProdOrderRoutingLine."Prod. Order No.",ProdOrderRoutingLine."Routing Reference No.",
              ProdOrderRoutingLine."Routing No.",ProdOrderRoutingLine."Operation No.");
            ProdStartingDate := ProdOrderRoutingLine2."Starting Date";
            ProdStartingTime := ProdOrderRoutingLine2."Starting Time";
          END;
        IF ProdOrderRoutingLine3."Prod. Order No." <> '' THEN BEGIN
          ProdOrderRoutingLine3."Critical Path" := TRUE;
          ProdOrderRoutingLine3.UpdateDatetime;
          ProdOrderRoutingLine3.MODIFY;
        END;
      END ELSE BEGIN
        TotalLotSize := MaxLotSize;
        SendAheadLotSize := MaxLotSize;
      END;
      RemainNeedQty :=
        ROUND(
          Workcenter."Queue Time" *
          CalendarMgt.TimeFactor(Workcenter."Queue Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      RemainNeedQty += InputQtyDiffTime;
      LoadCapForward(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.",4,FALSE);
      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Setup Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Setup Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      UpdateDates := TRUE;

      WITH ProdOrderRoutingLine DO BEGIN
        ResourceIsConstrained := ConstrainedCapacity.GET(Type,"No.");
        ParentIsConstrained := ParentWorkCenter.GET(Type::"Work Center","Work Center No.");
        IF NOT "Schedule Manually" AND
           (RemainNeedQty > 0) AND (ResourceIsConstrained OR ParentIsConstrained)
        THEN
          FinitelyLoadCapForward(0,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained)
        ELSE
          LoadCapForward(Type,"No.",0,TRUE);
      END;

      FirstInBatch := TRUE;
      REPEAT
        IF (InputQtyDiffTime > 0) AND (TotalLotSize = MaxLotSize) THEN
          SetMaxDateTime(
            ProdStartingDate,ProdStartingTime,ProdOrderRoutingLine2."Ending Date",ProdOrderRoutingLine2."Ending Time");

        LotSize := SendAheadLotSize;
        RemainNeedQty := LotSize * ProdOrderRoutingLine.RunTimePer;
        RemainNeedQty :=
          ROUND(
            RemainNeedQty *
            CalendarMgt.TimeFactor(ProdOrderRoutingLine."Run Time Unit of Meas. Code") /
            CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
            Workcenter."Calendar Rounding Precision");

        WITH ProdOrderRoutingLine DO BEGIN
          ResourceIsConstrained := ConstrainedCapacity.GET(Type,"No.");
          ParentIsConstrained := ParentWorkCenter.GET(Type::"Work Center","Work Center No.");
          IF NOT "Schedule Manually" AND
             (RemainNeedQty > 0) AND (ResourceIsConstrained OR ParentIsConstrained)
          THEN
            FinitelyLoadCapForward(1,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained)
          ELSE
            LoadCapForward(Type,"No.",1,TRUE);
        END;

        ProdStartingDate := ProdOrderRoutingLine."Ending Date";
        ProdStartingTime := ProdOrderRoutingLine."Ending Time";
      UNTIL FindSendAheadEndingTime(TmpProdOrderRtngLine,SendAheadLotSize);

      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Wait Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Wait Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      LoadCapForward(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.",2,FALSE);
      RemainNeedQty :=
        ROUND(
          ProdOrderRoutingLine."Move Time" *
          CalendarMgt.TimeFactor(ProdOrderRoutingLine."Move Time Unit of Meas. Code") /
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      LoadCapForward(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.",3,FALSE);

      WITH ProdOrderRoutingLine DO BEGIN
        IF "Starting Date" = 0D THEN BEGIN
          "Starting Date" := "Ending Date";
          "Starting Time" := "Ending Time";
        END;

        UpdateDatetime;
        MODIFY;
      END;
    END;

    LOCAL PROCEDURE CalculateRoutingLineFixed@9();
    VAR
      FixedProdOrderRoutingLine@1000 : Record 5409;
    BEGIN
      FixedProdOrderRoutingLine := ProdOrderRoutingLine;
      IF FixedProdOrderRoutingLine."Starting Date-Time" > FixedProdOrderRoutingLine."Ending Date-Time" THEN
        ERROR(Text007);

      // Calculate wait and move time, find end of runtime
      CalcRoutingLineBack(TRUE);
      RunEndingDateTime :=
        CREATEDATETIME(ProdOrderRoutingLine."Starting Date",ProdOrderRoutingLine."Starting Time");

      // Find start of runtime
      ProdOrderRoutingLine := FixedProdOrderRoutingLine;
      CalcRoutingLineForward(TRUE);

      ProdOrderRoutingLine."Starting Time" := FixedProdOrderRoutingLine."Starting Time";
      ProdOrderRoutingLine."Starting Date" := FixedProdOrderRoutingLine."Starting Date";
      ProdOrderRoutingLine."Ending Time" := FixedProdOrderRoutingLine."Ending Time";
      ProdOrderRoutingLine."Ending Date" := FixedProdOrderRoutingLine."Ending Date";
      ProdOrderRoutingLine.UpdateDatetime;
      ProdOrderRoutingLine.MODIFY;
    END;

    [External]
    PROCEDURE CalculateRoutingLine@2(VAR ProdOrderRoutingLine2@1000 : Record 5409;Direction@1001 : 'Forward,Backward';CalcStartEndDate@1002 : Boolean);
    VAR
      ProdOrderCapNeed@1003 : Record 5410;
      CostCalcMgt@1007 : Codeunit 5836;
      ExpectedOperOutput@1005 : Decimal;
      ActualOperOutput@1006 : Decimal;
      TotalQtyPerOperation@1008 : Decimal;
      TotalCapacityPerOperation@1004 : Decimal;
      IsHandled@1010 : Boolean;
    BEGIN
      MfgSetup.GET;

      ProdOrderRoutingLine := ProdOrderRoutingLine2;

      WaitTimeOnly :=
        (ProdOrderRoutingLine."Setup Time" = 0) AND (ProdOrderRoutingLine."Run Time" = 0) AND
        (ProdOrderRoutingLine."Move Time" = 0);

      IF ProdOrderRoutingLine."Ending Time" = 0T THEN
        ProdOrderRoutingLine."Ending Time" := 000000T;

      IF ProdOrderRoutingLine."Starting Time" = 0T THEN
        ProdOrderRoutingLine."Starting Time" := 000000T;

      ProdOrderRoutingLine."Expected Operation Cost Amt." := 0;
      ProdOrderRoutingLine."Expected Capacity Ovhd. Cost" := 0;
      ProdOrderRoutingLine."Expected Capacity Need" := 0;

      ProdOrderCapNeed.RESET;
      ProdOrderCapNeed.SETRANGE(Status,ProdOrderRoutingLine.Status);
      ProdOrderCapNeed.SETRANGE("Prod. Order No.",ProdOrderRoutingLine."Prod. Order No.");
      ProdOrderCapNeed.SETRANGE("Requested Only",FALSE);
      ProdOrderCapNeed.SETRANGE("Routing No.",ProdOrderRoutingLine."Routing No.");
      ProdOrderCapNeed.SETRANGE("Routing Reference No.",ProdOrderRoutingLine."Routing Reference No.");
      ProdOrderCapNeed.SETRANGE("Operation No.",ProdOrderRoutingLine."Operation No.");
      ProdOrderCapNeed.DELETEALL;

      NextCapNeedLineNo := 1;

      ProdOrderRoutingLine.TESTFIELD("Work Center No.");

      CurrentWorkCenterNo := '';
      Workcenter.GET(ProdOrderRoutingLine."Work Center No.");
      IF ProdOrderRoutingLine.Type = ProdOrderRoutingLine.Type::"Machine Center" THEN BEGIN
        MachineCenter.GET(ProdOrderRoutingLine."No.");
        Workcenter."Queue Time" := MachineCenter."Queue Time";
        Workcenter."Queue Time Unit of Meas. Code" := MachineCenter."Queue Time Unit of Meas. Code";
      END;
      IF NOT CalcStartEndDate THEN
        CLEAR(Workcenter."Queue Time");
      ProdOrder.GET(ProdOrderRoutingLine.Status,ProdOrderRoutingLine."Prod. Order No.");

      ProdOrderQty := 0;
      TotalScrap := 0;
      TotalLotSize := 0;
      ProdOrderLine.SETRANGE(Status,ProdOrderRoutingLine.Status);
      ProdOrderLine.SETRANGE("Prod. Order No.",ProdOrderRoutingLine."Prod. Order No.");
      ProdOrderLine.SETRANGE("Routing Reference No.",ProdOrderRoutingLine."Routing Reference No.");
      ProdOrderLine.SETRANGE("Routing No.",ProdOrderRoutingLine."Routing No.");
      OnCalculateRoutingLineOnAfterProdOrderLineSetFilters(ProdOrderLine,ProdOrder,ProdOrderRoutingLine);
      IF ProdOrderLine.FIND('-') THEN BEGIN
        ExpectedOperOutput := 0;
        REPEAT
          IsHandled := FALSE;
          OnCalculateRoutingLineOnBeforeCalcExpectedOperOutput(ProdOrderLine,ExpectedOperOutput,IsHandled);
          IF NOT IsHandled THEN
            ExpectedOperOutput := ExpectedOperOutput + ProdOrderLine."Quantity (Base)";
          TotalScrap := TotalScrap + ProdOrderLine."Scrap %";
        UNTIL ProdOrderLine.NEXT = 0;
        ActualOperOutput := CostCalcMgt.CalcActOutputQtyBase(ProdOrderLine,ProdOrderRoutingLine);
        ProdOrderQty := ExpectedOperOutput - ActualOperOutput;
        IF ProdOrderQty < 0 THEN
          ProdOrderQty := 0;
      END;

      MaxLotSize :=
        ProdOrderQty *
        (1 + ProdOrderRoutingLine."Scrap Factor % (Accumulated)") *
        (1 + TotalScrap / 100) +
        ProdOrderRoutingLine."Fixed Scrap Qty. (Accum.)";

      ProdOrderRoutingLine."Input Quantity" := MaxLotSize;

      IF ActualOperOutput > 0 THEN BEGIN
        TotalQtyPerOperation :=
          ExpectedOperOutput *
          (1 + ProdOrderRoutingLine."Scrap Factor % (Accumulated)") *
          (1 + TotalScrap / 100) +
          ProdOrderRoutingLine."Fixed Scrap Qty. (Accum.)";
      END ELSE
        TotalQtyPerOperation := MaxLotSize;

      OnBeforeCalcExpectedCost(ProdOrderRoutingLine,MaxLotSize,TotalQtyPerOperation,ActualOperOutput);

      TotalCapacityPerOperation :=
        ROUND(
          TotalQtyPerOperation *
          ProdOrderRoutingLine.RunTimePer *
          CalendarMgt.QtyperTimeUnitofMeasure(
            ProdOrderRoutingLine."Work Center No.",ProdOrderRoutingLine."Run Time Unit of Meas. Code"),
          UOMMgt.QtyRndPrecision);

      IF MfgSetup."Cost Incl. Setup" THEN
        CalcCostInclSetup(ProdOrderRoutingLine,TotalCapacityPerOperation);

      CalcExpectedCost(ProdOrderRoutingLine,TotalQtyPerOperation,TotalCapacityPerOperation);

      OnBeforeScheduleRoutingLine(ProdOrderRoutingLine);

      IF ProdOrderRoutingLine."Schedule Manually" THEN
        CalculateRoutingLineFixed
      ELSE BEGIN
        IF Direction = Direction::Backward THEN
          CalcRoutingLineBack(CalcStartEndDate)
        ELSE
          CalcRoutingLineForward(CalcStartEndDate);
      END;

      OnAfterCalculateRoutingLine(ProdOrderRoutingLine);

      ProdOrderRoutingLine2 := ProdOrderRoutingLine;
    END;

    LOCAL PROCEDURE FinitelyLoadCapBack@14(TimeType@1000 : 'Setup Time,Run Time';ConstrainedCapacity@1001 : Record 99000866;ResourceIsConstrained@1002 : Boolean;ParentWorkCenter@1003 : Record 99000866;ParentIsConstrained@1004 : Boolean);
    VAR
      LastProdOrderCapNeed@1005 : Record 5410;
      AvailTime@1006 : Decimal;
      ProdEndingDateTime@1007 : DateTime;
      ProdEndingDateTimeAddOneDay@1016 : DateTime;
      SetupTime@1008 : Decimal;
      TimetoProgram@1009 : Decimal;
      AvailCap@1010 : Decimal;
      DampTime@1011 : Decimal;
      xConCurrCap@1012 : Decimal;
      EndTime@1013 : Time;
      StartTime@1014 : Time;
    BEGIN
      IF (RemainNeedQty = 0) AND WaitTimeOnly THEN
        EXIT;
      EndTime := ProdEndingTime;
      ProdEndingDateTime := CREATEDATETIME(ProdEndingDate,ProdEndingTime);
      ProdEndingDateTimeAddOneDay := CREATEDATETIME(ProdEndingDate + 1,ProdEndingTime);
      ConCurrCap := ProdOrderRoutingLine."Concurrent Capacities";
      xConCurrCap := 1;

      LastProdOrderCapNeed.SetFilters(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.");

      CalendarEntry.SetCapacityFilters(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.");
      CalendarEntry.SETFILTER("Starting Date-Time",'<= %1',ProdEndingDateTime);
      CalendarEntry.SETFILTER("Ending Date-Time",'<= %1',ProdEndingDateTimeAddOneDay);
      IF CalendarEntry.FIND('+') THEN
        REPEAT
          IF (EndTime > CalendarEntry."Ending Time") OR (EndTime < CalendarEntry."Starting Time") OR
             (ProdEndingDate <> CalendarEntry.Date)
          THEN
            EndTime := CalendarEntry."Ending Time";
          StartTime := EndTime;

          IF (ConCurrCap = 0) OR (CalendarEntry.Capacity < ConCurrCap) THEN
            ConCurrCap := CalendarEntry.Capacity;
          IF TimeType <> TimeType::"Run Time" THEN
            RemainNeedQty := RemainNeedQty * ConCurrCap / xConCurrCap;
          xConCurrCap := ConCurrCap;

          CalculateDailyLoad(AvailCap,DampTime,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained);
          SetupTime := 0;
          IF TimeType = TimeType::"Run Time" THEN BEGIN
            SetupTime :=
              ROUND(
                ProdOrderRoutingLine."Setup Time" *
                CalendarMgt.TimeFactor(ProdOrderRoutingLine."Setup Time Unit of Meas. Code") /
                CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
                Workcenter."Calendar Rounding Precision");
            SetupTime := SetupTime * ConCurrCap;
          END;
          IF RemainNeedQty + SetupTime <= AvailCap + DampTime THEN
            AvailCap := AvailCap + DampTime;
          AvailCap :=
            ROUND(AvailCap *
              CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
              100 / CalendarEntry.Efficiency / ConCurrCap,1,'>');

          IF AvailCap > 0 THEN BEGIN
            ProdEndingDateTime := CREATEDATETIME(CalendarEntry.Date,EndTime);
            LastProdOrderCapNeed.SETFILTER(
              "Ending Date-Time",'>= %1 & < %2',CalendarEntry."Starting Date-Time",ProdEndingDateTimeAddOneDay);
            LastProdOrderCapNeed.SETFILTER(
              "Starting Date-Time",'>= %1 & < %2',CalendarEntry."Starting Date-Time",ProdEndingDateTime);
            IF LastProdOrderCapNeed.FIND('+') THEN
              REPEAT
                IF LastProdOrderCapNeed."Ending Time" < EndTime THEN BEGIN
                  AvailTime := Min(CalendarMgt.CalcTimeDelta(EndTime,LastProdOrderCapNeed."Ending Time"),AvailCap);
                  IF AvailTime > 0 THEN BEGIN
                    UpdateTimesBack(AvailTime,AvailCap,TimetoProgram,StartTime,EndTime);
                    CreateCapNeed(CalendarEntry.Date,StartTime,EndTime,TimetoProgram,TimeType,1);
                    IF FirstInBatch AND FirstEntry THEN BEGIN
                      FirstInBatch := FALSE;
                      FirstEntry := FALSE
                    END;
                    IF UpdateDates THEN BEGIN
                      ProdOrderRoutingLine."Ending Time" := EndTime;
                      ProdOrderRoutingLine."Ending Date" := CalendarEntry.Date;
                      UpdateDates := FALSE
                    END;
                    EndTime := StartTime;
                  END;
                END;
                IF LastProdOrderCapNeed."Starting Time" < EndTime THEN
                  EndTime := LastProdOrderCapNeed."Starting Time";
              UNTIL (LastProdOrderCapNeed.NEXT(-1) = 0) OR (RemainNeedQty = 0) OR (AvailCap = 0);

            IF (AvailCap > 0) AND (RemainNeedQty > 0) THEN BEGIN
              AvailTime := Min(CalendarMgt.CalcTimeDelta(EndTime,CalendarEntry."Starting Time"),AvailCap);
              IF AvailTime > 0 THEN BEGIN
                UpdateTimesBack(AvailTime,AvailCap,TimetoProgram,StartTime,EndTime);
                IF StartTime < CalendarEntry."Starting Time" THEN
                  StartTime := CalendarEntry."Starting Time";
                IF TimetoProgram <> 0 THEN
                  CreateCapNeed(CalendarEntry.Date,StartTime,EndTime,TimetoProgram,TimeType,1);
                IF FirstInBatch AND FirstEntry THEN BEGIN
                  FirstInBatch := FALSE;
                  FirstEntry := FALSE
                END;
                IF UpdateDates THEN BEGIN
                  ProdOrderRoutingLine."Ending Time" := EndTime;
                  ProdOrderRoutingLine."Ending Date" := CalendarEntry.Date;
                  UpdateDates := FALSE
                END;
                EndTime := StartTime;
              END;
            END;
          END;
          IF RemainNeedQty > 0 THEN BEGIN
            IF CalendarEntry.NEXT(-1) = 0 THEN BEGIN
              TestForError(Text001,Text002,CalendarEntry.Date);
              EXIT;
            END;
            EndTime := CalendarEntry."Ending Time";
          END ELSE BEGIN
            ProdEndingTime := StartTime;
            ProdEndingDate := CalendarEntry.Date;
            ProdOrderRoutingLine."Starting Time" := StartTime;
            ProdOrderRoutingLine."Starting Date" := CalendarEntry.Date;
            EXIT;
          END;
        UNTIL FALSE;
    END;

    LOCAL PROCEDURE FinitelyLoadCapForward@20(TimeType@1000 : 'Setup Time,Run Time';ConstrainedCapacity@1001 : Record 99000866;ResourceIsConstrained@1002 : Boolean;ParentWorkCenter@1003 : Record 99000866;ParentIsConstrained@1004 : Boolean);
    VAR
      NextProdOrderCapNeed@1005 : Record 5410;
      AvailTime@1006 : Decimal;
      ProdStartingDateTime@1007 : DateTime;
      ProdStartingDateTimeSubOneDay@1016 : DateTime;
      RunTime@1008 : Decimal;
      TimetoProgram@1009 : Decimal;
      AvailCap@1010 : Decimal;
      DampTime@1011 : Decimal;
      xConCurrCap@1012 : Decimal;
      EndTime@1013 : Time;
      StartTime@1014 : Time;
    BEGIN
      IF (RemainNeedQty = 0) AND WaitTimeOnly THEN
        EXIT;
      StartTime := ProdStartingTime;
      ProdStartingDateTime := CREATEDATETIME(ProdStartingDate,ProdStartingTime);
      ProdStartingDateTimeSubOneDay := CREATEDATETIME(ProdStartingDate - 1,ProdStartingTime);
      ConCurrCap := ProdOrderRoutingLine."Concurrent Capacities";
      xConCurrCap := 1;

      NextProdOrderCapNeed.SetFilters(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.");

      CalendarEntry.SetCapacityFilters(ProdOrderRoutingLine.Type,ProdOrderRoutingLine."No.");
      CalendarEntry.SETFILTER("Starting Date-Time",'>= %1',ProdStartingDateTimeSubOneDay);
      CalendarEntry.SETFILTER("Ending Date-Time",'>= %1',ProdStartingDateTime);
      IF CalendarEntry.FIND('-') THEN
        REPEAT
          IF (StartTime < CalendarEntry."Starting Time") OR (StartTime > CalendarEntry."Ending Time") OR
             (ProdStartingDate <> CalendarEntry.Date)
          THEN
            StartTime := CalendarEntry."Starting Time";
          EndTime := StartTime;

          IF (ConCurrCap = 0) OR (CalendarEntry.Capacity < ConCurrCap) THEN
            ConCurrCap := CalendarEntry.Capacity;
          IF TimeType <> TimeType::"Run Time" THEN
            RemainNeedQty := RemainNeedQty * ConCurrCap / xConCurrCap;
          xConCurrCap := ConCurrCap;

          CalculateDailyLoad(AvailCap,DampTime,ConstrainedCapacity,ResourceIsConstrained,ParentWorkCenter,ParentIsConstrained);
          RunTime := 0;
          IF TimeType = TimeType::"Setup Time" THEN BEGIN
            RunTime := LotSize * ProdOrderRoutingLine.RunTimePer;
            RunTime :=
              ROUND(RunTime *
                CalendarMgt.TimeFactor(ProdOrderRoutingLine."Run Time Unit of Meas. Code") /
                CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
                Workcenter."Calendar Rounding Precision");
          END;
          IF RemainNeedQty + RunTime <= AvailCap + DampTime THEN
            AvailCap := AvailCap + DampTime;
          AvailCap :=
            ROUND(AvailCap *
              CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
              100 / CalendarEntry.Efficiency / ConCurrCap,1,'>');

          IF AvailCap > 0 THEN BEGIN
            ProdStartingDateTime := CREATEDATETIME(CalendarEntry.Date,StartTime);
            NextProdOrderCapNeed.SETFILTER(
              "Ending Date-Time",'> %1 & <= %2',ProdStartingDateTime,CalendarEntry."Ending Date-Time");
            NextProdOrderCapNeed.SETFILTER(
              "Starting Date-Time",'> %1 & <= %2',ProdStartingDateTimeSubOneDay,CalendarEntry."Ending Date-Time");
            IF NextProdOrderCapNeed.FIND('-') THEN
              REPEAT
                IF NextProdOrderCapNeed."Starting Time" > StartTime THEN BEGIN
                  AvailTime := Min(CalendarMgt.CalcTimeDelta(NextProdOrderCapNeed."Starting Time",StartTime),AvailCap);
                  IF AvailTime > 0 THEN BEGIN
                    UpdateTimesForward(AvailTime,AvailCap,TimetoProgram,StartTime,EndTime);
                    CreateCapNeed(CalendarEntry.Date,StartTime,EndTime,TimetoProgram,TimeType,0);
                    IF FirstInBatch AND FirstEntry THEN BEGIN
                      FirstInBatch := FALSE;
                      FirstEntry := FALSE
                    END;
                    IF UpdateDates THEN BEGIN
                      ProdOrderRoutingLine."Starting Time" := StartTime;
                      ProdOrderRoutingLine."Starting Date" := CalendarEntry.Date;
                      UpdateDates := FALSE
                    END;
                    StartTime := EndTime;
                  END;
                END;
                IF NextProdOrderCapNeed."Ending Time" > StartTime THEN
                  StartTime := NextProdOrderCapNeed."Ending Time"
              UNTIL (NextProdOrderCapNeed.NEXT = 0) OR (RemainNeedQty = 0) OR (AvailCap = 0);

            IF (AvailCap > 0) AND (RemainNeedQty > 0) THEN BEGIN
              AvailTime := Min(CalendarMgt.CalcTimeDelta(CalendarEntry."Ending Time",StartTime),AvailCap);
              IF AvailTime > 0 THEN BEGIN
                UpdateTimesForward(AvailTime,AvailCap,TimetoProgram,StartTime,EndTime);
                IF EndTime > CalendarEntry."Ending Time" THEN
                  EndTime := CalendarEntry."Ending Time";
                IF TimetoProgram <> 0 THEN
                  CreateCapNeed(CalendarEntry.Date,StartTime,EndTime,TimetoProgram,TimeType,0);
                IF FirstInBatch AND FirstEntry THEN BEGIN
                  FirstInBatch := FALSE;
                  FirstEntry := FALSE
                END;
                IF UpdateDates THEN BEGIN
                  ProdOrderRoutingLine."Starting Time" := StartTime;
                  ProdOrderRoutingLine."Starting Date" := CalendarEntry.Date;
                  UpdateDates := FALSE
                END;
                StartTime := EndTime;
              END;
            END;
          END;
          IF RemainNeedQty > 0 THEN BEGIN
            IF CalendarEntry.NEXT = 0 THEN BEGIN
              TestForError(Text003,Text004,CalendarEntry.Date);
              EXIT;
            END;
            StartTime := CalendarEntry."Starting Time";
          END ELSE BEGIN
            ProdStartingTime := EndTime;
            ProdStartingDate := CalendarEntry.Date;
            ProdOrderRoutingLine."Ending Time" := EndTime;
            ProdOrderRoutingLine."Ending Date" := CalendarEntry.Date;
            EXIT;
          END;
        UNTIL FALSE;
    END;

    LOCAL PROCEDURE CalculateDailyLoad@19(VAR AvailCap@1000 : Decimal;VAR DampTime@1001 : Decimal;ConstrainedCapacity@1002 : Record 99000866;IsResourceConstrained@1003 : Boolean;ParentWorkCenter@1004 : Record 99000866;IsParentConstrained@1005 : Boolean);
    VAR
      CurrentLoadBase@1006 : Decimal;
      AvailCapWorkCenter@1007 : Decimal;
      DampTimeWorkCenter@1008 : Decimal;
      CapEffectiveBase@1014 : Decimal;
    BEGIN
      GetCurrentWorkCenterTimeFactorAndRounding(Workcenter."No.");
      IF (CalendarEntry."Capacity Type" = CalendarEntry."Capacity Type"::"Work Center") OR
         ((CalendarEntry."Capacity Type" = CalendarEntry."Capacity Type"::"Machine Center") AND
          (IsResourceConstrained XOR IsParentConstrained))
      THEN BEGIN
        WITH ConstrainedCapacity DO BEGIN
          IF IsParentConstrained THEN BEGIN
            ConstrainedCapacity := ParentWorkCenter;
            CalcCapConResWorkCenterLoadBase(ConstrainedCapacity,CalendarEntry.Date,CapEffectiveBase,CurrentLoadBase)
          END ELSE
            CalcCapConResProdOrderNeedBase(ConstrainedCapacity,CalendarEntry.Date,CapEffectiveBase,CurrentLoadBase);
          CalcAvailCapBaseAndDampTime(
            ConstrainedCapacity,AvailCap,DampTime,CapEffectiveBase,CurrentLoadBase,CurrentTimeFactor,CurrentRounding);
        END;
      END ELSE BEGIN
        CalcCapConResProdOrderNeedBase(ConstrainedCapacity,CalendarEntry.Date,CapEffectiveBase,CurrentLoadBase);
        CalcAvailCapBaseAndDampTime(
          ConstrainedCapacity,AvailCap,DampTime,CapEffectiveBase,CurrentLoadBase,CurrentTimeFactor,CurrentRounding);

        CalcCapConResWorkCenterLoadBase(ParentWorkCenter,CalendarEntry.Date,CapEffectiveBase,CurrentLoadBase);
        CalcAvailCapBaseAndDampTime(
          ParentWorkCenter,AvailCapWorkCenter,DampTimeWorkCenter,CapEffectiveBase,CurrentLoadBase,CurrentTimeFactor,CurrentRounding);

        IF AvailCap + DampTime > AvailCapWorkCenter + DampTimeWorkCenter THEN
          DampTime := DampTimeWorkCenter
        ELSE
          IF AvailCap + DampTime = AvailCapWorkCenter + DampTimeWorkCenter THEN
            DampTime := Max(DampTime,DampTimeWorkCenter);
        AvailCap := ROUND(Min(AvailCap,AvailCapWorkCenter),1);
      END;
    END;

    LOCAL PROCEDURE UpdateTimesBack@17(VAR AvailTime@1000 : Decimal;VAR AvailCap@1001 : Decimal;VAR TimetoProgram@1002 : Decimal;VAR StartTime@1003 : Time;EndTime@1004 : Time);
    VAR
      RoundedTimetoProgram@1005 : Decimal;
    BEGIN
      AvailTime :=
        ROUND(AvailTime / CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
          CalendarEntry.Efficiency / 100 * ConCurrCap,Workcenter."Calendar Rounding Precision");
      TimetoProgram := Min(RemainNeedQty,AvailTime);
      RoundedTimetoProgram :=
        ROUND(TimetoProgram *
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
          100 / CalendarEntry.Efficiency / ConCurrCap,1,'>');
      StartTime := CalendarMgt.CalcTimeSubtract(EndTime,RoundedTimetoProgram);
      RemainNeedQty := RemainNeedQty - TimetoProgram;
      IF ProdOrderRoutingLine.Status <> ProdOrderRoutingLine.Status::Simulated THEN
        AvailCap := AvailCap - RoundedTimetoProgram;
    END;

    LOCAL PROCEDURE UpdateTimesForward@21(VAR AvailTime@1000 : Decimal;VAR AvailCap@1001 : Decimal;VAR TimetoProgram@1002 : Decimal;StartTime@1003 : Time;VAR EndTime@1004 : Time);
    VAR
      RoundedTimetoProgram@1005 : Decimal;
    BEGIN
      AvailTime :=
        ROUND(AvailTime / CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
          CalendarEntry.Efficiency / 100 * ConCurrCap,Workcenter."Calendar Rounding Precision");
      TimetoProgram := Min(RemainNeedQty,AvailTime);
      RoundedTimetoProgram :=
        ROUND(TimetoProgram *
          CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code") *
          100 / CalendarEntry.Efficiency / ConCurrCap,1,'>');
      EndTime := StartTime + RoundedTimetoProgram;
      RemainNeedQty := RemainNeedQty - TimetoProgram;
      IF ProdOrderRoutingLine.Status <> ProdOrderRoutingLine.Status::Simulated THEN
        AvailCap := AvailCap - RoundedTimetoProgram;
    END;

    LOCAL PROCEDURE Min@18(Number1@1000 : Decimal;Number2@1001 : Decimal) : Decimal;
    BEGIN
      IF Number1 <= Number2 THEN
        EXIT(Number1);

      EXIT(Number2);
    END;

    LOCAL PROCEDURE Max@10(Number1@1000 : Decimal;Number2@1001 : Decimal) : Decimal;
    BEGIN
      IF Number1 >= Number2 THEN
        EXIT(Number1);

      EXIT(Number2);
    END;

    LOCAL PROCEDURE CalcExpectedCost@22(VAR ProdOrderRoutingLine@1000 : Record 5409;TotalQtyPerOperation@1002 : Decimal;TotalCapacityPerOperation@1001 : Decimal);
    BEGIN
      IF ProdOrderRoutingLine."Unit Cost Calculation" = ProdOrderRoutingLine."Unit Cost Calculation"::Time THEN BEGIN
        ProdOrderRoutingLine."Expected Operation Cost Amt." :=
          TotalCapacityPerOperation * ProdOrderRoutingLine."Unit Cost per";
        ProdOrderRoutingLine."Expected Capacity Ovhd. Cost" :=
          TotalCapacityPerOperation *
          (ProdOrderRoutingLine."Direct Unit Cost" *
           ProdOrderRoutingLine."Indirect Cost %" / 100 + ProdOrderRoutingLine."Overhead Rate");
      END ELSE BEGIN
        ProdOrderRoutingLine."Expected Operation Cost Amt." :=
          TotalQtyPerOperation * ProdOrderRoutingLine."Unit Cost per";
        ProdOrderRoutingLine."Expected Capacity Ovhd. Cost" :=
          TotalQtyPerOperation *
          (ProdOrderRoutingLine."Direct Unit Cost" *
           ProdOrderRoutingLine."Indirect Cost %" / 100 + ProdOrderRoutingLine."Overhead Rate");
      END;
    END;

    LOCAL PROCEDURE CalcCostInclSetup@39(ProdOrderRoutingLine@1000 : Record 5409;VAR TotalCapacityPerOperation@1001 : Decimal);
    VAR
      ConcurrentCapacity@1002 : Decimal;
    BEGIN
      OnBeforeCalcCostInclSetup(ProdOrderRoutingLine,TotalCapacityPerOperation);

      ConcurrentCapacity := ProdOrderRoutingLine."Concurrent Capacities";
      IF ConcurrentCapacity = 0 THEN
        ConcurrentCapacity := 1;
      TotalCapacityPerOperation :=
        TotalCapacityPerOperation +
        ROUND(
          ConcurrentCapacity * ProdOrderRoutingLine."Setup Time" *
          CalendarMgt.QtyperTimeUnitofMeasure(
            ProdOrderRoutingLine."Work Center No.",ProdOrderRoutingLine."Setup Time Unit of Meas. Code"),
          UOMMgt.QtyRndPrecision);

      OnAfterCalcCostInclSetup(ProdOrderRoutingLine,TotalCapacityPerOperation);
    END;

    LOCAL PROCEDURE CalcDuration@24(DateTime1@1001 : DateTime;DateTime2@1000 : DateTime) TotalDuration : Decimal;
    BEGIN
      TotalDuration :=
        ROUND(
          (DT2DATE(DateTime2) - DT2DATE(DateTime1)) * (86400000 / CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code")) +
          (DT2TIME(DateTime2) - DT2TIME(DateTime1)) / CalendarMgt.TimeFactor(Workcenter."Unit of Measure Code"),
          Workcenter."Calendar Rounding Precision");
      EXIT(TotalDuration);
    END;

    LOCAL PROCEDURE FindSendAheadEndingTime@23(VAR TmpProdOrderRtngLine@1000 : Record 5409;VAR SendAheadLotSize@1002 : Decimal) : Boolean;
    VAR
      Result@1003 : Boolean;
      xTotalLotSize@1004 : Decimal;
      xSendAheadLotSize@1005 : Decimal;
    BEGIN
      xTotalLotSize := TotalLotSize;
      xSendAheadLotSize := SendAheadLotSize;
      IF TmpProdOrderRtngLine.FINDSET THEN BEGIN
        REPEAT
          TotalLotSize := xTotalLotSize;
          SendAheadLotSize := xSendAheadLotSize;

          Result := Result OR GetSendAheadEndingTime(TmpProdOrderRtngLine,SendAheadLotSize);
        UNTIL TmpProdOrderRtngLine.NEXT = 0;
      END ELSE
        Result := GetSendAheadEndingTime(TmpProdOrderRtngLine,SendAheadLotSize);

      EXIT(Result);
    END;

    LOCAL PROCEDURE FindSendAheadStartingTime@25(VAR TmpProdOrderRtngLine@1000 : Record 5409;VAR SendAheadLotSize@1002 : Decimal) : Boolean;
    VAR
      Result@1003 : Boolean;
      xTotalLotSize@1004 : Decimal;
      xSendAheadLotSize@1005 : Decimal;
    BEGIN
      xTotalLotSize := TotalLotSize;
      xSendAheadLotSize := SendAheadLotSize;
      IF TmpProdOrderRtngLine.FINDSET THEN BEGIN
        REPEAT
          TotalLotSize := xTotalLotSize;
          SendAheadLotSize := xSendAheadLotSize;

          Result := Result OR GetSendAheadStartingTime(TmpProdOrderRtngLine,SendAheadLotSize);
        UNTIL TmpProdOrderRtngLine.NEXT = 0;
      END ELSE
        Result := GetSendAheadStartingTime(TmpProdOrderRtngLine,SendAheadLotSize);

      EXIT(Result);
    END;

    [External]
    PROCEDURE ReturnNextCalendarEntry@26(VAR CalendarEntry2@1000 : Record 99000757;OldCalendarEntry@1001 : Record 99000757;Direction@1002 : 'Backward,Forward');
    BEGIN
      CalendarEntry2 := OldCalendarEntry;
      CalendarEntry2.SETRANGE(Date,CalendarEntry2.Date);

      IF Direction = Direction::Backward THEN BEGIN
        CalendarEntry2.FIND('-');           // rewind within the same day
        CalendarEntry2.SETRANGE(Date);
        IF CalendarEntry2.NEXT(-1) = 0 THEN
          TestForError(Text001,Text002,CalendarEntry2.Date);

        IF (CalendarEntry2.Date + 1) < OldCalendarEntry.Date THEN BEGIN
          CalendarEntry2.Date := OldCalendarEntry.Date - 1;
          CreateCalendarEntry(CalendarEntry2);
        END;
      END ELSE BEGIN
        CalendarEntry2.FIND('+');            // rewind within the same day
        CalendarEntry2.SETRANGE(Date);
        IF CalendarEntry2.NEXT = 0 THEN
          TestForError(Text003,Text004,CalendarEntry2.Date);

        IF OldCalendarEntry.Date < (CalendarEntry2.Date - 1) THEN BEGIN
          CalendarEntry2.Date := OldCalendarEntry.Date + 1;
          CreateCalendarEntry(CalendarEntry2);
        END;
      END;
    END;

    LOCAL PROCEDURE CreateCalendarEntry@27(VAR CalendarEntry2@1000 : Record 99000757);
    BEGIN
      WITH CalendarEntry2 DO BEGIN
        "Ending Time" := 000000T;
        "Starting Time" := 000000T;
        Efficiency := 100;
        "Absence Capacity" := 0;
        "Capacity (Total)" := 0;
        "Capacity (Effective)" := "Capacity (Total)";
        "Starting Date-Time" := CREATEDATETIME(Date,"Starting Time");
        "Ending Date-Time" := "Starting Date-Time" + 86400000;
        IF NOT GET("Capacity Type","No.",Date,"Starting Time","Ending Time","Work Shift Code") THEN
          INSERT;
      END;
    END;

    LOCAL PROCEDURE GetCurrentWorkCenterTimeFactorAndRounding@29(WorkCenterNo@1000 : Code[20]);
    VAR
      WorkCenter@1001 : Record 99000754;
    BEGIN
      IF CurrentWorkCenterNo = WorkCenterNo THEN
        EXIT;

      WorkCenter.GET(WorkCenterNo);
      CurrentTimeFactor := CalendarMgt.TimeFactor(WorkCenter."Unit of Measure Code");
      CurrentRounding := WorkCenter."Calendar Rounding Precision";
    END;

    LOCAL PROCEDURE CalcCapConResWorkCenterLoadBase@34(CapacityConstrainedResource@1000 : Record 99000866;DateFilter@1001 : Date;VAR CapEffectiveBase@1003 : Decimal;VAR LoadBase@1002 : Decimal);
    BEGIN
      CapEffectiveBase := 0;
      LoadBase := 0;

      WITH CapacityConstrainedResource DO BEGIN
        SETRANGE("Date Filter",DateFilter);
        CALCFIELDS("Capacity (Effective)","Work Center Load Qty.");
        IF "Capacity (Effective)" <> 0 THEN BEGIN
          CapEffectiveBase := ROUND("Capacity (Effective)" * CurrentTimeFactor,CurrentRounding);
          LoadBase := ROUND("Work Center Load Qty." * CurrentTimeFactor,CurrentRounding);
        END;
      END;
    END;

    LOCAL PROCEDURE CalcCapConResProdOrderNeedBase@37(CapacityConstrainedResource@1000 : Record 99000866;DateFilter@1001 : Date;VAR CapEffectiveBase@1003 : Decimal;VAR LoadBase@1002 : Decimal);
    BEGIN
      CapEffectiveBase := 0;
      LoadBase := 0;

      WITH CapacityConstrainedResource DO BEGIN
        SETRANGE("Date Filter",DateFilter);
        CALCFIELDS("Capacity (Effective)","Prod. Order Need Qty.");
        IF "Capacity (Effective)" <> 0 THEN BEGIN
          CapEffectiveBase := ROUND("Capacity (Effective)" * CurrentTimeFactor,CurrentRounding);
          LoadBase := ROUND("Prod. Order Need Qty." * CurrentTimeFactor,CurrentRounding);
        END;
      END;
    END;

    [External]
    PROCEDURE CalcAvailCapBaseAndDampTime@47(CapacityConstrainedResource@1010 : Record 99000866;VAR AvailCap@1000 : Decimal;VAR DampTime@1001 : Decimal;CapEffectiveBase@1002 : Decimal;LoadBase@1004 : Decimal;TimeFactor@1011 : Decimal;Rounding@1009 : Decimal);
    VAR
      AvailCapBase@1008 : Decimal;
      AvailCapBaseMax@1006 : Decimal;
      LoadPct@1007 : Decimal;
      DampenerPct@1003 : Decimal;
      CriticalLoadPct@1005 : Decimal;
    BEGIN
      AvailCap := 0;
      DampTime := 0;

      IF CapEffectiveBase = 0 THEN
        EXIT;

      CriticalLoadPct := CapacityConstrainedResource."Critical Load %";
      AvailCapBaseMax := ROUND(CapEffectiveBase * CriticalLoadPct / 100,Rounding);
      AvailCapBase := Max(0,AvailCapBaseMax - LoadBase);
      AvailCap := ROUND(AvailCapBase / TimeFactor,Rounding);

      LoadPct := ROUND(LoadBase / CapEffectiveBase * 100,Rounding);
      DampenerPct := CapacityConstrainedResource."Dampener (% of Total Capacity)";
      DampTime :=
        ROUND(CapEffectiveBase / TimeFactor * Min(DampenerPct,CriticalLoadPct + DampenerPct - LoadPct) / 100,Rounding);
      DampTime := ROUND(Max(0,DampTime),1);
    END;

    [External]
    PROCEDURE CalcAvailQtyBase@30(VAR CalendarEntry@1016 : Record 99000757;ProdStartDate@1003 : Date;ProdStartTime@1002 : Time;TimeType@1005 : 'Setup Time,Run Time,Wait Time,Move Time,Queue Time';ConCurrCap@1007 : Decimal;IsForward@1004 : Boolean;TimeFactor@1011 : Decimal;Rounding@1008 : Decimal) AvQtyBase : Decimal;
    VAR
      CalendarStartTime@1001 : Time;
      CalendarEndTime@1000 : Time;
      CalcFactor@1015 : Integer;
      ModifyCalendar@1006 : Boolean;
    BEGIN
      IF IsForward THEN BEGIN
        CalendarStartTime := CalendarEntry."Starting Time";
        CalendarEndTime := CalendarEntry."Ending Time";
        CalcFactor := -1
      END ELSE BEGIN
        CalendarStartTime := CalendarEntry."Ending Time";
        CalendarEndTime := CalendarEntry."Starting Time";
        CalcFactor := 1;
      END;
      ModifyCalendar := FALSE;

      IF (((CalendarStartTime < ProdStartTime) AND IsForward) OR
          ((CalendarStartTime > ProdStartTime) AND NOT IsForward)) AND
         (CalendarEntry.Date = ProdStartDate)
      THEN BEGIN
        CASE TimeType OF
          TimeType::"Setup Time",
          TimeType::"Run Time":
            AvQtyBase :=
              ROUND(
                ABS(CalendarEndTime - ProdStartTime) *
                CalendarEntry.Efficiency / 100 * ConCurrCap,Rounding);
          TimeType::"Move Time",
          TimeType::"Queue Time":
            AvQtyBase :=
              ROUND(
                ABS(CalendarEndTime - ProdStartTime) *
                ConCurrCap,Rounding);
          TimeType::"Wait Time":
            BEGIN
              AvQtyBase := CalcAvailQtyBaseForWaitTime(ProdStartTime,ProdStartDate,CalendarEntry.Date,CalcFactor,IsForward);
              AvQtyBase := ROUND(AvQtyBase * ConCurrCap,Rounding);
            END;
        END;
        ModifyCalendar := TRUE;
      END ELSE
        IF (CalendarEntry.Capacity = CalendarEntry."Absence Capacity") AND
           (TimeType <> TimeType::"Wait Time")
        THEN
          AvQtyBase := 0
        ELSE
          CASE TimeType OF
            TimeType::"Setup Time",
            TimeType::"Run Time":
              AvQtyBase :=
                ROUND(
                  TimeFactor * CalendarEntry."Capacity (Effective)" /
                  (CalendarEntry.Capacity - CalendarEntry."Absence Capacity") * ConCurrCap,
                  Rounding);
            TimeType::"Move Time",
            TimeType::"Queue Time":
              AvQtyBase :=
                ROUND(
                  TimeFactor * CalendarEntry."Capacity (Total)" /
                  (CalendarEntry.Capacity - CalendarEntry."Absence Capacity") * ConCurrCap,
                  Rounding);
            TimeType::"Wait Time":
              BEGIN
                AvQtyBase := CalcAvailQtyBaseForWaitTime(ProdStartTime,ProdStartDate,CalendarEntry.Date,CalcFactor,IsForward);
                AvQtyBase := ROUND(AvQtyBase * ConCurrCap,Rounding);
                ModifyCalendar := TRUE;
              END;
          END;

      IF ModifyCalendar THEN
        IF IsForward THEN
          CalendarEntry."Starting Time" := ProdStartTime
        ELSE
          CalendarEntry."Ending Time" := ProdStartTime;
    END;

    LOCAL PROCEDURE CalcAvailQtyBaseForWaitTime@28(ProdStartTime@1000 : Time;ProdStartDate@1001 : Date;CalendarEntryDate@1003 : Date;CalcFactor@1004 : Integer;IsForward@1002 : Boolean) : Decimal;
    BEGIN
      IF (ProdStartTime = 000000T) AND ((CalendarEntryDate <> ProdStartDate) OR IsForward) THEN
        EXIT(86400000);
      EXIT((86400000 + (ProdStartTime - 000000T) * CalcFactor) MOD 86400000);
    END;

    LOCAL PROCEDURE SetMaxDateTime@40(VAR ResultingDate@1000 : Date;VAR ResultingTime@1001 : Time;DateToCompare@1002 : Date;TimeToCompare@1003 : Time);
    BEGIN
      IF ((ResultingDate = DateToCompare) AND (ResultingTime >= TimeToCompare)) OR
         (ResultingDate > DateToCompare)
      THEN
        EXIT;
      ResultingDate := DateToCompare;
      ResultingTime := TimeToCompare;
    END;

    LOCAL PROCEDURE SetMinDateTime@43(VAR ResultingDate@1000 : Date;VAR ResultingTime@1001 : Time;DateToCompare@1002 : Date;TimeToCompare@1003 : Time);
    BEGIN
      IF ((ResultingDate = DateToCompare) AND (ResultingTime <= TimeToCompare)) OR
         (ResultingDate < DateToCompare)
      THEN
        EXIT;
      ResultingDate := DateToCompare;
      ResultingTime := TimeToCompare
    END;

    LOCAL PROCEDURE SetRoutingLineFilters@31(ProdOrderRoutingLine@1000 : Record 5409;VAR ProdOrderRoutingLine2@1001 : Record 5409);
    BEGIN
      WITH ProdOrderRoutingLine2 DO BEGIN
        SETRANGE(Status,ProdOrderRoutingLine.Status);
        SETRANGE("Prod. Order No.",ProdOrderRoutingLine."Prod. Order No.");
        SETRANGE("Routing Reference No.",ProdOrderRoutingLine."Routing Reference No.");
        SETRANGE("Routing No.",ProdOrderRoutingLine."Routing No.");
        SETFILTER("Routing Status",'<>%1',"Routing Status"::Finished);
      END;
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterCalcCostInclSetup@42(ProdOrderRoutingLine@1000 : Record 5409;VAR TotalCapacityPerOperation@1001 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnAfterCalculateRoutingLine@32(VAR ProdOrderRoutingLine@1000 : Record 5409);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeCalcCostInclSetup@41(ProdOrderRoutingLine@1000 : Record 5409;VAR TotalCapacityPerOperation@1001 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeCalcExpectedCost@36(VAR ProdOrderRoutingLine@1000 : Record 5409;VAR MaxLotSize@1001 : Decimal;VAR TotalQtyPerOperation@1002 : Decimal;VAR ActualOperOutput@1003 : Decimal);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnBeforeScheduleRoutingLine@33(VAR ProdOrderRoutingLine@1000 : Record 5409);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnCalculateRoutingLineOnAfterProdOrderLineSetFilters@35(VAR ProdOrderLine@1000 : Record 5406;ProductionOrder@1001 : Record 5405;ProdOrderRoutingLine@1002 : Record 5409);
    BEGIN
    END;

    [Integration]
    LOCAL PROCEDURE OnCalculateRoutingLineOnBeforeCalcExpectedOperOutput@38(VAR ProdOrderLine@1000 : Record 5406;VAR ExpectedOperOutput@1001 : Decimal;VAR IsHandled@1002 : Boolean);
    BEGIN
    END;

    BEGIN
    END.
  }
}

