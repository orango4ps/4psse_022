OBJECT Report 11128530 Remittance - export (bank)
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVNO10.00 (15000050),4PSSE.NO;
  }
  PROPERTIES
  {
    Permissions=TableData 25=rimd;
    CaptionML=[ENU=Remittance - export (bank);
               NOR=Remittering - les ut (bank)];
    ProcessingOnly=Yes;
    OnPreReport=BEGIN
                  FindSetup.GET;
                  FindSetup.TESTFIELD("LCY Code");
                END;

  }
  DATASET
  {
    { 111280000;;DataItem;                   ;
               DataItemTable=Table11128091;
               OnPreDataItem=BEGIN
                               JournalRecExt.RESET;
                               JournalRecExt.SETRANGE("Journal Template Name",CurrentJournalLine."Journal Template Name");
                               JournalRecExt.SETRANGE("Journal Batch Name",CurrentJournalLine."Journal Batch Name");
                               JournalRecExt.SETRANGE("Remittance Agreement Code",RemAgreementCode); // Only one contract at the time is processed.

                               IF NOT JournalRecExt.FINDFIRST THEN
                                 ERROR(Text001);
                             END;
                              }

    { 7024;1   ;DataItem;                    ;
               DataItemTable=Table81;
               DataItemTableView=SORTING(Journal Template Name,Journal Batch Name,Line No.);
               MaxIteration=1;
               OnPreDataItem=VAR
                               StoreJournalRec@1081000 : Record 81;
                               RemPmtOrderExport@1080000 : Report 11128532;
                               RemittJournalCheckLine@1080001 : Codeunit 11128514;
                               InvoiceCounter@1081002 : Integer;
                               MaxPayments@1081004 : Integer;
                               Done@1081005 : Boolean;
                               NextSelection@1081006 : Boolean;
                               LastLine@1081007 : Boolean;
                               NumberOfInvoices@1081008 : Integer;
                               VendBalance@1081009 : Decimal;
                               FirstTransaction@1081010 : Boolean;
                               UnstructuredPaym@1081016 : Boolean;
                               CountUnstPaym@1081017 : Integer;
                               StoreJournalRecExt@111280000 : Record 11128091;
                             BEGIN
                               RemAgreement.LOCKTABLE; // To ensure the update of sequence numbers

                               PurchSetup.GET;

                               DateNow := TODAY; // Present time and date.
                               TimeNow := TIME;
                               ProductionDate := FORMAT(DATE2DMY(DateNow,2),2) + FORMAT(DATE2DMY(DateNow,1),2);
                               ProductionDate := CONVERTSTR(ProductionDate,' ','0');  // Change, for ex., date '12 1' to '1201'.
                               TransactionDate := ProductionDate;
                               NextLineNo(TRUE);
                               VendBalance := 0; // Make sure vendors' balance is non-negative
                               NextSelection := TRUE;  // See the explanation...
                               MaxPayments := 999; // Max. number of payments in a transaction
                               RemAgreement.GET(RemAgreementCode); // Make sure the specified code is valid

                               // Select lines from current journals
                               JournalRec.RESET; // Make sure primary keys are active and all filters deleted.
                               JournalRec.SETCURRENTKEY(
                                 //"Journal Template Name","Journal Batch Name","Remittance Agreement Code","Remittance Type","Remittance Account Code");
                                 "Journal Template Name","Journal Batch Name");
                               JournalRec.SETRANGE("Journal Template Name",CurrentJournalLine."Journal Template Name");
                               JournalRec.SETRANGE("Journal Batch Name",CurrentJournalLine."Journal Batch Name");
                               // JournalRec.SETRANGE("Remittance Agreement Code",RemAgreementCode); // Only one contract at the time is processed.
                               JournalRec.SETRANGE("Line No.","Gen. Journal Line Extension"."Line No.");

                               IF NOT JournalRec.FINDFIRST THEN
                                 ERROR(Text001);

                               JournalRec.FINDFIRST;
                               JournalRecExt.InitGetLine(JournalRec);

                               CreatePaymOrderHead;

                               // Run through the lines:
                               // 1. Start with the first one. Set the filter so that all related lines are selected.
                               // 2. Each journal line is deleted after being processed.
                               // 3. If there are more then 14 lines, run through more then once.
                               // 4. When lines within the filter er processed, the filter is deleted and first of the
                               //    remaining journal lines is selected and used now. (starts over at 1.)
                               // 5. Stop when all the lines are processed.

                               JournalRec.FINDFIRST;  // Start with the first one, with new key
                               JournalRecExt.InitGetLine(JournalRec);
                               StoreJournalRec.INIT;
                               StoreJournalRecExt.INIT;
                               StoreJournalRecExt."Remittance Type" := -1; // A temporary problem, since the type has to be specified and validated eventually.
                               FirstTransaction := TRUE;
                               REPEAT
                                 IF NextSelection THEN BEGIN  // Continue with next selection:
                                   // Select journal lines for current payment transaction
                                   JournalRecExt.SETRANGE("Remittance Type",JournalRecExt."Remittance Type");
                                   JournalRecExt.SETRANGE("Remittance Account Code",JournalRecExt."Remittance Account Code");
                                   JournalRec.SETRANGE("Posting Date",JournalRec."Posting Date");
                                   JournalRec.SETRANGE("Account No.",JournalRec."Account No.");
                                   JournalRecExt.SETRANGE(Urgent,JournalRecExt.Urgent);
                                   JournalRecExt.SETRANGE("Futures Contract No.",JournalRecExt."Futures Contract No.");
                                   JournalRecExt.SETRANGE("Futures Contract Exch. Rate",JournalRecExt."Futures Contract Exch. Rate");
                                   JournalRec.SETRANGE("Currency Code",JournalRec."Currency Code");
                                   JournalRec.SETRANGE("Currency Factor",JournalRec."Currency Factor");
                                   JournalRecExt.SETRANGE("Agreed Exch. Rate",JournalRecExt."Agreed Exch. Rate");
                                   JournalRecExt.SETRANGE("Agreed With",JournalRecExt."Agreed With");
                                   UnstructuredPaym := FALSE;

                                   // Unstructured and structured payments must be grouped separately.
                                   // Structured payments: those with either KID or External Doc. No. filled out
                                   // Unstructured payments: those with recipient ref. 1-3 filled out
                                   JournalRecExt.InitGetLine(JournalRec);
                                   IF NOT JournalRecExt."Structured Payment" THEN
                                     IF JournalRecExt."Remittance Type" = JournalRecExt."Remittance Type"::Domestic THEN BEGIN
                                       IF JournalRecExt."Recipient Ref. 1" = '' THEN
                                         ERROR(Text006,JournalRec."Line No.");
                                     END ELSE BEGIN
                                       IF JournalRecExt."Recipient Ref. Abroad" = '' THEN
                                         ERROR(Text009,JournalRec."Line No.");
                                     END
                                   ELSE
                                     //UnstructuredPaym := TRUE;
                                     UnstructuredPaym := FALSE;
                                   JournalRecExt.SETRANGE("Structured Payment",JournalRecExt."Structured Payment");

                                   JournalRec.FINDFIRST;  // Start with first one among selected ones.
                                   JournalRecExt.SETRANGE("Journal Template Name",JournalRec."Journal Template Name");
                                   JournalRecExt.SETRANGE("Journal Batch Name",JournalRec."Journal Batch Name");
                                   JournalRecExt.SETRANGE("Line No.",JournalRec."Line No.");
                                   JournalRecExt.FINDFIRST;

                                   // Init data related to the current account/agreement.
                                   // All journal lines selected by now are related to the same account
                                   StoreRemAccount := RemAccount; // StoreRemAccount is used in ApplHeader.
                                   RemAccount.GET(JournalRecExt."Remittance Account Code");
                                   IF FirstTransaction THEN
                                     StoreRemAccount := RemAccount;
                                   // Check. This should not happen:
                                   IF RemAccount."Remittance Agreement Code" <> RemAgreement.Code THEN
                                     ERROR(Text002);
                                   IF RemAccount.Type = RemAccount.Type::Foreign THEN
                                     IF (JournalRecExt."Payment Type Code Abroad" = '') AND NOT SkipPaymentTypeCodeAbroad THEN
                                       SkipPaymentTypeCodeAbroad := ConfirmSkipping(JournalRecExt.FIELDCAPTION("Payment Type Code Abroad"));
                                   RemAccount.TESTFIELD("Bank Account No.");
                                   IF RemAccount.Type = 2 THEN
                                     OwnAccountNo := '00000000000'
                                   ELSE
                                     OwnAccountNo := RemTools.FormatNumStr(RemAccount."Bank Account No.",11);
                                   NumberOfInvoices := JournalRec.COUNT;  // Number of invoices in transaction
                                   InvoiceCounter := 0; // Counts number of payments in a payment transaction
                                   CountUnstPaym := 0; // Counts number of unstructured payments in a payment transaction - max allowed 8

                                   // Check if remittance type is changed. If so, create a new PAYFOR99
                                   // for previous payment orders (if any) and a new
                                   // PAYFOR00 for following payment orders.
                                   IF StoreJournalRecExt."Remittance Type" <> JournalRecExt."Remittance Type" THEN BEGIN
                                     IF NOT FirstTransaction THEN BEGIN // Close the last one
                                       CountTrans := CountTrans + 1;  // Count payment transactions
                                       Betfor99(FALSE);
                                     END;

                                     // PAYFOR00 for first/next transaction
                                     StoreRemAccount := RemAccount;
                                     CountTrans := 1;  // Count payment transactions
                                     Betfor00;
                                     FirstTransaction := FALSE;
                                   END;
                                 END;

                                 JournalRec.TESTFIELD("Account Type",JournalRec."Account Type"::Vendor);
                                 JournalRecExt.TESTFIELD("Waiting Journal Reference",0); // Journal line is a settlement. It can not be exported!
                                 Vendor.GET(JournalRec."Account No.");

                                 IF RemAccount.Type = RemAccount.Type::Domestic THEN BEGIN
                                   CountTrans := CountTrans + 1;
                                   Betfor21(JournalRec)
                                 END ELSE BEGIN
                                   CountTrans := CountTrans + 3;
                                   // Get journal info for the first journal line in vendor transaction
                                   // Same values are used for transfer.
                                   // This can cause problems, since the following journal lines could have different values.
                                   Betfor01(JournalRec);
                                   Betfor02(JournalRec);
                                   Betfor03(JournalRec);
                                 END;

                                 REPEAT
                                   IF RemAccount.Type = RemAccount.Type::Foreign THEN
                                     IF (JournalRecExt."Specification (Norges Bank)" = '') AND (PurchSetup."Amt. Spec limit to Norges Bank" > 0) THEN BEGIN
                                       IF JournalRec."Amount (LCY)" >= PurchSetup."Amt. Spec limit to Norges Bank" THEN
                                         ERROR(
                                           STRSUBSTNO(Text008,JournalRecExt.FIELDCAPTION("Specification (Norges Bank)"),FIELDCAPTION("Amount (LCY)"),
                                             FORMAT(JournalRec."Line No."),PurchSetup."Amt. Spec limit to Norges Bank"));
                                       IF NOT SkipSpecification THEN
                                         SkipSpecification := ConfirmSkipping(JournalRecExt.FIELDCAPTION("Specification (Norges Bank)"));
                                     END;

                                   InvoiceCounter := InvoiceCounter + 1;  // Count number of invoices for current vendor.

                                   //Count unstructured payments. Max allowed lines for unstructered paym. is 25
                                   // Each message consist of 3 lines (recipient ref 1,2,3), so max allowed unstruct. payments in one trans.
                                   // is 8.
                                   IF UnstructuredPaym THEN
                                     CountUnstPaym := CountUnstPaym + 1;

                                   RemittJournalCheckLine.CheckUntilFirstError(JournalRec,RemAccount);
                                   VendBalance := VendBalance + JournalRec."Amount (LCY)";  // Count vendors balance for later checks
                                   // Moved to waiting journal by PAYFor23(), since own ref. is used
                                   MoveToWaitingJournal(JournalRec);  // Move journal line to waiting journal.

                                   CountTrans := CountTrans + 1;
                                   IF RemAccount.Type = RemAccount.Type::Domestic THEN
                                     Betfor23(JournalRec)
                                   ELSE
                                     Betfor04(JournalRec);

                                   RemTools.MarkEntry(JournalRec,'REM',PaymOrder.ID);  // Mark the posts waiting for remitt. settlement.

                                   // Delete journal lines that where just processed:
                                   StoreJournalRec := JournalRec;
                                   StoreJournalRecExt := JournalRecExt;
                                   JournalRec.DELETE(TRUE);

                                   // Find first of the remaining lines in filter. -
                                   // - Stop when all vendor lines are exported, or when 999 lines are exported, for structured payments.
                                   // In case of unstrucutred payments, max no. of payments within transaction is 8.
                                   LastLine := NOT JournalRec.FINDFIRST;
                                   JournalRecExt.InitGetLine(JournalRec);
                                 UNTIL (InvoiceCounter MOD MaxPayments = 0) OR LastLine OR (UnstructuredPaym AND ((CountUnstPaym MOD 8) = 0));

                                 // Are all the selected invoices processed?
                                 // If so, the next invoice is selected.
                                 // If they are not all processed, then the vendor has more then 14 invoices. Repeat-lopp again -
                                 // - until all vendors invoices are exported
                                 IF InvoiceCounter = NumberOfInvoices THEN BEGIN
                                   // New transaction. Checking amount:
                                   // Check balance for processed vendors:
                                   IF VendBalance < 0 THEN BEGIN
                                     // recognize vendor with and without currency, so the message is formulated correctly
                                     IF JournalRec."Currency Code" = '' THEN
                                       ERROR(Text003,
                                         JournalRec."Posting Date",JournalRec."Account No.",VendBalance);
                                     ERROR(Text004,JournalRec."Posting Date",JournalRec."Account No.",
                                       VendBalance,JournalRec."Currency Code",JournalRec."Currency Factor");
                                   END;
                                   VendBalance := 0;  // Reset for next vendor.
                                 END;
                                 IF InvoiceCounter = NumberOfInvoices THEN BEGIN
                                   // All selected invoices are processed. Continue with the following selection.
                                   // Delete limits for vendor.
                                   // Continue with the line following the ones just processed:
                                   JournalRecExt.SETRANGE("Remittance Type");
                                   JournalRecExt.SETRANGE("Remittance Account Code");
                                   JournalRec.SETRANGE("Posting Date");
                                   JournalRec.SETRANGE("Account No.");
                                   JournalRecExt.SETRANGE(Urgent);
                                   JournalRecExt.SETRANGE("Futures Contract No.");
                                   JournalRecExt.SETRANGE("Futures Contract Exch. Rate");
                                   JournalRec.SETRANGE("Currency Code");
                                   JournalRec.SETRANGE("Currency Factor");
                                   JournalRecExt.SETRANGE("Agreed Exch. Rate");
                                   JournalRecExt.SETRANGE("Agreed With");
                                   JournalRecExt.SETRANGE(KID);
                                   JournalRec.SETRANGE("External Document No.");
                                   JournalRecExt.SETRANGE("Recipient Ref. 1");
                                   JournalRecExt.SETRANGE("Structured Payment");
                                   Done := NOT JournalRec.FINDFIRST;  // More journal lines?
                                   JournalRecExt.InitGetLine(JournalRec);
                                   NextSelection := TRUE;  // All selected lines are processed. Select next transaction.
                                 END ELSE BEGIN  // Not all invoices are processed.
                                   Done := FALSE;  // Don't stop. Continue with the next one from the selection.
                                   NextSelection := FALSE;  // Not all selected lines are processed. The next transaction is NOT selected.
                                 END;
                               UNTIL Done;  // If stop=True, all invoices are processed.

                               CountTrans := CountTrans + 1;
                               Betfor99(TRUE);

                               IF RemAgreement."Return File Is Not In Use" THEN
                                 RemTools.SettlePaymOrdWithoutReturnFile(PaymOrder,JournalRec);

                               // Export  data:
                               RemPmtOrderExport.SetPmtOrder(PaymOrder);
                               RemPmtOrderExport.SetFilename(CurrentFilename);
                               LineRec.RESET;
                               LineRec.SETRANGE("Payment Order No.",PaymOrder.ID);
                               RemPmtOrderExport.SETTABLEVIEW(LineRec);
                               RemPmtOrderExport.RUNMODAL;
                             END;

               DataItemLink=Journal Template Name=FIELD(Journal Template Name),
                            Line No.=FIELD(Line No.),
                            Journal Batch Name=FIELD(Journal Batch Name) }

  }
  REQUESTPAGE
  {
    PROPERTIES
    {
      SaveValues=Yes;
      OnOpenPage=BEGIN
                   // Choose the contract specified in the first journal line
                   JournalRecExt.InitGetLine(CurrentJournalLine);
                   RemAgreement.GET(JournalRecExt."Remittance Agreement Code");
                   RemAgreementCode := RemAgreement.Code;
                   CurrentOperator := RemAgreement."Operator No.";
                   CurrentPassword := RemAgreement.Password;
                   CurrentDivision := RemAgreement.Division;
                   CurrentFilename := RemAgreement."Payment File Name"
                 END;

    }
    CONTROLS
    {
      { 1900000001;0;Container;
                  ContainerType=ContentArea }

      { 1900000002;1;Group  ;
                  CaptionML=[ENU=Options;
                             NOR=Alternativer;
                             SVE=Alternativ] }

      { 13  ;2   ;Field     ;
                  CaptionML=[ENU=Remittance agreement code;
                             NOR=Remitteringsavtalekode];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=RemAgreementCode;
                  TableRelation="Remittance Agreement";
                  OnValidate=BEGIN
                               RemAgreement.GET(RemAgreementCode);
                               CurrentOperator := RemAgreement."Operator No.";
                               CurrentPassword := RemAgreement.Password;
                               CurrentDivision := RemAgreement.Division;
                               CurrentFilename := RemAgreement."Payment File Name"
                             END;
                              }

      { 3   ;2   ;Field     ;
                  CaptionML=[ENU=Operator;
                             NOR=Operator;
                             SVE=Operat”r];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=CurrentOperator }

      { 5   ;2   ;Field     ;
                  ExtendedDatatype=Masked;
                  CaptionML=[ENU=Password;
                             NOR=Passord;
                             SVE=L”senord];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=CurrentPassword }

      { 9   ;2   ;Field     ;
                  CaptionML=[ENU=Division;
                             NOR=Divisjon;
                             SVE=Division];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=CurrentDivision }

      { 1   ;2   ;Field     ;
                  CaptionML=[ENU=Current note;
                             NOR=Oppdragsbemerkning];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=CurrentNote }

      { 8   ;2   ;Field     ;
                  CaptionML=[ENU=Filename;
                             NOR=Filnavn;
                             SVE=Filnamn];
                  ApplicationArea=#Basic,#Suite;
                  SourceExpr=CurrentFilename;
                  OnAssistEdit=BEGIN
                                 CurrentFilename := FileMgt.SaveFileDialog(Text015,CurrentFilename,Text016);
                               END;
                                }

    }
  }
  LABELS
  {
  }
  CODE
  {
    VAR
      JournalRec@1080100 : Record 81;
      RemAccount@1080101 : Record 11128506;
      StoreRemAccount@1080102 : Record 11128506;
      RemAgreement@1080103 : Record 11128503;
      PaymOrder@1080104 : Record 11128504;
      LineRec@1080105 : Record 11128505;
      CurrentJournalLine@1080106 : Record 81;
      WaitingJournal@1080107 : Record 11128507;
      Vendor@111280001 : Record 23;
      VendorExt@111280000 : Record 11128090;
      FindSetup@1080109 : Record 98;
      PurchSetup@1080110 : Record 312;
      RemTools@1080111 : Codeunit 11128515;
      FileMgt@1080015 : Codeunit 419;
      DateNow@1080113 : Date;
      TimeNow@1080114 : Time;
      ProductionDate@1080115 : Text[4];
      TransactionDate@1080116 : Text[4];
      StoreNextno@1080117 : Integer;
      OwnAccountNo@1080118 : Code[11];
      CountTrans@1080119 : Integer;
      CurrentOperator@1080120 : Text[11];
      CurrentDivision@1080121 : Text[11];
      CurrentPassword@1080122 : Text[10];
      CurrentNote@1080123 : Text[50];
      CurrentFilename@1080125 : Text[250];
      RemAgreementCode@1080126 : Code[10];
      Text001@1080007 : TextConst 'ENU=There are no payments to export.\Export is cancelled.;NOR=Ingen betalinger † lese ut.\Utlesning stoppet.';
      Text002@1080006 : TextConst 'ENU=Account and remittance agreement are different.;NOR=Kontoavtale og Remitteringsavtale er forskjellig.';
      Text003@1080005 : TextConst '@@@=Parameter 1 - decimal amount, 2 - account number, 3 - date.;ENU=Payment amount cannot be negative.\Balance for vendor %2 %3 is %1.;NOR=Betalingsbel›pet kan ikke v‘re negativt.\Saldo for leverand›r %2 %3 er %1.';
      Text004@1080004 : TextConst '@@@=Parameter 1 - decimal amount, 2 - account number, 3 - date, 4 - currency code, 5 - decimal amount.;ENU=Payment amount cannot be negative.\Balance for vendor %2 %3 is %1, currency %4 exchange rate %5.;NOR=Betalingsbel›pet kan ikke v‘re negativt.\Saldo for leverand›r %2 %3 er %1, valuta %4, kurs %5.';
      Text006@1080002 : TextConst 'ENU=You must fill in one of the following fields in journal line %1: KID, External Document No., or Recipient Ref.;NOR=Du m† fylle ut f›lgende felt i journallinje %1: KID, Eksterndokumentnr. eller Mottakerref.';
      Text007@1080001 : TextConst 'ENU=It is not required to fill in %1 on line %2 because the amount is below NOK %3.\\But it is recommended that you fill this field in.\\Do you want to continue?;NOR=Det er ikke n›dvendig † fylle ut %1 p† linje %2 fordi bel›pet er under NOK %3.\\Men det anbefales at du fyller ut dette feltet.\\Vil du fortsette?';
      Text008@1080000 : TextConst 'ENU=%1 is missing. This field is required because %2 on line %3 is higher than %4.;NOR=%1 mangler. Dette feltet kreves fordi %2 p† linje %3 er h›yere enn %4.';
      Text009@1080008 : TextConst 'ENU=You must fill in one of the following fields in journal line %1: KID, External Document No. or Recipient Ref. Abroad.;NOR=Du m† fylle ut f›lgende felt i journallinje %1: KID, Eksterndokumentnr. eller Mottaker ref. utland.';
      Text010@1080010 : TextConst 'ENU=Select invoice currency: %1 invoice entries are selected.;NOR=Velg fakturavaluta: %1 fakturaposter er valgt.';
      Text011@1080009 : TextConst 'ENU=should follow ISO-standard (3 char);NOR=skal angis med ISO-standard (3 tegn)';
      Text012@1080012 : TextConst 'ENU=Recipient address, city, and post code should be filled in. Do you want to continue?;NOR=Mottakeadresse, by og postnummer m† fylles ut. Vil du fortsette?';
      Text013@1080011 : TextConst 'ENU=Export is cancelled.;NOR=Utlesning stoppet.';
      Text014@1080013 : TextConst 'ENU=Line %1 is not 80 chars long.\%2;NOR=Linje %1 er ikke 80 tegn.\%2';
      Text015@1080003 : TextConst 'ENU=Remittance - export (bank);NOR=Remittering - les ut (bank)';
      Text016@1080014 : TextConst 'ENU=Text Files (*.txt)|*.txt|All Files (*.*)|*.*;NOR=Tekstfiler (*.txt)|*.txt|Alle filer (*.*)|*.*';
      SkipSpecification@1080016 : Boolean;
      SkipPaymentTypeCodeAbroad@1080017 : Boolean;
      JournalRecExt@111280002 : Record 11128091;

    PROCEDURE CreatePaymOrderHead@4();
    VAR
      NextID@1080000 : Integer;
    BEGIN
      // Create a PaymOrder for import.
      // Select ID. Find next:
      PaymOrder.LOCKTABLE;
      IF PaymOrder.FINDLAST THEN
        NextID := PaymOrder.ID + 1
      ELSE
        NextID := 1;

      // Insert new PaymOrder. Remaining data are processed later:
      PaymOrder.INIT;
      PaymOrder.ID := NextID;
      PaymOrder.Date := DateNow;
      PaymOrder.Time := TimeNow;
      PaymOrder.Type := PaymOrder.Type::Export;
      PaymOrder.Comment := CurrentNote;
      PaymOrder.INSERT;
    END;

    PROCEDURE ApplHeader@12() : Text[40];
    VAR
      Header@1080000 : Text[40];
      RoutineID@1080001 : Text[4];
    BEGIN
      // Header of 40 chars. Inserted several places in data. [p8]
      // For use in other blocks.

      // select routine ID - inland or abroad:
      CASE StoreRemAccount.Type OF
        StoreRemAccount.Type::Domestic:
          RoutineID := 'TBII';
        StoreRemAccount.Type::Foreign:
          RoutineID := 'TBIU';
        StoreRemAccount.Type::"Payment Instr.":
          RoutineID := 'TBIO';
      END;

      Header :=
        'AH' + // ID
        '2' + // Version
        '00' + // Return code
        RoutineID + // RoutineID. 4 char
        TransactionDate + // Trans.Date.
        RemTools.NextSeqNo(RemAgreement,0) + // Trans.Sequence. Daily number.
        Fill(8) + // Trans. Code - Reserved.
        Fill(11) + // UserID - Reserved.
        '04';                      // Number, 80 chars. Fixed.

      EXIT(Header);
    END;

    PROCEDURE Betfor00@2();
    VAR
      Operator@1080000 : Text[11];
      Division@1080001 : Text[11];
    BEGIN
      // Identification transaction [p30]

      // Format operator:
      IF RemAgreement."Payment System" = RemAgreement."Payment System"::"DnB Telebank" THEN
        // Operator is Numeric:
        Operator := RemTools.FormatNumStr(CurrentOperator,11)
      ELSE
        // Operator is Alfa:
        Operator := PADSTR(CurrentOperator,11,' ');

      // Format division:
      IF RemAgreement."Payment System" = RemAgreement."Payment System"::"Fokus Bank" THEN
        // Division is Numeric:
        Division := RemTools.FormatNumStr(CurrentDivision,11)
      ELSE
        // Division is Alfa:
        Division := PADSTR(CurrentDivision,11,' ');

      // Line 1:
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 char.
        'BETFOR00' + // Transaction code (BETFOR00=identification transaction)
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        Division + // Division, 11 chars
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no.
        Fill(6);                   // Reserved 6 chars.
      InsertLine(LineRec);

      // Line 2:
      InitLine(LineRec);
      LineRec.Data :=
        ProductionDate + // ProductionDate.
        PADSTR(RemAgreement.Password,10,' ') + // Password.
        'VERSJON002' + // Routine version.
        Fill(10) + // New password. Doesn't use 10 chars.
        Operator + // Operator no.
        ' ' + // Sigill Seal-use.  Not in use.
        RemTools.FormatNum(0,6,FALSE) + // Sigill Seal-date.  Not in use.
        RemTools.FormatNum(0,20,FALSE) + // Sigill Part-key.  Not in use.
        ' ' + // Seal how.  Not in use.
        Fill(7);                          // Reserved - 7 of total of 143 chars.
      InsertLine(LineRec);

      // Line 3. This line is reserved chars only:
      InitLine(LineRec);
      LineRec.Data := Fill(80);               // Reserved - 80  of total of 143 chars.
      InsertLine(LineRec);

      // Line 4:
      InitLine(LineRec);
      LineRec.Data :=
        Fill(56) + // Reserved - the last 56 and total of 143 chars.
        Fill(15) + // Own ref. batch, 15 chars
        Fill(9);                          // Reserved 9 chars.
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor01@15(JournalRec@1080000 : Record 81);
    VAR
      InvoiceEntry@1080001 : Record 25;
      DueDate@1080002 : Text[6];
      Y@1080003 : Text[2];
      M@1080004 : Text[2];
      D@1080005 : Text[2];
      PaymentCurrency@1080006 : Text[3];
      InvoiceCurrency@1080007 : Text[3];
      ChargesInland@1080008 : Text[3];
      ChargesAbroad@1080009 : Text[3];
      Warning@1080010 : Text[30];
      UrgencyNotice@1080011 : Text[1];
      AgreedExchRate@1080012 : Text[8];
      AgreedWith@1080013 : Text[6];
      Check@1080014 : Text[1];
      PriceInfo@1080018 : Text[1];
      ValueDateRecBank@1080019 : Text[6];
    BEGIN
      // Transfer-transaction abroad. [p22]

      Vendor.GET(JournalRec."Account No.");
      VendorExt.InitGetLine(Vendor);
      JournalRecExt.InitGetLine(JournalRec);

      // Payment date: Format YYMMDD (with leading 0 if possible):
      Y := COPYSTR(FORMAT(DATE2DMY(JournalRec."Posting Date",3),4),3,2);  // Years only (not centuries)
      M := FORMAT(DATE2DMY(JournalRec."Posting Date",2),2);
      D := FORMAT(DATE2DMY(JournalRec."Posting Date",1),2);
      DueDate := Y + M + D;
      // Endre f.eks. dato '9612 1' til '961201'.
      DueDate := CONVERTSTR(DueDate,' ','0');

      // Payment and invoice currency type:
      // Get invoice currency from the invoice entry:

      // Value date receiving bank: Format YYMMDD (with leading 0 if possible):
      Y := COPYSTR(FORMAT(DATE2DMY(JournalRec."Posting Date",3),4),3,2);  // Years only (not centuries)
      M := FORMAT(DATE2DMY(JournalRec."Posting Date",2),2);
      D := FORMAT(DATE2DMY(JournalRec."Posting Date",1),2);
      ValueDateRecBank := Y + M + D;
      // Endre f.eks. dato '9612 1' til '961201'.
      ValueDateRecBank := CONVERTSTR(ValueDateRecBank,' ','0');

      // Payment and invoice currency type:
      // Get invoice currency from the invoice entry:

      InvoiceEntry.SETCURRENTKEY("Document No.");
      InvoiceEntry.SETRANGE("Document Type",JournalRec."Applies-to Doc. Type");
      InvoiceEntry.SETRANGE("Document No.",JournalRec."Applies-to Doc. No.");
      InvoiceEntry.SETRANGE("Vendor No.",JournalRec."Account No.");
      InvoiceEntry.FINDFIRST;
      IF InvoiceEntry.COUNT <> 1 THEN // In case the same document no. was used several times.
        ERROR(Text010,InvoiceEntry.COUNT);
      IF InvoiceEntry."Currency Code" = '' THEN
        InvoiceCurrency := PADSTR(FindSetup."LCY Code",3)
      ELSE BEGIN
        IF STRLEN(InvoiceEntry."Currency Code") <> 3 THEN
          InvoiceEntry.FIELDERROR("Currency Code",Text011);
        InvoiceCurrency := InvoiceEntry."Currency Code";
      END;
      // Payment currency. Specified only if <> Invoice currency type.
      // Attention: Fokus Bank requires that this field is filled in. Payment currency must be specified.
      IF JournalRec."Currency Code" = '' THEN
        PaymentCurrency := PADSTR(FindSetup."LCY Code",3)
      ELSE BEGIN
        IF STRLEN(JournalRec."Currency Code") <> 3 THEN
          JournalRec.FIELDERROR("Currency Code",Text011);
        PaymentCurrency := JournalRec."Currency Code";
      END;

      // Charges
      CASE VendorExt."Charges Domestic" OF
        VendorExt."Charges Domestic"::"Debit remitter":
          ChargesInland := 'OUR';
        VendorExt."Charges Domestic"::"Debit recipient":
          ChargesInland := 'BEN';
        VendorExt."Charges Domestic"::Default:
          ChargesInland := '   ';
      END;
      CASE VendorExt."Charges Abroad" OF
        VendorExt."Charges Abroad"::"Debit remitter":
          ChargesAbroad := 'OUR';
        VendorExt."Charges Abroad"::"Debit recipient":
          ChargesAbroad := 'BEN';
        VendorExt."Charges Abroad"::Default:
          ChargesAbroad := '   ';
      END;

      // Warning:
      CASE VendorExt."Warning Notice" OF
        VendorExt."Warning Notice"::None:
          Warning := '';
        VendorExt."Warning Notice"::Phone:
          Warning := 'PHONE';
        VendorExt."Warning Notice"::Fax:
          Warning := 'TELEX';
        VendorExt."Warning Notice"::Other:
          Warning := 'OTHER' + VendorExt."Warning Text";
      END;
      Warning := PADSTR(Warning,30,' ');

      // UrgencyNotice:
      IF JournalRecExt.Urgent THEN
        UrgencyNotice := 'Y'
      ELSE
        UrgencyNotice := ' ';

      // Agreed exchg. rate:
      AgreedExchRate := RemTools.FormatNum(JournalRecExt."Agreed Exch. Rate",8,TRUE);
      AgreedWith := PADSTR(JournalRecExt."Agreed With",6);

      // Check:
      CASE JournalRecExt.Check OF
        JournalRecExt.Check::No:
          Check := ' ';
        JournalRecExt.Check::"Send to employer":
          Check := '0';
        JournalRecExt.Check::"Send to beneficiary":
          Check := '1';
      END;

      PriceInfo := Fill(1);

      // Line 1:
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR01' + // Transaction code, 8 chars
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no. (own).
        RemTools.NextSeqNo(RemAgreement,1) + // Global Sequence no. 4 digits.
        Fill(6);                           // Reference no. Blank for new paym orders.
      InsertLine(LineRec);

      // Line 2:
      InitLine(LineRec);
      LineRec.Data :=
        DueDate + // DueDate YYMMDD.
        PADSTR(JournalRec."Account No.",30) + // Own ref. PaymOrder. Users own ID. Not in use!
        // Ownref. PAYFOR04 is used.
        PaymentCurrency + // Payment currency type. Specified only if <> InvoiceCurrencytype.
        InvoiceCurrency + // Invoice currency type. Specified if paym.Currency is not specified.
        ChargesAbroad + // 3 chars
        ChargesInland + // 3 chars
        Warning + // 30 chars
        UrgencyNotice + // ='Y' if urgent. 1 char
        COPYSTR(AgreedExchRate,1,1);       // First char in this line. The last 7 in next line. 1 char.
      InsertLine(LineRec);

      // Line 3:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(AgreedExchRate,2,7) + // Last 7 chars. 7 chars
        PADSTR(JournalRecExt."Futures Contract No.",6) + // 6 chars
        RemTools.FormatNum(JournalRecExt."Futures Contract Exch. Rate",8,TRUE) + // 8 chars
        Check + // Draw a check?. 1 char
        Fill(6) + // Value date receiving bank, 6 chars
        Fill(2) + // Reserved 2 chars.
        '000000000000' + // R2, Real exchange rate. 12 chars
        Fill(12) + // R2, Execution ref. 2, 12 chars
        '0000000000000000' + // R2, Debited amount. 16 chars
        '0000000000';                      // R2, Transfered amount. First 10 chars
      InsertLine(LineRec);

      // Line 4:
      InitLine(LineRec);
      LineRec.Data :=
        '000000' + // R2, Transfered amount. Last 6 chars
        Fill(5) + // ClientRef 5 chars
        '000000' + // R2,M Execution ref. 6 chars
        AgreedWith + // 6 chars
        ' ' + // Deleting. Not supported. 1 char
        ' ' + // SBP-kode. DnB field. 1 char
        '000000' + // R2, value date. 6 chars
        '000000000' + // R2, Commision. 9 chars
        '000000000000' + // R2, Exchange rate in LCY. 12 chars
        Fill(1) + // R2, cancellation cause - 1 char - blank
        '0000000000000000' + // 16 chars
        PriceInfo + // R2, 1 char
        Fill(10);                          // Reserved 10 chars

      InsertLine(LineRec);
    END;

    PROCEDURE Betfor02@16(JournalRec@1080000 : Record 81);
    VAR
      BankAdr1@1080001 : Text[35];
      SWIFTRemb@1080002 : Text[11];
      BankCode@1080003 : Text[15];
      AccNoTBIO@1080004 : Text[35];
      BankName@1080007 : Text[35];
    BEGIN
      // Bank-link transaction abroad. [p23]

      Vendor.GET(JournalRec."Account No.");
      VendorExt.InitGetLine(Vendor);
      JournalRecExt.InitGetLine(JournalRec);
      RemAccount.GET(JournalRecExt."Remittance Account Code");

      // bank no. for TBIO - used with tbio only
      IF RemAccount.Type = 2 THEN
        AccNoTBIO := PADSTR(RemAccount."Bank Account No.",35)
      ELSE
        AccNoTBIO := Fill(35);

      // Swift address should always be filled out, and must be filled out for payments within EU
      VendorExt.TESTFIELD(SWIFT);

      // SWIFT remb. Will be devided:
      SWIFTRemb := PADSTR(VendorExt."SWIFT Remb. Bank",11);

      // Rec. country/region code must be filled out
      // Bank Code is used only if IBAN not used, and recipient country/region is one of the following countries:
      // 'AU','CA','IE','GB','CH','ZA','DE','US','AT'
      VendorExt.TESTFIELD("Rcpt. Bank Country/Region Code");
      BankCode := Fill(15);
      IF VendorExt."Rcpt. Bank Country/Region Code" IN ['AU','CA','IE','GB','CH','ZA','DE','US','AT'] THEN
        BankCode := PADSTR(VendorExt."Recipient Bank Account No.",15);

      // If Bankcode is filled out - then bankname and address MUST be blank.
      BankAdr1 := Fill(35);
      BankName := Fill(35);
      IF BankCode = '' THEN BEGIN
        // Bank address 1. Split:
        BankAdr1 := PADSTR(VendorExt."Bank Address 1",35);
        // Bank name
        BankName := PADSTR(VendorExt."Bank Name",35);
      END;

      // Note! If swift adr. is filled out then bankname and adr. should be blank, unless
      // the payment is to be forwarded from the swift bank to an underlying non-swift bank.
      // If this is not the case and both swift adr. and bankname/address is filled out -
      // the customer will be charged with the fee.

      // Line 1:
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR02' + // Transaction code
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no. (own).
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Reference no. Blank for new PaymOrders.
      InsertLine(LineRec);

      // Line 2:
      InitLine(LineRec);
      LineRec.Data :=
        PADSTR(VendorExt.SWIFT,11) + // Swift address for recipients bank. 11 chars
        PADSTR(BankName,35) + // Recipients bank. 35 chars
        COPYSTR(BankAdr1,1,34);           // First 34 chars. 34 chars
      InsertLine(LineRec);

      // Line 3:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(BankAdr1,35,1) + // Last char. 1 char
        PADSTR(VendorExt."Bank Address 2",35) + // Recipients bank. 35 chars
        PADSTR(VendorExt."Bank Address 3",35) + // Recipients bank. 35 chars
        COPYSTR(SWIFTRemb,1,9);            // First 9 chars. 9 chars
      InsertLine(LineRec);

      // Line 4:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(SWIFTRemb,10,2) + // Last 2 chars. 2 chars
        PADSTR(VendorExt."Rcpt. Bank Country/Region Code",2) + // Country/Region code 2 chars
        BankCode + // 15 chars
        PADSTR(AccNoTBIO,35) + // Account No. (only used with TBIO)
        Fill(26);                          // Reserved 26 chars
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor03@17(JournalRec@1080000 : Record 81);
    VAR
      Recipient@1080001 : ARRAY [4] OF Text[35];
      TelexFax@1080002 : Text[1];
      RecAdr@1080003 : Boolean;
    BEGIN
      // Recipients transaction abroad. [p24]

      Vendor.GET(JournalRec."Account No.");
      VendorExt.InitGetLine(Vendor);

      // These fields are to be regarded as a unit. If the first position in one
      // of the fields is not filled in (is blank) the rest of the field will be ignored.
      // Line 1 must be filled in before line 2 etc. There must not be any blank lines between the fields.
      //>>160908
      //Recipient[1] := Vendor.Name;
      //Recipient[2] := Vendor.Address;
      //Recipient[3] := Vendor."Address 2";
      //Recipient[4] := Vendor."Post Code" + ' ' + Vendor.City;
      Recipient[1] := COPYSTR(Vendor.Name,1,35);
      Recipient[2] := COPYSTR(Vendor.Address,1,35);
      Recipient[3] := COPYSTR(Vendor."Address 2",1,35);
      Recipient[4] := COPYSTR(Vendor."Post Code" + ' ' + Vendor.City,1,35);
      //<<160908
      COMPRESSARRAY(Recipient);

      // Rec. Adress should be filled out to make sure the recepient receives payment notice, however, it is not required,
      // only recommended
      RecAdr := TRUE;
      IF (Recipient[2] = '') OR (Recipient[3] = '') OR (Vendor."Post Code" = '') OR (Vendor.City = '') THEN
        RecAdr := CONFIRM(Text012,TRUE);
      IF NOT RecAdr THEN
        ERROR(Text013);

      // 35 chars in all fields:
      Recipient[1] := PADSTR(Recipient[1],35);
      Recipient[2] := PADSTR(Recipient[2],35);
      Recipient[3] := PADSTR(Recipient[3],35);
      Recipient[4] := PADSTR(Recipient[4],35);

      // Telex, fax:
      CASE VendorExt."Recipient Confirmation" OF
        VendorExt."Recipient Confirmation"::None:
          TelexFax := ' ';
        VendorExt."Recipient Confirmation"::Telex:
          TelexFax := 'T';
        VendorExt."Recipient Confirmation"::Fax:
          TelexFax := 'F';
      END;

      // Rec. country/region code must be filled out
      Vendor.TESTFIELD("Country/Region Code");

      // Line 1:
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR03' + // transaction code
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no. (own). 11 chars
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Reference no. Blank for new PaymOrders.
      InsertLine(LineRec);

      // Line 2:
      InitLine(LineRec);
      LineRec.Data :=
        PADSTR(VendorExt."Recipient Bank Account No.",35) + // 35 chars.
        Recipient[1] + // Recipients name. 35 chars
        COPYSTR(Recipient[2],1,10);         // Recipients address 1. 35 chars
      InsertLine(LineRec);

      // Line 3:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(Recipient[2],11,25) + // Recipients address 1. Last 25 chars
        Recipient[3] + // Recipients address 2. 35 chars
        COPYSTR(Recipient[4],1,20);         // Recipients address 3. First 20 chars
      InsertLine(LineRec);

      // Line 4:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(Recipient[4],21,15) + // Recipients address 3. Last 15 chars
        PADSTR(Vendor."Country/Region Code",2) + // Recipients country/region code. 2 chars
        TelexFax + // 1 char
        PADSTR(VendorExt."Telex Country/Region Code",2) + // Recipients telex country/region code. 2 chars
        PADSTR(VendorExt."Telex/Fax No.",18) + // Telex/fax no. 18 chars
        PADSTR(VendorExt."Recipient Contact",20) + // Attention: 20 chars
        Fill(22);                           // Reserved 22 chars
      // This shoudln't create problems, regardless of data filled in here.
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor04@18(JournalRec@1080000 : Record 81);
    VAR
      OwnRef@1080001 : Text[35];
      InvoiceAmount@1080002 : Text[15];
      DebitCreditCode@1080003 : Text[1];
      ToOwnAccount@1080004 : Text[1];
      KIDForeign@1080005 : Text[1];
      RecRefAbroad@1080006 : Code[35];
    BEGIN
      // Invoice transaction abroad. [p25]

      Vendor.GET(JournalRec."Account No.");
      VendorExt.InitGetLine(Vendor);
      JournalRecExt.InitGetLine(JournalRec);

      // Format own ref.:
      // Own ref. comes from Waiting journal it refers to.
      OwnRef := STRSUBSTNO('%1',WaitingJournal.Reference);
      OwnRef := PADSTR(OwnRef,35);

      // Format invoice amount:
      InvoiceAmount := RemTools.FormatNum(JournalRec.Amount,15,TRUE);

      // Create debit/credit code:
      IF JournalRec.Amount < 0 THEN
        DebitCreditCode := 'K'
      ELSE
        DebitCreditCode := 'D';

      // either KID i "recipient ref. (abroad)" + 'K' in "KID (Foreign)" (if KID specified)
      // or invoice no. i "recipient ref. (abroad)" and blank in "KID (Foreign)" otherwise
      IF JournalRecExt.KID <> '' THEN BEGIN
        RecRefAbroad := JournalRecExt.KID;
        KIDForeign := 'K';
      END ELSE BEGIN
        IF JournalRec."External Document No." <> '' THEN
          RecRefAbroad := JournalRec."External Document No."
        ELSE
          RecRefAbroad := JournalRecExt."Recipient Ref. Abroad";
        KIDForeign := ' ';
      END;
      // To own account:
      IF VendorExt."To Own Account" THEN
        ToOwnAccount := 'Y'
      ELSE
        ToOwnAccount := ' ';

      // Line 1:
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
         'BETFOR04' + // transaction code
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no (own).
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Reference no. Blank for new PaymOrders.
      InsertLine(LineRec);

      // Line 2:
      InitLine(LineRec);
      LineRec.Data :=
        PADSTR(RecRefAbroad,35) + // Recipient ref.
        OwnRef + // Own reference. Important!: Identification for return. 35 chars
        COPYSTR(InvoiceAmount,1,10);        // First 10 chars
      InsertLine(LineRec);

      // Line 3:
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(InvoiceAmount,11,5) + // Last 5 chars
        DebitCreditCode + // 1 char
        PADSTR(JournalRecExt."Payment Type Code Abroad",6) + // 6 chars
        PADSTR(JournalRecExt."Specification (Norges Bank)",60) + // Amount concerned. 60 chars
        ToOwnAccount + // To own account. 1 char
        Fill(1) + // R2, Cancelation cause - 1 char - blank
        '000000';                          // reserved 6 chars
      InsertLine(LineRec);

      // Line 4:
      InitLine(LineRec);
      LineRec.Data :=
        ' ' + // Reserved 1 char
        '000000' + // Reserved 6 chars
        Fill(45) + // Reserved 45 chars
        KIDForeign + // 1 char
        '000' + // R1, R2. 3 chars.
        Fill(24);                          // Reserved 24 chars
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor21@5(JournalRec@1080000 : Record 81);
    VAR
      DueDate@1080001 : Text[6];
      TextCode@1080002 : Code[3];
      RecipientAccount@1080003 : Text[30];
      Y@1080004 : Text[2];
      M@1080005 : Text[2];
      D@1080006 : Text[2];
    BEGIN
      // Transfer transaction. [p31]
      // Header for new creditor. New PAyfor21+payfor23 for shift in:
      // 1. Creditor
      // 2. Date
      // 3. Max. 14 Invoices.
      // 4. Currency

      // Get creditor:
      Vendor.GET(JournalRec."Account No.");
      VendorExt.InitGetLine(Vendor);
      JournalRecExt.InitGetLine(JournalRec);

      // Convert BOLS text code-optionfield to correct code:
      WITH JournalRecExt DO BEGIN
        CASE "BOLS Text Code" OF
          "BOLS Text Code"::"Transfer without advice":
            TextCode := '600';
          "BOLS Text Code"::"KID transfer":
            TextCode := '601';
          "BOLS Text Code"::"Transfer with advice":
            TextCode := '602';
          "BOLS Text Code"::"Money order":
            TextCode := '603';
          "BOLS Text Code"::Salary:
            TextCode := '604';
          "BOLS Text Code"::"Seaman's pay":
            TextCode := '605';
          "BOLS Text Code"::"Agricultural settlement":
            TextCode := '606';
          "BOLS Text Code"::"Pension/ Social security":
            TextCode := '607';
          "BOLS Text Code"::"Advice sent from institution other than BBS":
            TextCode := '608';
          "BOLS Text Code"::Tax:
            TextCode := '609';
          "BOLS Text Code"::"Free text mass payment":
            TextCode := '621';
          "BOLS Text Code"::"Free text":
            TextCode := '622';
          "BOLS Text Code"::"Self-produced money order":
            TextCode := '630';
        END;

      //>>RFC-034
        //IF KID <> '' THEN
        IF (KID <> '') AND (NOT RemAccount."No KID") THEN
      //<<RFC-034
          TextCode := '601'
        ELSE
          IF JournalRec."External Document No." <> '' THEN
            TextCode := '600'
          ELSE
            TextCode := '602';
      END;

      // Format YYMMDD (with leading 0, if possible):
      Y := COPYSTR(FORMAT(DATE2DMY(JournalRec."Posting Date",3),4),3,2);  // Years only (not centuries)
      M := FORMAT(DATE2DMY(JournalRec."Posting Date",2),2);
      D := FORMAT(DATE2DMY(JournalRec."Posting Date",1),2);
      DueDate := Y + M + D;
      // Change, for ex., date '9612 1' to '961201'.
      DueDate := CONVERTSTR(DueDate,' ','0');

      // Format recipients account [p37] (REMEMBER it's an Alfa-field):
      IF VendorExt."Recipient Bank Account No." = '' THEN  // Account no. is not specified. Use account 19:
        RecipientAccount := '00000000019'
      ELSE BEGIN // Account is specified. Format account no. deletes all non-numerical char:
        RecipientAccount := '00000000000' + RemTools.FormatAccountNo(VendorExt."Recipient Bank Account No.");
        RecipientAccount := COPYSTR(RecipientAccount,STRLEN(RecipientAccount) - 10);  // 11 last chars.
      END;

      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR21' + // Transaction code (PAYFOR21=Transfer-transaction)
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no (own).
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Referance no. Blank for new PaymOrders.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        DueDate + // Payment date YYMMDD.
        PADSTR(JournalRec."Account No.",30) + // Own ref. PaymOrder. Users own id. Not in use!
        // - Own ref i PAYFOR23 is used in return.
        ' ' + // Reserved. 1 char.
        RecipientAccount + // Recipients account.
        PADSTR(Vendor.Name,30) + // Recipients name.
        COPYSTR(PADSTR(Vendor.Address,30),1,2);  // Adress 1. First 2 chars
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(PADSTR(Vendor.Address,30),3) + // Adress 1. Last 28 chars
        PADSTR(Vendor."Address 2",30) + // Adress 2.
        PADSTR(Vendor."Post Code",4) + // Postal code.
        COPYSTR(PADSTR(Vendor.City,26),1,18); // City
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(PADSTR(Vendor.City,26),19) + // city. Remaining 8 chars.
        '000000000000000' + // Amount to own account. 15 chars. NOT SUPPORTED!
        TextCode + // TextCode. BOLS [p40], 3 chars
        'F' + // Trans. type. Only Invoice is supported.
        ' ' + // Deleting. Set ='D' if transaction was previously deleting.
        '000000000000000' + // Total amount. Only settled return R2.
        '00000' + // Reserved. 5 numerical chars.
        Fill(6) + // Value date. Return only (R2).
        Fill(6) + // Value date receiving bank, 6 chars
        Fill(1) + // R2, cancellation cause, 1 char - blanke
        Fill(9) + // Reserved.
        Fill(10);                          // 10 chars
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor23@6(JournalRec@1080000 : Record 81);
    VAR
      DebitCreditCode@1080001 : Text[1];
      OwnRef@1080002 : Text[30];
      InvoiceNo@1080003 : Text[20];
      CustomerNo@1080005 : Text[15];
      InvoiceDate@1080006 : Text[8];
      RecRef1@1080007 : Text[40];
      RecRef2@1080008 : Text[40];
      RecRef3@1080009 : Text[40];
      KID@1080010 : Text[27];
      Y@1080011 : Text[4];
      M@1080012 : Text[2];
      D@1080013 : Text[2];
      PurchInvHeader@1100285500 : Record 122;
      SymbrioSetup@1100285501 : Record 11127975;
    BEGIN
      // Invoice transaction. [p33]
      JournalRecExt.InitGetLine(JournalRec);

      // Create debit/credit code:
      IF JournalRec."Amount (LCY)" < 0 THEN
        DebitCreditCode := 'K'
      ELSE
        DebitCreditCode := 'D';

      // Format own ref:
      // Own ref comes from Waiting journal it refers to.
      OwnRef := STRSUBSTNO('%1',WaitingJournal.Reference);
      OwnRef := PADSTR(OwnRef,30);  // Length is 30 char.

      KID := Fill(27);
      RecRef1 := Fill(40);
      RecRef2 := Fill(40);
      RecRef3 := Fill(40);
      CustomerNo := Fill(15);
      InvoiceNo := Fill(20);
      InvoiceDate := Fill(8);

      // ONLY ONE of the following: KID, External Doc. No., or Recipient ref. 1-3 can be filled out for one payment.
      IF JournalRecExt.KID = '' THEN
        IF JournalRec."External Document No." = '' THEN BEGIN
          JournalRecExt.TESTFIELD("Recipient Ref. 1");
          RecRef1 := PADSTR(JournalRecExt."Recipient Ref. 1",40);
          RecRef2 := PADSTR(JournalRecExt."Recipient Ref. 2",40);
          RecRef3 := PADSTR(JournalRecExt."Recipient Ref. 3",40);
        END ELSE BEGIN

          InvoiceNo := PADSTR(JournalRec."External Document No.",20);

      //>>IME253
          IF SymbrioSetup.GET AND (JournalRec."Applies-to Doc. Type" = JournalRec."Applies-to Doc. Type"::Invoice) AND (PurchInvHeader.GET(JournalRec."Applies-to Doc. No.")) THEN BEGIN
            IF PurchInvHeader."Payment Reference" <> '' THEN
               InvoiceNo := PADSTR(COPYSTR(PurchInvHeader."Payment Reference",1,20),20);
          END;
      //<<IME253
      //>>RFC155
          IF JournalRec."Payment Reference"<>'' THEN
            InvoiceNo := PADSTR(COPYSTR(JournalRec."Payment Reference",1,20),20);
      //<<RFC155

          Vendor.GET(JournalRec."Account No.");
          CustomerNo := PADSTR(Vendor."Our Account No.",15);
          JournalRec.TESTFIELD("Document Date");
          // InvoiceDate: Format YYYYMMDD
          Y := COPYSTR(FORMAT(DATE2DMY(JournalRec."Document Date",3),4),1,4);  // Years incl. centuries
          M := FORMAT(DATE2DMY(JournalRec."Document Date",2),2);
          D := FORMAT(DATE2DMY(JournalRec."Document Date",1),2);
          InvoiceDate := Y + M + D;
          // Endre f.eks. dato '199612 1' til '19961201'.
          InvoiceDate := CONVERTSTR(InvoiceDate,' ','0');
        END
      ELSE
        KID := PADSTR(JournalRecExt.KID,27);
      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR23' + // Transaction code (PAYFOR23=Invoice transaction)
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        OwnAccountNo + // Account no. (own)
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Reference no. Blank for PaymOrders.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        RecRef1 + // Recipient ref. invoice. Can not be used with InvoicNo or KID
        RecRef2;                           // Recipient ref. invoice.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        RecRef3 + // Recipient ref. invoice.
        KID + // KID. Can not be used with InvoiceNo or recipient ref.
        COPYSTR(OwnRef,1,13);             // Own ref. First 13 chars
      InsertLine(LineRec);
      InitLine(LineRec);
      LineRec.Data :=
        COPYSTR(OwnRef,14) + // Own ref. Last 17 chars
        RemTools.FormatNum(JournalRec."Amount (LCY)",15,TRUE) + // Invoice amount. 15 chars.
        DebitCreditCode + // Debit/credit code.
        InvoiceNo +
        // 20 chars. can not be used with KID or recipient ref., otherwise mandatory together with
        // customer no. and invoice date. = External doc. no - gen. jnl line
        '000' + // Serial no. Specified in return data R1, R2.
        Fill(1) + // R2, cancellation cause - 1 char - blank
        CustomerNo + // 15 chars  = our account no. , vendor tbl
        InvoiceDate;                       // YYYYMMDD = document date = gen. jnl line
      InsertLine(LineRec);
    END;

    PROCEDURE Betfor99@7(LastPayfor99@1080000 : Boolean);
    VAR
      AppVersion@1080001 : Text[11];
      ApplicationSystemConstants@1100583000 : Codeunit 9015;
    BEGIN
      // Closing transaction. [p34]

      // Application version
      AppVersion := PADSTR('Nav ' + ApplicationSystemConstants.ApplicationVersion,11);

      InitLine(LineRec);
      LineRec.Data :=
        ApplHeader + // Application header. 40 chars.
        'BETFOR99' + // Transaction code (PAYFOR99=closing transaction)
        RemTools.FormatNumStr(RemAgreement."Company/Agreement No.",11) + // Company no.
        Fill(11) + // Reserved 11 char.
        RemTools.NextSeqNo(RemAgreement,1) + // Global sequence no. 4 digits.
        Fill(6);                           // Reserved 6 chars.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        ProductionDate + // Production date. 4 chars
        Fill(19) + // Reserved 19 chars.
        RemTools.FormatNum(CountTrans,5,FALSE) + // Number of transactions - blocks of 320 chars.
        Fill(52);                          // Reserved. First 52 of 163 chars.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        Fill(80);                           // Reserved. 80 of remaining 111 chars.
      InsertLine(LineRec);

      InitLine(LineRec);
      LineRec.Data :=
        Fill(31) + // Last 31 of 163 characters
        '    ' + // Sigill security. Not in use.
        ' ' + // Sigill language. Not in use.
        ' ' + // Sigill version. Not in use.
        ' ' + // Sigill interface. Not in use.
        '                  ' + // Sigill control field. Not in use.
        AppVersion + // software version, 16 version
        Fill(5) +
        Fill(8);                           // bank version - blank
      InsertLine(LineRec);

      IF LastPayfor99 THEN  // If DnB Telebank is used, an extra empty line is required.
        IF RemAgreement."Payment System" = RemAgreement."Payment System"::"DnB Telebank" THEN BEGIN
          InitLine(LineRec);
          LineRec."Empty Line" := TRUE;
          LineRec.Data := '';
          InsertLine(LineRec);
        END;
    END;

    PROCEDURE MoveToWaitingJournal@13(JournalLine@1080000 : Record 81);
    VAR
      WaitingJournal2@1080001 : Record 11128507;
    BEGIN
      WaitingJournal.INIT;
      WaitingJournal.TRANSFERFIELDS(JournalLine);
      WaitingJournal."Payment Order ID - Sent" := PaymOrder.ID;
      WaitingJournal."Remittance Status" := WaitingJournal."Remittance Status"::Sent;
      // Own reference, sent to bank:
      WaitingJournal2.LOCKTABLE;
      WaitingJournal2.INIT;
      IF WaitingJournal2.FINDLAST THEN
        WaitingJournal.Reference := WaitingJournal2.Reference + 1
      ELSE
        WaitingJournal.Reference := 1;
      WaitingJournal.VALIDATE("Remittance Account Code",RemAccount.Code);
      WaitingJournal.INSERT(TRUE);
      WaitingJournal.CopyLineDimensions(JournalLine);
    END;

    PROCEDURE Fill@3(SpaceCount@1080000 : Integer) : Text[250];
    BEGIN
      // Returns a string with number of 'spaceCount' SPACES.
      EXIT(PADSTR('',SpaceCount,' '));
    END;

    PROCEDURE NextLineNo@8(Init@1080000 : Boolean) : Integer;
    BEGIN
      // Calculate and return the next line no.
      // PARAMETERS:
      // init=True. Line nos. start with 1, from the next 'False' call.
      // init=False. Returns next line no.
      // RETURNS: Next line no.=0 if init=True.

      IF Init THEN
        StoreNextno := 0 // This number is not used.
      ELSE
        StoreNextno := StoreNextno + 1;
      EXIT(StoreNextno);
    END;

    PROCEDURE Control@1(LineNo@1080000 : Integer;Data@1080001 : Text[100]);
    BEGIN
      // An extra check. This error must not occur in customers systems.
      // Note that the last line might have length = 0

      IF (STRLEN(Data) <> 80) AND (STRLEN(Data) <> 0) THEN
        MESSAGE(Text014,LineNo,Data);
    END;

    PROCEDURE InitLine@1080009(VAR LineRec@1080000 : Record 11128505);
    BEGIN
      // Prepare data-line for use.
      LineRec.INIT;
      LineRec."Payment Order No." := PaymOrder.ID;
      LineRec."Line No" := NextLineNo(FALSE);
      LineRec."Empty Line" := FALSE;
    END;

    PROCEDURE InsertLine@10(LineRec@1080000 : Record 11128505);
    BEGIN
      // Insert data-Line in a file.
      Control(LineRec."Line No",LineRec.Data);  // My own control, just in case!
      LineRec.Data := UPPERCASE(LineRec.Data);
      LineRec.INSERT;
    END;

    PROCEDURE SetJournalLine@11(JournalLine@1080000 : Record 81);
    BEGIN
      // Transfer current lines from journal routine (f.ex. journal window):
      CurrentJournalLine := JournalLine;
    END;

    LOCAL PROCEDURE ConfirmSkipping@1080003(FieldCaption@1080000 : Text) : Boolean;
    BEGIN
      IF NOT CONFIRM(STRSUBSTNO(Text007,FieldCaption,
             FORMAT(JournalRec."Line No."),PurchSetup."Amt. Spec limit to Norges Bank"))
      THEN
        ERROR('');
      EXIT(TRUE);
    END;

    BEGIN
    {
      151216 ITERO.DL RFC034 altered detection of UnstructuredPaym
      160929 ITERO.DL RFC155 handle Payment Reference
    }
    END.
  }
  RDLDATA
  {
  }
}

