OBJECT Codeunit 9500 Debugger Management
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=NAVW114.00;
  }
  PROPERTIES
  {
    SingleInstance=Yes;
    OnRun=VAR
            Uri@1000 : DotNet "'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Uri";
            UriPartial@1001 : DotNet "'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.UriPartial";
            UrlString@1002 : Text;
          BEGIN
            // Generates a URL like dynamicsnav://host:port/instance//debug<?tenant=tenantId>
            UrlString := GETURL(CLIENTTYPE::Windows);
            Uri := Uri.Uri(UrlString);
            UrlString := Uri.GetLeftPart(UriPartial.Path) + DebuggerUrlTok + Uri.Query;

            HYPERLINK(UrlString);
          END;

  }
  CODE
  {
    VAR
      ClientAddin@1002 : Record 2000000069;
      DebuggedSession@1006 : Record 2000000110;
      DebuggerTaskPage@1000 : Page 9500;
      Text000Err@1003 : TextConst 'ENU=Cannot process debugger break. The debugger is not active.;NOR=Kan ikke behandle feils›kingsprogramstopp. Feils›kingsprogrammet er ikke aktivt.;SVE=Det g†r inte att behandla fels”kningsbrytpunkten. Fels”karen „r inte aktiv.';
      LastErrorMesssageIsNew@1007 : Boolean;
      LastErrorMessage@1005 : Text;
      CodeViewerControlRegistered@1001 : Boolean;
      ActionState@1004 : 'None,RunningCodeAction,CodeTrackingAction,BreakAfterRunningCodeAction,BreakAfterCodeTrackingAction';
      DebuggerUrlTok@1008 : TextConst '@@@={Locked};ENU=debug;NOR=debug;SVE=debug';
      ClientAddinDescriptionTxt@1009 : TextConst '@@@=%1 - product name;ENU=%1 Code Viewer control add-in;NOR=Kontrolltillegg for %1-kodevisningsprogram;SVE=%1 kontrolltill„gg Kodloggbok';

    PROCEDURE OpenDebuggerTaskPage@2();
    BEGIN
      IF NOT CodeViewerControlRegistered THEN BEGIN
        ClientAddin.INIT;
        ClientAddin."Add-in Name" := 'Microsoft.Dynamics.Nav.Client.CodeViewer';
        ClientAddin."Public Key Token" := '31bf3856ad364e35';
        ClientAddin.Description := STRSUBSTNO(ClientAddinDescriptionTxt,PRODUCTNAME.FULL);
        IF ClientAddin.INSERT THEN;
        CodeViewerControlRegistered := TRUE;
      END;

      IF NOT DEBUGGER.ISACTIVE THEN
        DebuggerTaskPage.RUN
      ELSE
        DebuggerTaskPage.CLOSE;
    END;

    [EventSubscriber(Codeunit,2000000009,OnDebuggerBreak)]
    LOCAL PROCEDURE ProcessOnDebuggerBreak@3(ErrorMessage@1000 : Text);
    BEGIN
      LastErrorMessage := ErrorMessage;
      LastErrorMesssageIsNew := TRUE;

      IF DEBUGGER.ISACTIVE THEN BEGIN
        IF ActionState = ActionState::CodeTrackingAction THEN
          ActionState := ActionState::BreakAfterCodeTrackingAction
        ELSE
          IF ActionState = ActionState::RunningCodeAction THEN
            ActionState := ActionState::BreakAfterRunningCodeAction;

        RefreshDebuggerTaskPage;
      END ELSE
        ERROR(Text000Err);
    END;

    [External]
    PROCEDURE GetLastErrorMessage@4(VAR IsNew@1000 : Boolean) Message : Text;
    BEGIN
      Message := LastErrorMessage;
      IsNew := LastErrorMesssageIsNew;
      LastErrorMesssageIsNew := FALSE;
    END;

    [External]
    PROCEDURE RefreshDebuggerTaskPage@1();
    BEGIN
      DebuggerTaskPage.ACTIVATE(TRUE);
    END;

    [External]
    PROCEDURE AddWatch@5(Path@1000 : Text[1024];Refresh@1002 : Boolean);
    VAR
      DebuggerWatch@1001 : Record 2000000104;
    BEGIN
      IF Path <> '' THEN BEGIN
        DebuggerWatch.SETRANGE(Path,Path);
        IF DebuggerWatch.ISEMPTY THEN BEGIN
          DebuggerWatch.INIT;
          DebuggerWatch.Path := Path;
          DebuggerWatch.INSERT(TRUE);

          IF Refresh THEN
            RefreshDebuggerTaskPage;
        END;
      END;
    END;

    LOCAL PROCEDURE LastIndexOf@6(Path@1000 : Text[1024];Character@1001 : Char;Index@1002 : Integer) : Integer;
    VAR
      CharPos@1003 : Integer;
    BEGIN
      IF Path = '' THEN
        EXIT(0);

      IF Index <= 0 THEN
        EXIT(0);

      IF Index > STRLEN(Path) THEN
        Index := STRLEN(Path);

      CharPos := Index;

      IF Path[CharPos] = Character THEN
        EXIT(CharPos);
      IF CharPos = 1 THEN
        EXIT(0);

      REPEAT
        CharPos := CharPos - 1
      UNTIL (CharPos = 1) OR (Path[CharPos] = Character);

      IF Path[CharPos] = Character THEN
        EXIT(CharPos);

      EXIT(0);
    END;

    [External]
    PROCEDURE RemoveQuotes@7(Variable@1000 : Text[1024]) VarWithoutQuotes : Text[1024];
    BEGIN
      IF Variable = '' THEN
        EXIT(Variable);

      IF (STRLEN(Variable) >= 2) AND (Variable[1] = '"') AND (Variable[STRLEN(Variable)] = '"') THEN
        VarWithoutQuotes := COPYSTR(Variable,2,STRLEN(Variable) - 2)
      ELSE
        VarWithoutQuotes := Variable;
    END;

    LOCAL PROCEDURE IsInRecordContext@8(Path@1000 : Text[1024];Record@1001 : Text) : Boolean;
    VAR
      Index@1002 : Integer;
      Position@1003 : Integer;
      CurrentContext@1004 : Text[250];
    BEGIN
      IF Path = '' THEN
        EXIT(FALSE);

      IF Record = '' THEN // Empty record name means all paths match
        EXIT(TRUE);

      Index := STRLEN(Path);

      IF Path[Index] = '"' THEN BEGIN
        Position := LastIndexOf(Path,'"',Index - 1);
        IF Position <= 1 THEN
          EXIT(FALSE);
        IF Path[Position - 1] <> '.' THEN
          EXIT(FALSE);
        Index := Position - 1; // set index on first '.' from the end
      END ELSE BEGIN
        Position := LastIndexOf(Path,'.',Index);
        IF Position <= 1 THEN
          EXIT(FALSE);
        Index := Position; // set index on first '.' from the end
      END;

      Index := Index - 1;
      Position := LastIndexOf(Path,'.',Index);

      IF Position <= 1 THEN  // second '.' not found - context not found
        EXIT(FALSE);

      Index := Position - 1;
      Position := LastIndexOf(Path,'.',Index);

      CurrentContext := COPYSTR(Path,Position + 1,Index - Position);
      EXIT(LOWERCASE(CurrentContext) = LOWERCASE(Record));
    END;

    [External]
    PROCEDURE ShouldBeInTooltip@10(Path@1000 : Text[1024];LeftContext@1001 : Text) : Boolean;
    BEGIN
      EXIT((STRPOS(Path,'."<Globals>"') = 0) AND (STRPOS(Path,'.Keys.') = 0) AND
        ((STRPOS(Path,'."<Global Text Constants>".') = 0) OR (STRPOS(Path,'"<Globals>"."<Global Text Constants>".') > 0)) AND
        IsInRecordContext(Path,LeftContext));
    END;

    [External]
    PROCEDURE GetDebuggedSession@11(VAR DebuggedSessionRec@1000 : Record 2000000110);
    BEGIN
      DebuggedSessionRec := DebuggedSession;
    END;

    [External]
    PROCEDURE SetDebuggedSession@12(DebuggedSessionRec@1000 : Record 2000000110);
    BEGIN
      DebuggedSession := DebuggedSessionRec;
    END;

    [External]
    PROCEDURE SetRunningCodeAction@13();
    BEGIN
      ActionState := ActionState::RunningCodeAction;
    END;

    [External]
    PROCEDURE SetCodeTrackingAction@16();
    BEGIN
      ActionState := ActionState::CodeTrackingAction;
    END;

    [External]
    PROCEDURE IsBreakAfterRunningCodeAction@14() : Boolean;
    BEGIN
      EXIT(ActionState = ActionState::BreakAfterRunningCodeAction);
    END;

    [External]
    PROCEDURE IsBreakAfterCodeTrackingAction@17() : Boolean;
    BEGIN
      EXIT(ActionState = ActionState::BreakAfterCodeTrackingAction);
    END;

    [External]
    PROCEDURE ResetActionState@15();
    BEGIN
      ActionState := ActionState::None;
    END;

    [EventSubscriber(Codeunit,2000000006,OpenDebugger)]
    LOCAL PROCEDURE OpenDebugger@9();
    BEGIN
      PAGE.RUN(PAGE::"Session List");
    END;

    BEGIN
    END.
  }
}

