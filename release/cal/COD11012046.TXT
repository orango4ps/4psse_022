OBJECT Codeunit 11012046 Close Project/Service
{
  OBJECT-PROPERTIES
  {
    Date=;
    Time=;
    Version List=4PS14.00,4PSSE;
  }
  PROPERTIES
  {
    Permissions=TableData 11072005=rimd,
                TableData 11072012=rimd;
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      GenLedgerSetup@1100485003 : Record 98;
      UserSetup@1210190123 : Record 91;
      ProjSetup@1210190104 : Record 315;
      ProjRec@1210190051 : Record 11072003;
      ProjTypeRec@1210190036 : Record 11012009;
      ProjectTypeExtension@1100529615 : Record 11229469;
      ProjEntryRec@1210190049 : Record 11072005;
      ProjCustRec@1210190046 : Record 11012005;
      ProjInstRec@1210190042 : Record 11012018;
      ProjCostPlusRec@1210190041 : Record 11012019;
      ServSetup@1210190094 : Record 11012800;
      ServTypeRec@1210190096 : Record 11012814;
      ServContrRec@1210190118 : Record 11012812;
      ServEntryRec@1210190108 : Record 11012819;
      gvServEntryRec@1100525009 : Record 11012819;
      TmpServiceEntryRec@1100525015 : TEMPORARY Record 11012819;
      TmpServiceEntryPostGroup@1100529605 : TEMPORARY Record 11012819;
      ServOrderRec@1210190103 : Record 11012823;
      ServCostPlusRec@1210190093 : Record 11012825;
      PurchLineRec@1210190047 : Record 39;
      ApprovEntryRec@1210190030 : Record 11012032;
      SalesHeader@1100485027 : Record 36;
      SalesLineRec@1210190044 : Record 37;
      ErrorRec@1210190039 : Record 11012051;
      PlotRec@1210190032 : Record 11012500;
      ExtensionRec@1210190033 : Record 11012004;
      OptionRec@1100525012 : Record 11012502;
      ICEntryRec@1210190029 : Record 11012058;
      PlantLocRec@1210190028 : Record 11012554;
      RentalUnitRec@1210190025 : Record 11012940;
      RentalPackageRec@1210190024 : Record 11012941;
      CostTypeContrRec@1210190037 : Record 11012046;
      ServJnlLineRec@1210190109 : Record 11012820;
      JobJnlLineRec@1210190034 : Record 11072008;
      GenJnlLineRec@1210190043 : Record 81;
      JnlTemplRec@1210190035 : Record 80;
      PreclosureProjectRec@1210190112 : Record 11012093;
      NewGenRegRec@1210190124 : Record 45;
      BudgetLine@1100485005 : Record 11012001;
      ScannerLineRec@1100485016 : Record 11012061;
      VendorPostingGrpSettingsRec@1100485017 : Record 11020252;
      ServVendPostGrpSettingsRec@1100525000 : Record 11012889;
      PurchSetup@1100485023 : Record 312;
      GLEntry@1100525003 : Record 17;
      GLAcc@1100525004 : Record 15;
      ProjEntryRec2@1210190045 : Record 11072005;
      PrognosisRec@1210190106 : Record 11012034;
      SalesInvoiceLine@1100409002 : Record 113;
      CustLedgerEntry@1100409003 : Record 21;
      LedgerbyProjTypeCustGr@1100529601 : Record 11229378;
      LedgerbyServTypeCustGr@1100529604 : Record 11072322;
      CreateCostControl@1210190022 : Codeunit 11012012;
      PostGenJnlLine@1210190021 : Codeunit 12;
      PostProjJnlLine@1210190020 : Codeunit 11072003;
      PostServJnlLine@1210190110 : Codeunit 11012802;
      DimMgt@1210190019 : Codeunit 408;
      CostContMgt@1210190122 : Codeunit 11012006;
      SearchProgrDate@1210190116 : Codeunit 11012014;
      Window@1210190018 : Dialog;
      gvType@1210190095 : 'Project,Service Contract,Service Order';
      gvProj@1210190050 : Code[20];
      gvContr@1210190100 : Code[20];
      gvOrder@1210190101 : Code[20];
      gvPeriod@1210190111 : Text[30];
      gvExtraTest@1100485000 : Boolean;
      gvSourceType@1100485025 : Option;
      gvCostComponent@1100525008 : Code[20];
      gvControlYear@1100485029 : Integer;
      gvContractControlPeriodCode@1100528600 : Code[10];
      gvPostProjectService@1100485030 : Boolean;
      GlobDim1Code@1100525016 : Code[20];
      DocCode@1210190017 : Code[20];
      gvDocNoCde@1210190016 : Code[20];
      NoSeriesCde@1210190015 : Code[10];
      ErrorTxt@1210190013 : Text[250];
      NextLineNo@1210190009 : Integer;
      NoOfRecords@1210190008 : Integer;
      LineCount@1210190007 : Integer;
      i@1210190107 : Integer;
      x@1100485007 : Integer;
      BalanceDec@1210190006 : Decimal;
      ProvisionDec@1210190117 : Decimal;
      FinishedDec@1210190011 : Decimal;
      TotContrDec@1210190005 : Decimal;
      CostAmountCostType@1100485004 : ARRAY [5] OF Decimal;
      PostingDate@1210190004 : Date;
      IgnorePurchase@1210190003 : Boolean;
      IgnoreSales@1210190002 : Boolean;
      IgnoreFuturePostings@1100485015 : Boolean;
      IgnoreProjectInventory@1100525007 : Boolean;
      IgnoreServiceOrders@1100529100 : Boolean;
      IgnoreWorkOrders@1100529102 : Boolean;
      RentalUnitRevenues@1210190001 : Decimal;
      Text001@1210190012 : TextConst 'ENU=Project          #1#################\\;NOR=Prosjekt          #1#################\\;SVE=Projekt          #1#################\\';
      Text002@1210190010 : TextConst 'ENU=Service Contract #1#################\\;NOR=Servicekontrakt #1#################\\;SVE=Servicekontrakt  #1#################\\';
      Text003@1210190014 : TextConst 'ENU=Service Order    #1#################\\;NOR=Serviceordre    #1#################\\;SVE=Serviceorder    #1#################\\';
      Text007@1210190092 : TextConst 'ENU=Busy with        #2#################\;NOR=Opptatt med        #2#################\;SVE=Upptagen med     #2#################\';
      Text008@1210190091 : TextConst 'ENU=from             #3################# @4@@@@@@@@@@@@@;NOR=fra             #3################# @4@@@@@@@@@@@@@;SVE=frÜn             #3################# @4@@@@@@@@@@@@@';
      Text009@1210190090 : TextConst 'ENU=Check;NOR=Check;SVE=Check';
      Text010@1210190089 : TextConst 'ENU=Purchase Invoices;NOR=Innkjõpsfakturaer;SVE=Inkîpsfakturor';
      Text011@1210190088 : TextConst 'ENU=Purchase Invoice not Posted, Company %1;NOR=Innkjõpsfakturaen er ikke bokfõrt;SVE=Inkîpsfakturan har inte bokfîrts';
      Text012@1210190087 : TextConst 'ENU=Approval Entries;NOR=Godkjenningstransaksjoner;SVE=GodkÑnnandetransaktioner';
      Text013@1210190086 : TextConst 'ENU=Still Approval Entries present;NOR=Det er fortsatt Godkjenningtransaksjoner igjen;SVE=Det finns fortfarande godkÑnnandetransaktioner kvar';
      Text014@1210190085 : TextConst 'ENU=Purchase Credit Memo;NOR=Kjõpskreditnota;SVE=Inkîpskreditnota';
      Text015@1210190084 : TextConst 'ENU=Purchase Credit Memo not processed, Company %1;NOR=Innkjõpskreditnota er ikke behandlet;SVE=Inkîpskreditnota har inte behandlats';
      Text016@1210190083 : TextConst 'ENU=Sales Invoices;NOR=Salgsfakturaer;SVE=FîrsÑljningsfakturor';
      Text017@1210190082 : TextConst 'ENU=Sales Invoice Not Processed;NOR=Salgsfakturaen er ikke behandlet;SVE=FîrsÑljningsfakturan har inte behandlats';
      Text018@1210190081 : TextConst 'ENU=Sales Credit Memo;NOR=Salgskreditnota;SVE=FîrsÑljningskreditnota';
      Text019@1210190080 : TextConst 'ENU=Sales Credit Memo not processed;NOR=Salgskreditnota er ikke behandlet;SVE=FîrsÑljningskreditnota har inte behandlats';
      Text020@1210190079 : TextConst 'ENU=Hours;NOR="Timer ";SVE=Timmar';
      Text021s@1100525018 : TextConst 'ENU="There are unprocessed hours; Year %1, Week %2,  Employee %3, Company %4"';
      Text022@1210190077 : TextConst 'ENU=Installments;NOR=Betalingsplaner;SVE=Betalplaner';
      Text023@1210190076 : TextConst 'ENU=Installment %1 (amount %2) not fully (%3)  invoiced for principal %4;NOR=Avdrag %1 (belõp %2) ikke fullstendig (%3) fakturert for oppdragsgiver %4;SVE=Betalplan %1 (belopp %2) inte helt (%3) fakturerad fîr huvudkontot %4';
      Text024@1210190075 : TextConst 'ENU=Contract Amount;NOR=Kontraktsbelõp;SVE=Kontraktsbelopp';
      Text025@1210190074 : TextConst 'ENU=Total Contract Amount (%1) differs from Installment Total (%2) for Principal %3;NOR=Totalt kontraktsbelõp (%1) skiller seg fra avdragstotal (%2) for oppdragsgiver %3;SVE=Totalt kontraktsbelopp (%1) skiljer sig frÜn total avbetalning (%2) fîr uppdragsgivaren %3';
      Text025s@1210190105 : TextConst 'ENU=Total Contract Amount (%1) differs from Installment Total (%2) for %3 %4;NOR=Totalt Kontraktsbelõp (%1) skiller seg fra avdragstotal  (%2) for %3 %4;SVE=Totalt kontraktsbelopp (%1) skiljer sig frÜn total avbetalning (%2) fîr %3 %4';
      Text026@1210190073 : TextConst 'ENU=Plot Price (%1) unequals the Plot Installment (%2) for Principal %3;NOR=Tegningsprisen (%1) er ikke lik tegningsavdrag (%2) for oppdragsgiver %3;SVE=Ritningspriset (%1) Ñr inte lika med Ritningsavbetalningen (%2) fîr uppdragsgivaren %3';
      Text027@1210190072 : TextConst 'ENU=Plot Installment (%1) not created for Principal %2;NOR=Tegningsavdrag (%1) er ikke opprettet for oppdragsgiver %2;SVE=Ritningsavbetalning (%1) har inte skapats fîr uppdragsgivaren %2';
      Text028@1210190071 : TextConst 'ENU=Cost Plus Entries;NOR=Selvkosttransaksjoner;SVE=Redovisade sjÑlvkostnader';
      Text029@1210190070 : TextConst 'ENU=Cost Plus Entry Principal %1 Commission %2 Settl.Sheet %3 not invoiced.;NOR=Selvkosttransaksjon for oppdragsgiver %1 provisjon %2 avregningsark %3 er ikke fakturert.;SVE=Redovisad sjÑlvkostnad fîr uppdragsgivare %1 provision %2 avrÑkn.ark %3 har inte fakturerats.';
      Text030@1210190097 : TextConst 'ENU=Cost Plus Entry Service Order %1 not invoiced.;NOR=Selvkosttransaksjon for serviceordre %1 er ikke fakturert.;SVE=Redovisad sjÑlvkostnad fîr serviceorder %1 har inte fakturerats.';
      Text031@1210190068 : TextConst 'ENU=General Journal Entries;NOR=Generelle journaltransaksjoner;SVE=Redovisningsjournaltransaktioner';
      Text032@1210190067 : TextConst 'ENU=Still Gen.Journal Entries Present;NOR="Det finnes fortsatt gen. journaltransaksjoner ";SVE=Det finns fortfarande allm. journaltransaktioner kvar';
      Text033@1210190066 : TextConst 'ENU=Cash;NOR=Cash;SVE=Kassa';
      Text034@1210190065 : TextConst 'ENU=Still Cash Entries present;NOR="Det finnes fortsatt kontanttransaksjoner ";SVE=Det finns fortfarande kontanttransaktioner kvar';
      Text035@1210190064 : TextConst 'ENU=Bank;NOR=Bank;SVE=Bank';
      Text036@1210190063 : TextConst 'ENU=Still Bank Entries present;NOR=Det finnes fortsatt banktransaksjoner;SVE=Det finns fortfarande banktransaktioner kvar';
      Text037@1210190062 : TextConst 'ENU=Purchase Orders;NOR=Bestillinger;SVE=Inkîpsorder';
      Text038@1210190061 : TextConst 'ENU=Purchase Line (%1 %2) not completely delivered, balance %3, Company %4;NOR=Innkjõpsraden (%1 %2) er ikke fullstendig levert, balanse %3;SVE=Inkîpsraden (%1 %2) har inte levererats fullstÑndigt, balans %3';
      Text039@1210190060 : TextConst 'ENU=Purchase Line (%1 %2) not fully invoiced,  balance %3, Company %4;NOR=Innkjõpsraden (%1 %2) er ikke fullstendig fakturert, balanse %3;SVE=Inkîpsraden (%1 %2) har inte fakturerats fullstÑndigt, balans %3';
      Text040@1210190059 : TextConst 'ENU=Post;NOR=Bokfõr;SVE=Post';
      Text041@1210190058 : TextConst 'ENU=Evaluate Result;NOR=Vurder resultat;SVE=UtvÑrdera resultat';
      Text042@1210190057 : TextConst 'ENU=%1 %2 Closing;NOR=%1 %2 lukkes;SVE=%1 %2 stÑngs';
      Text045@1210190054 : TextConst 'ENU=%1 ''%2'' is not closed yet, %3 is not filled;NOR=%1 ''%2'' er ikke stengt enda, og %3 er ikke fylt ut.;SVE=%1 ''%2'' Ñr inte stÑngd Ñnnu, och %3 Ñr inte ifylld.';
      Text046@1210190053 : TextConst 'ENU=%1 ''%2'' is not fully invoiced for %3 ''%4'';NOR=%1 ''%2'' er ikke fullstendig fakturert for %3 ''%4''.;SVE=%1 ''%2'' Ñr inte helt fakturerad fîr %3 ''%4''.';
      Text047@1210190052 : TextConst 'ENU=There are Intercompany entries that must be processed;NOR=Det finnes konserninterne transaksjoner som mÜ behandles;SVE=Det finns koncerninterna transaktioner som mÜste behandlas';
      Text049@1210190113 : TextConst 'ENU=Preclosure Results;NOR=Preliminërt regnskapsresultat;SVE=ProjektvÑrderingar';
      Text050@1210190114 : TextConst 'ENU=Preclosure Result %1 %2;NOR=Preliminërt regnskapsresultat %1 %2;SVE=ProjektvÑrdering %1 %2';
      Text051@1100525001 : TextConst 'ENU=Provision Loss %1 %2;NOR=Tap pÜ avsettning %1 %2;SVE=Fîrlust pÜ avsÑttning %1 %2';
      Text052@1210190120 : TextConst 'ENU="%1 %2 Provision ";NOR=%1 %2 provisjon;SVE="%1 %2 avsÑttning "';
      Text053@1100485001 : TextConst 'ENU=Sub Project %1 is not Administrative Finished;NOR=Underprosjekt %1 er ikke ferdigstilt administrativt.;SVE=Underprojekt %1 har inte slutfîrts administrativt';
      Text054@1100485002 : TextConst 'ENU=Ledger Entry found with Posting Date after %1;NOR=Transaksjon funnet med bokfõringsdato etter %1;SVE=Reskontratransaktion hittades med bokfîringsdatum efter %1';
      RentalUnitCosts@1100529614 : Decimal;
      ShowGenJnl@1100485006 : Boolean;
      Text055@1100485009 : TextConst 'ENU=%1 %2 Book empty lent in;NOR=%1 %2 Bok tom, lÜnes i;SVE=%1 %2 bok Ñr tom, inlÜning';
      Text056@1100485010 : TextConst 'ENU=Still Item Journal Lines Present, Company %1;NOR=Fortsatt artikkeljournalrader tilstede;SVE=Det finns fortfarande artikeljournalrader kvar';
      Text057@1100485012 : TextConst 'ENU=Still chargeable Job Entries present that no Cost Plus is created for;NOR=Fortsatt belastbare jobbtransaksjoner tilstede som ingen selvkoster er opprettet for;SVE=Det finns fortfarande debiterbara jobbtransaktioner kvar som inga redovisade sjÑlvkostnader har skapats fîr';
      Text058@1100485008 : TextConst 'ENU=Extension Contract %1 has status Applied or Offered.;NOR=ETA %1 har status Anvendt eller tilbudt.;SVE=éTA %1 har status TillÑmpat eller Erbjudet.';
      Text061@1100485014 : TextConst 'ENU=Still Bar Code Scanner Entries present;NOR=Fortsatt strekkodetransaksjoner tilstede.;SVE=Det finns fortfarande streckkodstransaktioner kvar';
      PostGrpCount@1100485018 : Integer;
      CustPostGrpCount@1100529602 : Integer;
      VendorPostingGroupTable@1100485020 : ARRAY [50] OF Code[20];
      CustPostingGroupTable@1100529600 : ARRAY [50] OF Code[20];
      PartBalanceTable@1100485019 : ARRAY [50] OF Decimal;
      Text062@1100485021 : TextConst 'ENU=%1 %2 closing, VendPGrp %3;NOR=%1 %2 stenger, lev.gruppe %3;SVE=%1 %2 stÑngs, lev.grupp %3';
      Text063@1100485024 : TextConst 'ENU=Approve Registered Purchase Invoices first.;NOR=Godkjenn registrerte innkjõpsfakturaer fõrst;SVE=GodkÑnn registrerade inkîpsfakturor fîrst';
      Text064@1100485026 : TextConst 'ENU=Sales Orders;NOR=Ordrer;SVE=Fîrs.order';
      Text065@1100485028 : TextConst 'ENU=Sales Order Not Processed;NOR=Salgsordre er ikke behandlet;SVE=FîrsÑljningsorder har inte behandlats';
      Text067@1100525005 : TextConst 'ENU=%1 must be a %2 in %3 %4;NOR=%1 mÜ vëre en %2 i %3 %4;SVE=%1 mÜste vara en %2 i %3 %4';
      Text068@1100525006 : TextConst 'ENU=Still Project Inventory present;NOR=Det finnes fortsatt prosjektlager;SVE=Det finns fortfarande projektlager kvar';
      PartRevenueBalanceTable@1100529603 : ARRAY [50] OF Decimal;
      FiltersOnServEntry@1100525010 : Boolean;
      Text069@1100525011 : TextConst 'ENU=%1 ''%2 %3 '' is not %4.;NOR=%1 ''%2 %3'' er ikke %4.;SVE=%1 ''%2 %3'' Ñr inte %4.';
      Text070@1100525013 : TextConst 'ENU=%1 ''%2'' has option(s) with status %3 or %4;NOR=%1 ''%2'' har alternativ med status %3 eller %4;SVE=%1 ''%2'' har alternativ med status %3 eller %4';
      Text071@1100525014 : TextConst 'ENU=%1 ''%2'' has option(s) where the installments are not created yet;NOR=%1 ''%2'' har alternativ hvor avdragene ikke er opprettet enda.;SVE=%1 ''%2'' har alternativ fîr vilka avbetalningar Ñnnu inte Ñr skapade';
      Text072@1210190048 : TextConst 'ENU=Finalize After Closure Costs;NOR=Ferdigstil etter avviklingskoster;SVE=Slutfîr efter avvecklingskostnader';
      Text073@1210190055 : TextConst 'ENU=Finalize After Closure Costs %1 %2;NOR=Ferdigstill etter avviklingskoster %1 %2;SVE=Slutfîr efter avvecklingskostnader %1 %2';
      PrognosisActive@1210190102 : Boolean;
      Text074@1100528601 : TextConst 'ENU=Still Open Contract Arrangements present;NOR=Det finnes fortsatt Üpne kontraktsvilkÜr;SVE=Det finns fortfarande îppna kontraktsvillkor';
      Text075@1100528602 : TextConst 'ENU=Installment (%1) is not invoiced;NOR=Betalingsplan (%1) er ikke fakturert;SVE=Betalplan (%1) Ñr inte fakturerad';
      Text076@1100528604 : TextConst 'ENU=Sales Invoice Proposals;NOR=Faktureringsforslag;SVE=Faktureringsfîrslag';
      Text077@1100528603 : TextConst 'ENU=Sales Invoice Proposal Not Processed;NOR=Faktureringsforslag ikke behandlet;SVE=Faktureringsfîrslag ej behandlade';
      Text078@1100528605 : TextConst 'ENU=Preclosure Results found with Posting Date after %1;NOR=Prõveregnskapsresultat funnet med bokfõringsdato etter %1;SVE=ProjektvÑrderingar funna med bokfîringdatum efter %1';
      Text079@1100528606 : TextConst 'ENU=Open Preclosure Results found;NOR=èpne prõveregnskapsresultater funnet;SVE=ôppna provredovisningsresultat funna';
      Text080@1100528607 : TextConst 'ENU=Object (%1) not (fully) invoiced;NOR=Objekt (%1) er ikke (fullstendig) bokfõrt;SVE=Objekt (%1) Ñr inte (fullstÑndigt) bokfîrda';
      Text081@1210190119 : TextConst 'ENU=Workdate can not Preceed Ending Date of Contract Period %1;NOR=Arbeidsdato kan ikke komme fõr sluttdato for kontraktsperiode %1;SVE=Arbetsdatum kan inte fîregÜ slutdatum fîr kontraktsperiod %1';
      Text082@1100409000 : TextConst 'ENU=Sales Invoice Not Paid';
      CheckInvoicesPaid@1100409001 : Boolean;
      gPreview@1100528240 : Boolean;
      TempGenJnlLineRec1@1100528241 : TEMPORARY Record 81;
      TempGenJnlLineRec2@1100528242 : TEMPORARY Record 81;
      Text085@1100528245 : TextConst 'ENU=Preview;NOR=ForhÜndsvisning;SVE=Fîrhandsgranskning';
      gvProvisionsCosts@1100528244 : 'Actual Data,Prognosis Data,No Provision';
      gvProvisionsRevenues@1100528243 : 'Actual Data,Prognosis Data,No Provision';
      Text086@1100528246 : TextConst 'ENU=Of %1 ''%2'' is no prognosis for closing present.;NOR=Av %1 ''%2'' er det ingen prognose for stenging tilstede';
      Text087@1100525017 : TextConst 'ENU=Provisions;NOR=Forsyninger;SVE=AvsÑttningar';
      Text088@1100525019 : TextConst 'ENU=Base Service Order %1 is not Administrative Finished';
      gvIgnorePlant@1100525002 : Boolean;
      TextSYM077@1100285500 : TextConst 'ENU=%1 %2 must no be %3;SVE=%1 %2 fÜr inte vara %3';
      Text089@1100528608 : TextConst 'ENU=Service Order %1 not fully (Cost/Revenue) transfered to Project';
      Text090@1100529101 : TextConst 'ENU=%1 %2 (%3) not finished or cancelled;SVE=%1 %2 (%3) Ñr avslutad eller avbruten';
      Text091@1100529103 : TextConst 'ENU=%1 %2 not finished;SVE=%1 %2 Ñr inte avslutad';
      Text092@1100528609 : TextConst 'ENU=%1 of %2 %3 must be %4;SVE=%1 of %2 %3 mÜste vara %4';
      Text093@1100528610 : TextConst 'ENU=%1 of %2 %3 must be set;SVE=%1 av %2 %3 mÜste anges/vÑljas';
      Text094@1100525020 : TextConst 'ENU=The two Service Types stored at %1 %2 must have the same value in Field ''%3''.';
      Text095@1100529606 : TextConst 'ENU=%1 %2 closing, CustPGrp %3';
      CloseServiceOrderViaClosingPeriod@1100528611 : Boolean;
      Text096@1100528613 : TextConst 'ENU=Close Service Order via closing Control Period';
      Text097@1100529607 : TextConst 'ENU=Advance payments not processed';
      Text098@1100528612 : TextConst 'ENU=Open purchase found, show error messages?;SVE=ôppet inkîp funnet, visa felmeddelanden?';
      Text099@1100528614 : TextConst 'ENU=Continue?;SVE=FortsÑtt?';
      FPSLicenseManagement@1100527400 : Codeunit 11229289;
      CloseContract@1100529609 : Boolean;
      Text100@1100529608 : TextConst 'ENU=%1 must have a value in %2 %3.;SVE=%1 mÜste ha ett vÑrde i %2 %3.';
      PostOldPreclosureResult@1100529610 : Boolean;
      RestOfContractServiceContractCtrlPeriod@1100529611 : TEMPORARY Record 11071746;
      CloseServiceRestOfContract@1100529612 : Boolean;
      CorrectOldPreclosureResult@1100529613 : Boolean;
      IgnoreItemJournal@1100528201 : Boolean;
      IgnoreInterCompany@1100528200 : Boolean;

    PROCEDURE SetSelection@11012002(lvType@1210190005 : 'Project,Service Contract,Service Order';lvProj@11012047 : Code[20];lvContr@11012048 : Code[20];lvOrder@11012049 : Code[20];lvPostingDate@1210190004 : Date;lvIgnorePurchase@1210190003 : Boolean;lvIgnoreSales@1210190002 : Boolean;lvIgnoreFuturePostings@1100485001 : Boolean;lvIgnoreServiceOrders@1100529100 : Boolean;lvIgnoreWorkOrders@1100529101 : Boolean;lvPeriod@1210190000 : Text[30];lvExtraTest@1100485000 : Boolean;lvIgnoreItemJournal@1100528200 : Boolean;lvIgnoreInterCompany@1100528201 : Boolean);
    BEGIN
      gvType := lvType;
      gvProj := lvProj;
      gvContr := lvContr;
      gvOrder := lvOrder;
      gvPeriod := lvPeriod;
      gvExtraTest := lvExtraTest;

      //gvExtraTest is the opposite of "Post".
      gvPostProjectService := NOT gvExtraTest;

      UserSetup.GET(USERID);
      GenLedgerSetup.GET;
      ProjSetup.GET;

      IF gvType = gvType::Project THEN BEGIN
        ProjSetup.TESTFIELD("Journal Template Closing Proc.");
        ProjSetup.TESTFIELD("Journal Batch Closing Proc.");
        IF gvPostProjectService THEN
          UserSetup.TESTFIELD("Resp.Pers.Closing.Proc.Project",TRUE);
        PostOldPreclosureResult := ProjSetup."Old Preclosure Result Present";

        ProjRec.GET(gvProj);
        GlobDim1Code := ProjRec."Global Dimension 1 Code";
        ProjRec.TESTFIELD("Project Type");
        ProjRec.TESTFIELD("Main Project");
        ProjTypeRec.GET(ProjRec."Project Type");
        ProjectTypeExtension.GetProjectTypeExtension(ProjTypeRec.Code);
        IF NOT (ProjTypeRec."No Closing Posts Cost Plus Pr." AND
          (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus"))
        THEN
          CheckType(ProjRec."Project Type");
      END;

      IF gvType = gvType::"Service Contract" THEN BEGIN
        ServSetup.GET;
        ServSetup.TESTFIELD("Journal Template Closing Proc.");
        ServSetup.TESTFIELD("Journal Batch Closing Proc.");
        IF gvPostProjectService THEN
          UserSetup.TESTFIELD("Resp.Pers.Closing.Proc.Service",TRUE);
        PostOldPreclosureResult := ServSetup."Old Preclosure Result Present";

        ServContrRec.GET(gvContr);
        GlobDim1Code := ServContrRec."Global Dimension 1 Code";
        ServContrRec.TESTFIELD("Service Type");
        ServContrRec.TESTFIELD("Service Type (Other)");
        CheckType(ServContrRec."Service Type");
        CheckType(ServContrRec."Service Type (Other)");
      END;

      IF gvType = gvType::"Service Order" THEN BEGIN
        ServSetup.GET;
        ServSetup.TESTFIELD("Journal Template Closing Proc.");
        IF gvPostProjectService THEN
          UserSetup.TESTFIELD("Resp.Pers.Closing.Proc.Service",TRUE);

        ServOrderRec.GET(gvOrder);
        GlobDim1Code := ServOrderRec."Global Dimension 1 Code";
        IF ServOrderRec.Status < ServOrderRec.Status::"Administrative Finished" THEN
          ServOrderRec.TESTFIELD(Status, ServOrderRec.Status::"Administrative Finished");

        ServOrderRec.TESTFIELD("Service Type");
        ServOrderRec.TESTFIELD("Service Type (Other)");
        IF CheckServTypePosting(ServOrderRec."Service Type",ServOrderRec."Service Type (Other)") THEN BEGIN
          CheckType(ServOrderRec."Service Type");
          CheckType(ServOrderRec."Service Type (Other)");
        END;
      END;

      PostingDate := lvPostingDate;
      IgnorePurchase := lvIgnorePurchase;
      IgnoreSales := lvIgnoreSales;
      IgnoreFuturePostings := lvIgnoreFuturePostings;
      IgnoreServiceOrders := lvIgnoreServiceOrders;
      IgnoreWorkOrders := lvIgnoreWorkOrders;
      IgnoreItemJournal := lvIgnoreItemJournal;
      IgnoreInterCompany := lvIgnoreInterCompany;
    END;

    [External]
    PROCEDURE SetPreview@1100528240(lvPreview@1100528240 : Boolean);
    BEGIN
      gPreview := lvPreview;
    END;

    [External]
    PROCEDURE SelSelectionProjInvent@1100525016(lvIgnoreProjectInventory@1100525000 : Boolean);
    BEGIN
      IgnoreProjectInventory := lvIgnoreProjectInventory
    END;

    PROCEDURE Check@1();
    VAR
      lProject@1210190003 : Record 11072003;
      DummyRec@1100485000 : Record 11012051;
      lExtContRec@1100485001 : Record 11012004;
      lProjLedgEntry2@1100485002 : Record 11072005;
      OptionRec2@1100525000 : Record 11012502;
      PlantMgtCompRec@1100525001 : Record 11020586;
      ServiceContractCtrlPeriod@1100528601 : Record 11071746;
      ServiceContractArrangement@1100528600 : Record 11071705;
      ContractObjectMaintenance@1100528602 : Record 11071692;
      ServiceOrder@1100525002 : Record 11012823;
      ServiceOrderExtension@1100528603 : Record 11071727;
      IntercompanyRelation@1100525006 : Record 11012057;
      HourAccountingLine@1100525007 : Record 11012039;
      UARHourAccountingLine@1100525003 : Record 11012610;
      SiteMngmntHoursLine@1100528500 : Record 11012361;
      ServiceCategory@1100529600 : Record 11071985;
      ServiceType@1100529601 : Record 11012814;
      TmpServiceType@1100529602 : TEMPORARY Record 11012814;
      CurrTempl@1210190005 : Code[20];
      CurrLino@1210190006 : Integer;
      lSymbrioSetup@1100285502 : Record 11127975;
      lVendorLedgerEntry@1100285505 : Record 25;
      lPurchInvHeader@1100285503 : Record 122;
      lPurchInvLine@1100285500 : Record 123;
      lPurchCrMemoHdr@1100285504 : Record 124;
      lPurchCrMemoLine@1100285501 : Record 125;
      ItemJnlLineRec@1100528200 : Record 83;
    BEGIN
      IF GUIALLOWED THEN BEGIN
        OpenDialogWindow();
        Window.UPDATE(2,Text009);
      END;

      IF gvType = gvType::"Service Contract" THEN BEGIN
        IF NOT (ServContrRec.Status IN [ServContrRec.Status::"Invoicing Allowed", ServContrRec.Status::Expired]) THEN
          AddError(STRSUBSTNO(Text092, ServContrRec.FIELDCAPTION(Status), ServContrRec.TABLECAPTION, ServContrRec."No.", ServContrRec.Status::"Invoicing Allowed"), ServContrRec."No.");
        IF ServContrRec."Starting Date" = 0D THEN
          AddError(STRSUBSTNO(Text093, ServContrRec.FIELDCAPTION("Starting Date"), ServContrRec.TABLECAPTION, ServContrRec."No."), ServContrRec."No.");
      END;

      //Check for not posted purchase invoices
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text010);
      PurchLineRec.RESET;
      PurchLineRec.CHANGECOMPANY(COMPANYNAME);
      PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Invoice);
      ErrorTxt := STRSUBSTNO(Text011,PurchLineRec.CURRENTCOMPANY);
      CheckPurchase;
      IF NOT IgnoreInterCompany THEN BEGIN
        IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
        IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
        IF IntercompanyRelation.FINDSET THEN
          REPEAT
            PurchLineRec.RESET;
            PurchLineRec.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
            PurchLineRec.SETRANGE("Receiving Company",COMPANYNAME);
            PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Invoice);
            ErrorTxt := STRSUBSTNO(Text011,PurchLineRec.CURRENTCOMPANY);
            CheckPurchase;
          UNTIL IntercompanyRelation.NEXT = 0;
      END;

      //Test Approval Entries
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text012);
      LineCount := 1;
      IF gvType = gvType::Project THEN
        ApprovEntryRec.SETRANGE("Project No.",gvProj);
      IF gvType = gvType::"Service Contract" THEN BEGIN
        ApprovEntryRec.SETRANGE("Service Contract No.",gvContr);
        ApprovEntryRec.SETFILTER("Service Order No.", '%1', '');
      END;
      IF gvType = gvType::"Service Order" THEN
        ApprovEntryRec.SETRANGE("Service Order No.",gvOrder);
      IF ApprovEntryRec.FINDSET THEN BEGIN
        NoOfRecords := ApprovEntryRec.COUNT;
        InitDoc;
        REPEAT
          IF DocCode <> ApprovEntryRec."Document No." THEN BEGIN
            DocCode := ApprovEntryRec."Document No.";
            AddError(Text013,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL ApprovEntryRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;

      //Check for not posted Purchase Credit Memos
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text014);
      PurchLineRec.RESET;
      PurchLineRec.CHANGECOMPANY(COMPANYNAME);
      PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::"Credit Memo");
      ErrorTxt := STRSUBSTNO(Text015,PurchLineRec.CURRENTCOMPANY);
      CheckPurchase;
      IF NOT IgnoreInterCompany THEN BEGIN
        IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
        IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
        IF IntercompanyRelation.FINDSET THEN
          REPEAT
            PurchLineRec.RESET;
            PurchLineRec.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
            PurchLineRec.SETRANGE("Receiving Company",COMPANYNAME);
            PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::"Credit Memo");
            ErrorTxt := STRSUBSTNO(Text015,PurchLineRec.CURRENTCOMPANY);
            CheckPurchase;
          UNTIL IntercompanyRelation.NEXT = 0;
      END;

      //Check for not posted Sales Invoice Proposals
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text076);
      SalesLineRec.SETRANGE("Document Type", SalesLineRec."Document Type"::"Invoice Proposal");
      ErrorTxt := Text077;
      CheckSales;

      //Check for not posted Sales Invoices
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text016);
      SalesLineRec.SETRANGE("Document Type", SalesLineRec."Document Type"::Invoice);
      ErrorTxt := Text017;
      CheckSales;

      //Check for Not Posted Sales Credit Memos
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text018);
      SalesLineRec.SETRANGE("Document Type",SalesLineRec."Document Type"::"Credit Memo");
      ErrorTxt := Text019;
      CheckSales;

      //Check for not applied sales invoices
      IF (gvType = gvType::"Service Order") AND (CheckInvoicesPaid) THEN BEGIN
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text016);
        CheckSalesInvoice;
      END;

      //Check not processed hours
      IF (gvType = gvType::Project) OR (gvType = gvType::"Service Order") THEN BEGIN
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text020);
        HourAccountingLine.CHANGECOMPANY(COMPANYNAME);
        CheckUnprocessedHours(HourAccountingLine);
        IF NOT IgnoreInterCompany THEN BEGIN
          IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
          IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
          IF IntercompanyRelation.FINDSET THEN
            REPEAT
              HourAccountingLine.RESET;
              HourAccountingLine.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
              HourAccountingLine.SETRANGE("Receiving Company",COMPANYNAME);
              CheckUnprocessedHours(HourAccountingLine);
            UNTIL IntercompanyRelation.NEXT = 0;
        END;
      END;

      //Check not processed hours UAR
      IF FPSLicenseManagement.LicenseAndReadPermissionForTable(UARHourAccountingLine) THEN BEGIN
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text020 + ' (UAR)');
        UARHourAccountingLine.CHANGECOMPANY(COMPANYNAME);
        CheckUnprocessedHoursUAR(UARHourAccountingLine);
        IF NOT IgnoreInterCompany THEN BEGIN
          IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
          IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
          IF IntercompanyRelation.FINDSET THEN
            REPEAT
              UARHourAccountingLine.RESET;
              UARHourAccountingLine.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
              UARHourAccountingLine.SETRANGE("Receiving Company",COMPANYNAME);
              CheckUnprocessedHoursUAR(UARHourAccountingLine);
            UNTIL IntercompanyRelation.NEXT = 0;
        END;
      END;

      //Check not processed hours Site Management
      IF (gvType = gvType::Project) OR (gvType = gvType::"Service Order") THEN BEGIN
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text020);
        SiteMngmntHoursLine.CHANGECOMPANY(COMPANYNAME);
        CheckUnprocessedHoursSiteMgt(SiteMngmntHoursLine);
        IF NOT IgnoreInterCompany THEN BEGIN
          IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
          IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
          IF IntercompanyRelation.FINDSET THEN
            REPEAT
              SiteMngmntHoursLine.RESET;
              SiteMngmntHoursLine.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
              SiteMngmntHoursLine.SETRANGE("Receiving Company",COMPANYNAME);
              CheckUnprocessedHoursSiteMgt(SiteMngmntHoursLine);
            UNTIL IntercompanyRelation.NEXT = 0;
        END;
      END;

      //Check for Sales Lines, Installments and Contract Amounts
      IF NOT IgnoreSales THEN BEGIN
        CASE gvType OF
          gvType::Project:
            BEGIN
              CheckProjectInvoice;
              CheckRentalSalesOrders;
            END;
          gvType::"Service Contract", gvType::"Service Order":
            CheckServiceInvoice;
        END;
      END;

      //Check present Item Journal Lines
      IF NOT IgnoreItemJournal THEN BEGIN
        IF GUIALLOWED THEN
          Window.UPDATE(3,ItemJnlLineRec.TABLECAPTION);
        ItemJnlLineRec.CHANGECOMPANY(COMPANYNAME);
        CheckItemJnlLines(ItemJnlLineRec);
        IF NOT IgnoreInterCompany THEN BEGIN
          IntercompanyRelation.SETFILTER("Supplying Company",'<>%1',COMPANYNAME);
          IntercompanyRelation.SETRANGE("Receiving Company",COMPANYNAME);
          IF IntercompanyRelation.FINDSET THEN
            REPEAT
              ItemJnlLineRec.RESET;
              ItemJnlLineRec.CHANGECOMPANY(IntercompanyRelation."Supplying Company");
              ItemJnlLineRec.SETRANGE("Receiving Company",COMPANYNAME);
              CheckItemJnlLines(ItemJnlLineRec);
            UNTIL IntercompanyRelation.NEXT = 0;
        END;
      END;

      //Check present Gen.Journal Entries
      IF GUIALLOWED THEN
        Window.UPDATE(3,Text031);
      LineCount := 1;
      CASE gvType OF
        gvType::Project:
          GenJnlLineRec.SETRANGE("Job No.",gvProj);
        gvType::"Service Contract":
          BEGIN
            GenJnlLineRec.SETRANGE("Service Contract No.",gvContr);
            GenJnlLineRec.SETFILTER("Service Order No.", '%1', '');
            GenJnlLineRec.SETFILTER("Posting Date", gvPeriod);
          END;
        gvType::"Service Order":
          GenJnlLineRec.SETRANGE("Service Order No.",gvOrder);
      END;
      IF GenJnlLineRec.FINDSET THEN BEGIN
        NoOfRecords := GenJnlLineRec.COUNT;
        InitDoc;
        REPEAT
          IF DocCode <> GenJnlLineRec."Document No." THEN BEGIN
            DocCode := GenJnlLineRec."Document No.";
            AddError(Text032,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL GenJnlLineRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;

      //Check Bar Code Scanner Entries
      IF gvType IN [gvType::Project, gvType::"Service Order"] THEN BEGIN
        IF gvType = gvType::Project THEN
          ScannerLineRec.SETRANGE("Project No.",gvProj);
        IF gvType = gvType::"Service Order" THEN
          ScannerLineRec.SETRANGE("Service Order",gvOrder);
        ScannerLineRec.SETFILTER(Status, '<>%1', ScannerLineRec.Status::Done);
        IF ScannerLineRec.FINDFIRST THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text061);
          AddError(ErrorTxt,' ');
        END;
      END;

      //Check Purchase Orders
      IF NOT IgnorePurchase THEN BEGIN
        //Check complete delivery and invoicing of Purchase Orders
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text037);
        PurchLineRec.RESET;
        PurchLineRec.CHANGECOMPANY(COMPANYNAME);
        PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Order);
        CheckPurchaseInvoice();
      END;

      IF (gvType = gvType::Project) THEN BEGIN
        PurchSetup.GET;
        IF (PurchSetup."Preregister WIP Purch. Inv.") AND
            (PurchSetup."Preregistration WIP Account" <> '') THEN
        BEGIN
          ProjRec.CALCFIELDS("Preregistration WIP Account");
          IF ProjRec."Preregistration WIP Account" <> '' THEN BEGIN
            ProjRec.CALCFIELDS("Preregistered WIP");
            IF ProjRec."Preregistered WIP" <> 0 THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text063, ProjRec."Preregistered WIP");
              AddError(ErrorTxt,' ');
            END;
          END;
        END;
      END;

      //Check Inter Company Entry
      ICEntryRec.RESET;
      ICEntryRec.SETRANGE("Post in Company", COMPANYNAME);
      IF gvType = gvType::Project THEN
        ICEntryRec.SETRANGE("Project No.",gvProj);
      IF gvType = gvType::"Service Contract" THEN BEGIN
        ICEntryRec.SETRANGE("Service Contract No.",gvContr);
        ICEntryRec.SETFILTER("Service Order No.", '%1', '');
      END;
      IF gvType = gvType::"Service Order" THEN
        ICEntryRec.SETRANGE("Service Order No.",gvOrder);
      IF ICEntryRec.FINDFIRST THEN BEGIN
        ErrorTxt := Text047;
        AddError(ErrorTxt,' ');
      END;

      //Check Plant
      IF ((gvType = gvType::Project) AND (NOT gvIgnorePlant)) OR
         ((gvType = gvType::"Service Order") AND (NOT gvIgnorePlant))
      THEN BEGIN
        PlantMgtCompRec.RESET;
        IF PlantMgtCompRec.FINDSET(FALSE,FALSE) THEN BEGIN
          REPEAT
            PlantLocRec.RESET;
            PlantLocRec.CHANGECOMPANY(PlantMgtCompRec."Plant Company");
            PlantLocRec.SETCURRENTKEY("Company Name", "Project No.", "Service Order No.", "Employee No.");
            IF PlantMgtCompRec."Plant Company" = COMPANYNAME THEN
              PlantLocRec.SETFILTER("Company Name",'%1|%2','',COMPANYNAME)
            ELSE
              PlantLocRec.SETRANGE("Company Name",COMPANYNAME);
            IF gvType = gvType::Project THEN
              PlantLocRec.SETRANGE("Project No.",gvProj)
            ELSE BEGIN
              PlantLocRec.SETRANGE("Project No.",'');
              PlantLocRec.SETRANGE("Service Order No.",gvOrder);
            END;
            IF PlantLocRec.FINDSET THEN BEGIN
              REPEAT
                ErrorTxt := PlantLocRec.CheckFinished(PlantMgtCompRec."Plant Company", FALSE, DummyRec);
                IF ErrorTxt <> '' THEN BEGIN
                  ErrorTxt := COPYSTR(ErrorTxt + ' (' + PlantMgtCompRec."Plant Company" + ')', 1, 250);
                  AddError(ErrorTxt,' ');
                END;
              UNTIL PlantLocRec.NEXT = 0;
            END;

            IF gvType = gvType::Project THEN BEGIN  //* On transportorders no invoice to serviceorder possible
              IF PlantMgtCompRec."Plant Company" = COMPANYNAME THEN BEGIN
                PlantLocRec.RESET;
                PlantLocRec.CHANGECOMPANY(COMPANYNAME);
                ErrorTxt := PlantLocRec.CheckFinishedTransProjLevel(gvProj); //* Same company, see comment in function
                IF ErrorTxt <> '' THEN
                  AddError(ErrorTxt,' ');
              END;
            END;
          UNTIL PlantMgtCompRec.NEXT = 0;
        END;
      END;

      //Check Rental Units
      IF (gvType = gvType::Project) AND (ProjSetup."Rental Units active") THEN BEGIN
        ErrorTxt := '';
        RentalUnitRec.RESET;
        RentalUnitRec.SETRANGE("Project No.",gvProj);
        RentalUnitRec.SETRANGE("Ending Date",0D);
        IF RentalUnitRec.FINDFIRST THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text045, RentalUnitRec.FIELDCAPTION("Rental Unit"),
                                 RentalUnitRec."Rental Unit", RentalUnitRec.FIELDCAPTION("Ending Date"));
        END ELSE BEGIN
          RentalPackageRec.RESET;
          RentalPackageRec.SETRANGE("Project No.",gvProj);
          RentalPackageRec.SETRANGE("Completely Invoiced",FALSE);
          RentalPackageRec.SETFILTER("Customer No.",'<>%1','');
          IF RentalPackageRec.FINDFIRST THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text046,
                                   RentalPackageRec.FIELDCAPTION("Rental Unit"),RentalPackageRec."Rental Unit",
                                   RentalPackageRec.FIELDCAPTION("Customer No."),RentalPackageRec."Customer No.");
          END;
        END;
        IF ErrorTxt <> '' THEN
           AddError(ErrorTxt,' ');
      END;

      IF (gvType = gvType::Project) AND gvExtraTest THEN BEGIN
        //Check Sub Projects
        IF ProjRec."Single/Main/Sub Project" = ProjRec."Single/Main/Sub Project"::"Main Project" THEN BEGIN
          lProject.SETCURRENTKEY("Main Project");
          lProject.SETRANGE("Main Project", gvProj);
          lProject.SETRANGE("Single/Main/Sub Project", ProjRec."Single/Main/Sub Project"::"Sub Project");
          IF lProject.FINDSET THEN
            REPEAT
              IF lProject."Project Status" < lProject."Project Status"::"Administrative Finished" THEN BEGIN
                ErrorTxt := STRSUBSTNO(Text053, lProject."No.");
                AddError(ErrorTxt, ' ');
              END;
            UNTIL lProject.NEXT = 0;
        END;
      END;

      IF (gvType = gvType::Project) THEN BEGIN
        IF NOT IgnoreFuturePostings THEN BEGIN
          //Check Project Ledger Entries after Posting Date
          ErrorTxt := '';
          ProjEntryRec.RESET;
          ProjEntryRec.SETCURRENTKEY("Job No.", "Posting Date");
          ProjEntryRec.SETRANGE("Job No.", gvProj);
          ProjEntryRec.SETFILTER("Posting Date", '>%1', PostingDate);
          IF ProjEntryRec.FINDSET THEN
            REPEAT
              //Check Balance is zero
              lProjLedgEntry2.RESET;
              lProjLedgEntry2.SETCURRENTKEY("Main Project No.","Job No.","Entry Type","Cost Type","Posting Date");
              lProjLedgEntry2.SETRANGE("Main Project No.", ProjRec."Main Project");
              lProjLedgEntry2.SETRANGE("Job No.", gvProj);
              lProjLedgEntry2.SETRANGE("Entry Type", ProjEntryRec."Entry Type");
              lProjLedgEntry2.SETRANGE("Cost Type", ProjEntryRec."Cost Type");
              lProjLedgEntry2.SETFILTER("Posting Date", '>%1', PostingDate);
              lProjLedgEntry2.SETRANGE("Advance Payment", ProjEntryRec."Advance Payment");
              lProjLedgEntry2.CALCSUMS("Total Cost (LCY)", "Closed Costs");
              lProjLedgEntry2.SETRANGE("Cost Type"); //Revenues can be spread over different Cost Types
              lProjLedgEntry2.CALCSUMS("Total Price (LCY)", "Closed Revenues");
              IF (lProjLedgEntry2."Total Cost (LCY)" + lProjLedgEntry2."Closed Costs" <> 0) OR
                 (lProjLedgEntry2."Total Price (LCY)" + lProjLedgEntry2."Closed Revenues" <> 0)
              THEN BEGIN
                ErrorTxt := STRSUBSTNO(Text054, PostingDate);
                AddError(ErrorTxt, ' ');
              END;
            UNTIL (ProjEntryRec.NEXT = 0) OR (ErrorTxt <> '');
        END;

        CheckProjectPreclosureResult(PostingDate);

        IF NOT IgnoreSales THEN BEGIN
          //Check Extension Contract Status
          lExtContRec.RESET;
          lExtContRec.SETRANGE("Project No.", gvProj);
          lExtContRec.SETFILTER(Status, '<%1', lExtContRec.Status::Order);
          IF lExtContRec.FINDFIRST THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text058, lExtContRec."Contract No.");
            AddError(ErrorTxt, ' ');
          END;
          PlotRec.RESET;
          PlotRec.SETRANGE("Project No.",gvProj);
          IF PlotRec.FINDSET THEN BEGIN
            OptionRec.RESET;
            OptionRec.SETRANGE("Project No.", gvProj);
            REPEAT
              OptionRec.SETRANGE("Plot No.", PlotRec."Plot No.");
              OptionRec.SETFILTER(Status, '<%1', OptionRec.Status::Order);
              OptionRec.SETRANGE("Installments Generated");  //* Reset filter
              IF OptionRec.FINDFIRST THEN BEGIN
                OptionRec.Status := OptionRec.Status::Applied;
                OptionRec2.Status := OptionRec.Status::Offered;
                ErrorTxt := STRSUBSTNO(Text070, OptionRec.FIELDCAPTION("Plot No."), OptionRec."Plot No.",
                              OptionRec.Status, OptionRec2.Status);
                AddError(ErrorTxt, ' ');
              END;

              OptionRec.SETFILTER(Status, '%1|%2', OptionRec.Status::Order, OptionRec.Status::Invoice);
              OptionRec.SETRANGE("Installments Generated", FALSE);
              IF OptionRec.FINDFIRST THEN BEGIN
                ErrorTxt := STRSUBSTNO(Text071, OptionRec.FIELDCAPTION("Plot No."), OptionRec."Plot No.");
                AddError(ErrorTxt, ' ');
              END;
            UNTIL PlotRec.NEXT = 0;
          END;
        END;
      END;

      IF (gvType = gvType::"Service Order") THEN BEGIN
        IF NOT IgnoreFuturePostings THEN BEGIN
          ServEntryRec.RESET;
          ServEntryRec.SETCURRENTKEY("Service Order No.");
          ServEntryRec.SETRANGE("Service Order No.", gvOrder);
          ServEntryRec.SETFILTER("Posting Date", '>%1', PostingDate);
          ServEntryRec.SETRANGE("Service Order WIP processed", FALSE);
          IF ServEntryRec.FINDFIRST THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text054, PostingDate);
            AddError(ErrorTxt, ' ');
          END;
        END;

        ServOrderRec.GET(gvOrder);
        IF (ServOrderRec."Base Service Order No." <> ServOrderRec."No.") AND (NOT ServOrderRec."Base Service Order") THEN BEGIN
          IF ServiceOrder.GET(ServOrderRec."Base Service Order No.") THEN BEGIN
            IF ServiceOrder.Status <= ServiceOrder.Status::"Technical Finished" THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text088, ServOrderRec."Base Service Order No.");
              AddError(ErrorTxt, ' ');
            END;
          END;
        END;

        //Check transfer to project
        IF NOT IgnoreSales AND (ServSetup."Service to Project" = ServSetup."Service to Project"::"Transfer Cost and Revenue") THEN BEGIN
          ServiceOrderExtension.GetServOrderExtension(gvOrder);
          IF ServiceOrderExtension."Master Project" <> '' THEN BEGIN
            ServEntryRec.RESET;
            ServEntryRec.SETCURRENTKEY("Service Order No.");
            ServEntryRec.SETRANGE("Service Order No.", gvOrder);
            ServEntryRec.SETRANGE("Service Order WIP processed", FALSE);
            ServEntryRec.SETRANGE("Transfer to Project", ServEntryRec."Transfer to Project"::" ");
            IF NOT ServEntryRec.ISEMPTY THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text089, gvOrder);
              AddError(ErrorTxt, '');
            END;
          END;
        END;

        IF NOT CloseServiceOrderViaClosingPeriod THEN
          IF ServOrderRec."Service Contract No." <> '' THEN BEGIN
            IF NOT ServContrRec.GET(ServOrderRec."Service Contract No.") THEN
              ServContrRec.INIT;
            IF (ServContrRec."Contract Form" <> ServContrRec."Contract Form"::"Framework Contract") AND
               NOT ServContrRec.IsAlwaysCloseOrdersAllowed(ServOrderRec."Service Contract No.", ServOrderRec."Source Type")
            THEN BEGIN
              ServiceContractCtrlPeriod.SETRANGE("Service Contract No.", ServOrderRec."Service Contract No.");
              ServiceContractCtrlPeriod.SETFILTER("Starting Date", '<=%1', ServOrderRec."Service Control Period Date");
              ServiceContractCtrlPeriod.SETFILTER("Ending Date", '>=%1', ServOrderRec."Service Control Period Date");
              IF NOT ServiceContractCtrlPeriod.FINDFIRST OR (ServiceContractCtrlPeriod."Date Finished" = 0D) THEN
                AddError(Text096, ServOrderRec."No.");
            END;
          END;
      END;

      IF (gvType = gvType::"Service Contract") THEN BEGIN
        IF NOT IgnoreFuturePostings AND ((gvContractControlPeriodCode <> '') OR CloseServiceRestOfContract) THEN BEGIN
          ServEntryRec.RESET;
          ServEntryRec.SETCURRENTKEY("Service Contract No.");
          ServEntryRec.SETRANGE("Service Contract No.", gvContr);
          ServEntryRec.SETFILTER("Service Order No.", '%1', '');
          ServEntryRec.SETFILTER("Posting Date", '>%1', PostingDate);
          GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
          ServEntryRec.SETRANGE("Service Control Period Date",
            ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
          ServEntryRec.SETRANGE("Service Contract WIP processed", FALSE);
          IF ServEntryRec.FINDFIRST THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text054, PostingDate);
            AddError(ErrorTxt, ' ');
          END;
        END;

        CheckServicePreclosureResult;

        IF NOT PostOldPreclosureResult THEN BEGIN
          ServEntryRec.RESET;
          ServEntryRec.SETCURRENTKEY("Service Contract No.");
          ServEntryRec.SETRANGE("Service Contract No.", gvContr);
          ServEntryRec.SETFILTER("Service Order No.", '%1', '');
          ServEntryRec.SETRANGE("Service Contract WIP processed", FALSE);
          IF ServContrRec.Status < ServContrRec.Status::Expired THEN BEGIN
            GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
            ServEntryRec.SETRANGE("Service Control Period Date", ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
          END;
          IF ServEntryRec.FINDSET THEN BEGIN
            TmpServiceType.DELETEALL;
            REPEAT
              IF ServiceCategory.GetServiceType(ServEntryRec."Service Contract No.", ServEntryRec."Service Category", ServEntryRec."Additional Cost", ServiceType) THEN
                CheckServiceType(ServiceType.Code, TmpServiceType)
              ELSE
                CheckServiceType(ServContrRec."Service Type (Other)", TmpServiceType);
            UNTIL ServEntryRec.NEXT = 0;
          END;
        END;

        IF ServContrRec.Status < ServContrRec.Status::Expired THEN BEGIN
          GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
          IF WORKDATE <= ServiceContractCtrlPeriod."Ending Date" THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text081, ServiceContractCtrlPeriod.Code);
            AddError(ErrorTxt, ' ');
          END;

          ContractObjectMaintenance.SETRANGE("Service Contract No.", gvContr);
          IF ContractObjectMaintenance.FINDSET THEN
            REPEAT
              ContractObjectMaintenance.UpdateServiceContractArr(ServiceContractCtrlPeriod."Ending Date", TRUE, FALSE, FALSE);
            UNTIL ContractObjectMaintenance.NEXT = 0;

          ServiceContractArrangement.SETRANGE("Service Contract No.", gvContr);
          ServiceContractArrangement.SETRANGE("Theoretical Maintenance Date",
            ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
          ServiceContractArrangement.SETRANGE("Service Order No.", '');
          ServiceContractArrangement.SETRANGE(Cancelled, FALSE);
          IF NOT ServiceContractArrangement.ISEMPTY THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text074, PostingDate);
            AddError(ErrorTxt, ' ');
          END;
        END;
      END;

      //Check open serviceorders
      IF (gvType = gvType::Project) AND (NOT IgnoreServiceOrders) THEN
        CheckServiceOrders;

      //Check open workorders
      IF (gvType = gvType::"Service Order") AND (NOT IgnoreWorkOrders) THEN
        CheckWorkOrders;

      //Check project inventory is zero
      IF (gvType = gvType::Project) AND (NOT IgnoreProjectInventory) THEN
        CheckProjectInventory();

      //Check project prognosis
      IF (gvType = gvType::Project) AND
         ((gvProvisionsCosts=gvProvisionsCosts::"Prognosis Data") OR (gvProvisionsRevenues=gvProvisionsRevenues::"Prognosis Data")) THEN
      BEGIN
        SetFiltersProjRec;
        IF NOT PrognosisActive THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text086, ProjRec.TABLECAPTION,ProjRec."No.");
          AddError(ErrorTxt, ' ');
        END;
      END;

      //Check Advance Payment balance
      IF (gvType = gvType::Project) THEN BEGIN
        ErrorTxt := '';
        lProjLedgEntry2.RESET;
        lProjLedgEntry2.SETRANGE("Job No.", gvProj);
        lProjLedgEntry2.SETRANGE("Entry Type", lProjLedgEntry2."Entry Type"::Sale);
        lProjLedgEntry2.SETRANGE("Advance Payment", TRUE);
        lProjLedgEntry2.CALCSUMS("Total Price (LCY)", "Closed Revenues");
        IF lProjLedgEntry2."Total Price (LCY)" + lProjLedgEntry2."Closed Revenues" <> 0 THEN BEGIN
          ErrorTxt := Text097;
          AddError(ErrorTxt, ' ');
        END;
      END;


      //>>SYM077
      //check posted purchase documents are not on hold
      IF lSymbrioSetup.READPERMISSION THEN
        IF lSymbrioSetup.GET THEN BEGIN
          IF (gvType = gvType::Project) AND (lSymbrioSetup."Path Invoice Import" <> '') THEN BEGIN
            ErrorTxt := '';
            lVendorLedgerEntry.SETFILTER("On Hold",'<>%1','');
            lVendorLedgerEntry.SETRANGE(Open,TRUE);
            lVendorLedgerEntry.SETFILTER("Document Type",'%1|%2',lVendorLedgerEntry."Document Type"::Invoice,lVendorLedgerEntry."Document Type"::"Credit Memo");
            IF lVendorLedgerEntry.FINDSET(FALSE) THEN
            REPEAT
              CASE lVendorLedgerEntry."Document Type" OF
                lVendorLedgerEntry."Document Type"::Invoice:
                  BEGIN
                    lPurchInvLine.SETRANGE("Document No.",lVendorLedgerEntry."Document No.");
                    IF lPurchInvLine.FINDSET(FALSE) THEN
                    REPEAT
                      IF (lPurchInvLine."Job No." = gvProj) AND (lPurchInvHeader.GET(lVendorLedgerEntry."Document No.")) THEN BEGIN
                        ErrorTxt := STRSUBSTNO(TextSYM077, lPurchInvHeader.TABLECAPTION, lPurchInvHeader."No.",lVendorLedgerEntry.FIELDCAPTION(lVendorLedgerEntry."On Hold"));
                        AddError(ErrorTxt, ' ');
                      END;
                    UNTIL (lPurchInvLine.NEXT=0) OR (ErrorTxt <> '');
                  END;
                lVendorLedgerEntry."Document Type"::"Credit Memo":
                  BEGIN
                    lPurchCrMemoLine.SETRANGE("Document No.",lVendorLedgerEntry."Document No.");
                    IF lPurchCrMemoLine.FINDSET(FALSE) THEN
                    REPEAT
                      IF (lPurchCrMemoLine."Job No." = gvProj) AND (lPurchCrMemoHdr.GET(lVendorLedgerEntry."Document No.")) THEN BEGIN
                        ErrorTxt := STRSUBSTNO(TextSYM077, lPurchCrMemoHdr.TABLECAPTION, lPurchCrMemoHdr."No.",lVendorLedgerEntry.FIELDCAPTION(lVendorLedgerEntry."On Hold"));
                        AddError(ErrorTxt, ' ');
                      END;
                    UNTIL (lPurchCrMemoLine.NEXT=0) OR (ErrorTxt <> '');
                  END;
              END;
            UNTIL (lVendorLedgerEntry.NEXT=0) OR (ErrorTxt <> '');

          END;
        END;
      //<<SYM077

      IF GUIALLOWED THEN
        Window.UPDATE(3,'');
    END;

    LOCAL PROCEDURE OpenDialogWindow@1100528606();
    BEGIN
      IF NOT GUIALLOWED THEN
        EXIT;
      IF gvType = gvType::Project THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1,gvProj);
      END;
      IF gvType = gvType::"Service Contract" THEN BEGIN
        Window.OPEN(Text002 + Text007 + Text008);
        Window.UPDATE(1,gvContr);
      END;
      IF gvType = gvType::"Service Order" THEN BEGIN
        Window.OPEN(Text003 + Text007 + Text008);
        Window.UPDATE(1,gvOrder);
      END;
    END;

    PROCEDURE Post@2();
    VAR
      CostTypeNo@1100485000 : Integer;
      TotCost@1100485001 : Decimal;
      RevAmountCostType@1100485002 : ARRAY [5] OF Decimal;
      TotRevAmount@1100485003 : Decimal;
      lContractAmount@1210190000 : Decimal;
      OpenInstallmentAmount@1100409000 : Decimal;
      CostType@1100485004 : Integer;
      lCount@1100485005 : Integer;
      PrognosisDec@1100409001 : Decimal;
      RoughPrognosis@1100409002 : Boolean;
      CostPlusExtensionRevenues@1100525005 : Decimal;
      ServiceContractCtrlPeriod@1100528200 : Record 11071746;
      ServiceCategory@1100529600 : Record 11071985;
      ServiceType@1100529601 : Record 11012814;
    BEGIN
      IF ErrorsFound THEN
        EXIT;

      IF GUIALLOWED THEN BEGIN
        IF gPreview THEN
          Window.UPDATE(2,Text085)
        ELSE
          Window.UPDATE(2,Text040);

        Window.UPDATE(3,Text041);
      END;

      GenLedgerSetup.GET;

      //Check if Ledger Entries have to be made
      CASE gvType OF
        gvType::Project:
          BEGIN
            IF ProjTypeRec."No Closing Posts Cost Plus Pr." AND
              (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN
            BEGIN
              UpdateProjectStatus;
              UpdatePlantLocStatus;
              IF NOT ProjSetup."Provisions at Closure" THEN
                ClosePurchaseOrderControl;
              EXIT;
            END ELSE BEGIN
              CreateCostControl.RUN(ProjRec);
              COMMIT;
            END;
          END;
        gvType::"Service Order":
          IF ServTypeRec."No Closing Ledger Entries" THEN BEGIN
            UpdateServiceOrderSatus;
            UpdatePlantLocStatus;
            ClosePurchaseOrderControl;
            EXIT;
          END;
      END;

      IF (gvType = gvType::Project) AND (ProjSetup."Provisions at Closure") THEN
        SetFiltersProjRec;

      //Locking
      TableLocking;
      //
      //InitTemplateAndBatch
      InitTemplateAndBatch;
      //

      //******************************************************** PROJECT *****************************************************************
      IF gvType = gvType::Project THEN BEGIN
        CostTypeContrRec.SETRANGE("Project No.",gvProj);
        CostTypeContrRec.SETFILTER("Project Filter", gvProj);

        IF (ProjSetup."Provisions at Closure") THEN
          SetFiltersCostTypeContrRec;

        FOR i := 1 TO 9 DO BEGIN
          BalanceDec := 0;
          ProvisionDec := 0;
          CASE i OF
            1:BEGIN
                CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Labor);
                CalcCostAmounts;
              END;
            2:BEGIN
                CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Material);
                CalcCostAmounts;
              END;
            3:BEGIN
                CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Subcontracting);
                CalcCostAmounts;
              END;
            4:BEGIN
                CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Plant);
                CalcCostAmounts;
              END;
            5:BEGIN
                CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Sundry);
                CalcCostAmounts;
              END;
            6:BEGIN
                ProjRec.SETFILTER("Project Filter", gvProj);
                ProjRec.CALCFIELDS(Revenues,"Project Contract Amount","Extension Contract Amount","Options Contract Amount");
                IF ProjSetup."Provisions at Closure" AND
                  (gvProvisionsRevenues <> gvProvisionsRevenues::"No Provision")
                THEN BEGIN
                  CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Revenue);
                  CostTypeContrRec.FINDFIRST;
                  CostTypeContrRec.CALCFIELDS("Prognosis Revenues");

                  lContractAmount := (ProjRec."Project Contract Amount" +
                                      ProjRec."Extension Contract Amount" +
                                      ProjRec."Options Contract Amount");

                  IF PrognosisActive AND (gvProvisionsRevenues = gvProvisionsRevenues::"Prognosis Data") THEN BEGIN
                    RoughPrognosis := FALSE;
                    IF ((PrognosisRec."Rough Prognosis Total Revenues" <> 0) OR
                               (PrognosisRec."Rough Prognosis Total Cost" <> 0))
                    THEN BEGIN
                      ProjTypeRec.TESTFIELD("Cost. Acc Rough Prognosis Cost");
                      ProjTypeRec.TESTFIELD("Prov. Acc Rough Prognosis Cost");
                      PrognosisDec := PrognosisRec."Rough Prognosis Total Revenues";
                      ProvisionDec := (PrognosisDec - ProjRec.Revenues) * -1;
                      RoughPrognosis := TRUE;
                    END ELSE BEGIN
                      PrognosisDec := CostTypeContrRec."Prognosis Revenues" + PrognosisRec.GetRevenueProjectInvoiced;
                      ProvisionDec := (PrognosisDec - ProjRec.Revenues) * -1;
                    END;
                  END ELSE BEGIN
                    IF CheckAllocationRevenues(lContractAmount, OpenInstallmentAmount) THEN
                      ProvisionDec := OpenInstallmentAmount * -1
                    ELSE
                      IF ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Fixed Price" THEN  BEGIN
                        CostPlusExtensionRevenues := 0;
                        ExtensionRec.SETRANGE("Project No.",gvProj);
                        ExtensionRec.SETFILTER(
                          Status,'>=%1&<%2',  ExtensionRec.Status::Order,ExtensionRec.Status::Expired);
                        ExtensionRec.SETRANGE("Settlement Method", ExtensionRec."Settlement Method"::"Cost Plus");
                        IF ExtensionRec.FINDSET THEN
                          REPEAT
                            ExtensionRec.CALCFIELDS(Revenues);
                            CostPlusExtensionRevenues := CostPlusExtensionRevenues + ExtensionRec.Revenues;
                          UNTIL ExtensionRec.NEXT = 0;
                        ProvisionDec := (lContractAmount + CostPlusExtensionRevenues - ProjRec.Revenues) * -1;
                      END;
                  END;

                END;

                IF ProjSetup."Rental Units active" THEN
                  RentalUnitRevenues := CalculateRentalUnitRevenues;

                ProjRec.SETRANGE("Rental Unit Filter", '');
                FOR CostType := ProjRec."Original Cost Type Filter"::Labor TO ProjRec."Original Cost Type Filter"::Sundry DO BEGIN
                  ProjRec.SETRANGE("Original Cost Type Filter", CostType);
                  ProjRec.CALCFIELDS(Revenues);
                  BalanceDec := -ProjRec.Revenues;

                  SearchProjExeptionbyCustPstGrp(CostType);
                  IF CustPostGrpCount > 0 THEN
                    FOR lCount := 1 TO CustPostGrpCount DO
                      BalanceDec -= PartRevenueBalanceTable[lCount];

                  IF BalanceDec <> 0 THEN BEGIN
                    FillGenJnlLine(1, CostType);
                    FillJobJnlLine;
                    NextLineNo := NextLineNo + 10000;
                  END;

                  IF CustPostGrpCount > 0 THEN
                    FOR lCount := 1 TO CustPostGrpCount DO
                      IF LedgerbyProjTypeCustGr.GET(ProjTypeRec.Code, CustPostingGroupTable[lCount]) THEN BEGIN
                        BalanceDec := PartRevenueBalanceTable[lCount];
                        FillGenJnlLine(9, CostType);
                        FillJobJnlLine;
                        NextLineNo := NextLineNo + 10000;
                      END;
                END;
                ProjRec.SETFILTER("Original Cost Type Filter", '%1|%2', ProjRec."Original Cost Type Filter"::" ",
                                                                     ProjRec."Original Cost Type Filter"::Revenues);
                ProjRec.CALCFIELDS(Revenues);
                BalanceDec := -ProjRec.Revenues;

                SearchProjExeptionbyCustPstGrp(0);
              END;
            7:BEGIN
                BalanceDec := 0;
                IF ProjSetup."Rental Units active" THEN
                  BalanceDec := RentalUnitRevenues;
              END;
            8:BEGIN
                ProvisionDec := 0;
                IF (ProjSetup."Provisions at Closure") AND
                   (PrognosisActive) AND
                   (RoughPrognosis) AND
                   (gvProvisionsCosts = gvProvisionsCosts::"Prognosis Data")
                THEN BEGIN
                  ProjTypeRec.TESTFIELD("Cost. Acc Rough Prognosis Cost");
                  ProjTypeRec.TESTFIELD("Prov. Acc Rough Prognosis Cost");
                  ProjRec.SETFILTER("Project Filter", gvProj);
                  ProjRec.CALCFIELDS("Actual Costs");
                  ProvisionDec := PrognosisRec."Rough Prognosis Total Cost" - ProjRec."Actual Costs";

                END;
              END;
            9:BEGIN
                BalanceDec := 0;
                IF ProjSetup."Rental Units active" THEN
                  BalanceDec := RentalUnitCosts;
              END;
          END;

          IF (PostGrpCount > 0) AND (i < 6) THEN BEGIN
          //prevent double posting
            FOR lCount := 1 TO PostGrpCount DO
              BalanceDec := BalanceDec - PartBalanceTable[lCount];
          END;

          IF (CustPostGrpCount > 0) AND (i = 6) THEN
            FOR lCount := 1 TO CustPostGrpCount DO
              BalanceDec -= PartRevenueBalanceTable[lCount];

          IF BalanceDec <> 0 THEN BEGIN
            FillGenJnlLine(1, 0);
            FillJobJnlLine;
            NextLineNo := NextLineNo + 10000;
          END;

          IF ProvisionDec <> 0 THEN BEGIN
            FillGenJnlLine(2, 0);
            FillJobJnlLine;
            NextLineNo := NextLineNo + 10000;
          END;

          IF (PostGrpCount > 0) AND (i < 6) THEN BEGIN
            //divergent posting per vendor posting group
            FOR lCount := 1 TO PostGrpCount DO BEGIN
              IF VendorPostingGrpSettingsRec.GET(ProjTypeRec.Code, VendorPostingGroupTable[lCount]) THEN BEGIN
                BalanceDec := PartBalanceTable[lCount];
                FillGenJnlLine(5, 0);
                FillJobJnlLine;
                NextLineNo := NextLineNo + 10000;
              END;
            END;
          END;

          IF (CustPostGrpCount > 0) AND (i = 6) THEN
            FOR lCount := 1 TO CustPostGrpCount DO
              IF LedgerbyProjTypeCustGr.GET(ProjTypeRec.Code, CustPostingGroupTable[lCount]) THEN BEGIN
                BalanceDec := PartRevenueBalanceTable[lCount];
                FillGenJnlLine(9, 0);
                FillJobJnlLine;
                NextLineNo := NextLineNo + 10000;
              END;
        END;

        //Reverse Preclosure Results and Provisions
        ReversePreclosureResults;

        //Divide Revenues Fixed Price over Cost Types
        IF (ProjRec.Revenues <> 0) AND
           (ProjTypeRec."Revenue Division based on" <> ProjTypeRec."Revenue Division based on"::None) THEN
        BEGIN
          TotCost := 0;
          TotRevAmount := 0;
          FOR CostTypeNo := 1 TO 5 DO BEGIN
            IF ProjTypeRec."Revenue Division based on" = ProjTypeRec."Revenue Division based on"::Budget THEN BEGIN
              //IF based on budget then recalculate CostAmountCostType
              BudgetLine.SETCURRENTKEY("Project No.","Extension Contract Status","Cost Type");
              BudgetLine.SETRANGE("Project No.", gvProj);
              BudgetLine.SETRANGE("Cost Type", CostTypeNo - 1);
              BudgetLine.SETFILTER("Extension Contract Status", '%1|>=%2&<%3',
                BudgetLine."Extension Contract Status"::"Not Applicable",
                BudgetLine."Extension Contract Status"::Order,
                BudgetLine."Extension Contract Status"::Expired);
              BudgetLine.CALCSUMS("Amount (LCY)");
              CostAmountCostType[CostTypeNo] := BudgetLine."Amount (LCY)";
            END;
            TotCost := TotCost + CostAmountCostType[CostTypeNo];
          END;

          FOR CostTypeNo := 1 TO 5 DO BEGIN
            IF TotCost <> 0 THEN
              RevAmountCostType[CostTypeNo] := ROUND(CostAmountCostType[CostTypeNo] / TotCost * ProjRec.Revenues)
            ELSE
              RevAmountCostType[CostTypeNo] := 0;
            TotRevAmount := TotRevAmount + RevAmountCostType[CostTypeNo];
          END;
          FOR CostTypeNo := 1 TO 5 DO BEGIN
            IF (TotRevAmount <> ProjRec.Revenues) AND (RevAmountCostType[CostTypeNo] <> 0) THEN BEGIN
              RevAmountCostType[CostTypeNo] := RevAmountCostType[CostTypeNo] - TotRevAmount + ProjRec.Revenues;
              TotRevAmount := ProjRec.Revenues;
            END;
            BalanceDec := -RevAmountCostType[CostTypeNo];
            i := CostTypeNo;
            FillGenJnlLine(3, 0);
            NextLineNo := NextLineNo + 10000;
          END;
          BalanceDec := ProjRec.Revenues;
          i := 6;
          FillGenJnlLine(3, 0);
          NextLineNo := NextLineNo + 10000;
        END;
      END;

      //******************************************************** SERVICE *****************************************************************
      IF (gvType = gvType::"Service Contract") OR (gvType = gvType::"Service Order") THEN BEGIN
        WITH ServEntryRec DO BEGIN
          FOR x := 1 TO 2 DO BEGIN
            RESET;
            IF FiltersOnServEntry = TRUE THEN BEGIN
              ServEntryRec.COPY(gvServEntryRec);
              IF gvServEntryRec.GETFILTER("Additional Cost") <> '' THEN
                IF gvServEntryRec.GETRANGEMAX("Additional Cost") = TRUE THEN
                  x := 2;  //skip x=1
              SETRANGE("Service Contract WIP processed", FALSE);
              SETRANGE("Service Order WIP processed", FALSE);
            END;
            IF gvType = gvType::"Service Contract" THEN BEGIN
              SETCURRENTKEY("Service Contract No.");
              SETRANGE("Service Contract No.", gvContr);
              SETFILTER("Service Order No.", '%1', '');
              SETRANGE("Service Contract WIP processed", FALSE);
              IF ServContrRec.Status < ServContrRec.Status::Expired THEN BEGIN
                GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
                SETRANGE("Service Control Period Date",
                  ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
              END;

              IF x = 1 THEN BEGIN
                SETRANGE("Additional Cost", FALSE);
                IF PostOldPreclosureResult THEN
                  CheckType(ServContrRec."Service Type")
                ELSE
                  IF FINDSET THEN
                    REPEAT
                      IF ServiceCategory.GetServiceType("Service Contract No.", "Service Category", FALSE, ServiceType) THEN
                        CheckType(ServiceType.Code)
                      ELSE
                        CheckType(ServContrRec."Service Type");
                    UNTIL NEXT = 0;
              END ELSE BEGIN
                SETRANGE("Additional Cost", TRUE);
                IF PostOldPreclosureResult THEN
                  CheckType(ServContrRec."Service Type")
                ELSE
                  IF FINDSET THEN
                    REPEAT
                      IF ServiceCategory.GetServiceType("Service Contract No.", "Service Category", TRUE, ServiceType) THEN
                        CheckType(ServiceType.Code)
                      ELSE
                        CheckType(ServContrRec."Service Type (Other)");
                    UNTIL NEXT = 0;
              END;
            END;
            IF gvType = gvType::"Service Order" THEN BEGIN
              SETCURRENTKEY("Service Order No.");
              SETRANGE("Service Order No.", gvOrder);
              SETRANGE("Service Order WIP processed", FALSE);
              IF x = 1 THEN BEGIN
                SETRANGE("Additional Cost", FALSE);
                CheckType(ServOrderRec."Service Type");
              END ELSE BEGIN
                SETRANGE("Additional Cost", TRUE);
                CheckType(ServOrderRec."Service Type (Other)");
              END;
            END;
            FOR i := 1 TO 6 DO BEGIN

              CASE i OF
                1: SETRANGE("Cost Type", "Cost Type"::Labor);
                2: SETRANGE("Cost Type", "Cost Type"::Material);
                3: SETRANGE("Cost Type", "Cost Type"::Subcontracting);
                4: SETRANGE("Cost Type", "Cost Type"::Plant);
                5: SETRANGE("Cost Type", "Cost Type"::Sundry);
                6: SETRANGE("Cost Type");
              END;

              IF i = 6 THEN BEGIN
                //revenue splitted
                IF gvType <> gvType::"Service Contract" THEN BEGIN
                  FOR CostType := "Original Cost Type"::Labor TO "Original Cost Type"::Sundry DO BEGIN
                    SETRANGE("Original Cost Type", CostType);
                    SearchServExeptionbyCustPstGrp(CostType);

                    BalanceDec := 0;
                    TmpServiceEntryRec.DELETEALL;
                    IF FINDSET THEN
                      REPEAT
                        IF NOT TmpServiceEntryPostGroup.GET("Entry No.") THEN BEGIN
                          BalanceDec := BalanceDec - "Total Revenue (LCY)";
                          TmpServiceEntryRec := ServEntryRec;
                          TmpServiceEntryRec.INSERT(FALSE);
                        END;
                      UNTIL NEXT = 0;

                    IF BalanceDec <> 0 THEN BEGIN
                      FillGenJnlLine(1, CostType);
                      GenJnlLineRec."Additional Cost (Service)" := (x=2);
                      FillServJnlLine;
                      NextLineNo := NextLineNo + 10000;
                    END;

                    IF CustPostGrpCount > 0 THEN BEGIN
                      FOR lCount := 1 TO CustPostGrpCount DO
                        IF LedgerbyServTypeCustGr.GET(ServTypeRec.Code, CustPostingGroupTable[lCount]) THEN BEGIN
                          TmpServiceEntryPostGroup.SETRANGE("Customer Posting Group", LedgerbyServTypeCustGr."Customer Posting Group No.");
                          IF TmpServiceEntryPostGroup.FINDSET THEN
                            REPEAT
                              TmpServiceEntryRec := TmpServiceEntryPostGroup;
                              TmpServiceEntryRec.INSERT;
                            UNTIL TmpServiceEntryPostGroup.NEXT = 0;
                          BalanceDec := PartRevenueBalanceTable[lCount];
                          FillGenJnlLine(9, CostType);
                          GenJnlLineRec."Additional Cost (Service)" := (x=2);
                          FillServJnlLine;
                          NextLineNo := NextLineNo + 10000;
                        END;
                      TmpServiceEntryPostGroup.RESET;
                      TmpServiceEntryPostGroup.DELETEALL;
                      TmpServiceEntryRec.DELETEALL;
                    END;
                  END;
                  SearchServExeptionbyCustPstGrp(0);

                  BalanceDec := 0;
                  SETFILTER("Original Cost Type", '%1|%2', "Original Cost Type"::" ", "Original Cost Type"::Revenues);
                  TmpServiceEntryRec.DELETEALL;
                  IF FINDSET THEN
                    REPEAT
                      IF NOT TmpServiceEntryPostGroup.GET("Entry No.") THEN BEGIN
                        BalanceDec := BalanceDec - "Total Revenue (LCY)";
                        TmpServiceEntryRec := ServEntryRec;
                        TmpServiceEntryRec.INSERT(FALSE);
                      END;
                    UNTIL NEXT = 0;
                END ELSE BEGIN
                  //Don't split revenue and post per entry for Service Contract
                  TmpServiceEntryRec.DELETEALL;
                  IF FINDSET THEN
                    REPEAT
                      BalanceDec := -"Total Revenue (LCY)";
                      TmpServiceEntryRec := ServEntryRec;
                      TmpServiceEntryRec.INSERT(FALSE);
                      IF BalanceDec <> 0 THEN BEGIN
                        IF NOT LedgerbyServTypeCustGr.GET(ServTypeRec.Code, "Customer Posting Group") THEN
                          CLEAR(LedgerbyServTypeCustGr);
                        IF (LedgerbyServTypeCustGr."Closed Revenue Credit" = '') AND (LedgerbyServTypeCustGr."Closed Revenue Debit" = '') THEN
                          FillGenJnlLine(1, 0)
                        ELSE
                          FillGenJnlLine(9, 0);
                        GenJnlLineRec."Additional Cost (Service)" := (x=2);
                        FillServJnlLine;
                        NextLineNo := NextLineNo + 10000;
                      END;
                    UNTIL NEXT = 0;
                    BalanceDec := 0;
                END;
              END ELSE BEGIN
                //costs
                BalanceDec := 0;
                CLEAR(PartBalanceTable);
                CLEAR(VendorPostingGroupTable);
                PostGrpCount := 0;

                TmpServiceEntryRec.DELETEALL;
                IF FINDSET THEN BEGIN
                  REPEAT
                    BalanceDec := BalanceDec + "Total Cost (LCY)";
                    TmpServiceEntryRec := ServEntryRec;
                    TmpServiceEntryRec.INSERT(FALSE);
                  UNTIL NEXT = 0;
                  SearchServExeptionbyVendPstGrp;
                END;
              END;

              IF (PostGrpCount > 0) AND (i < 6) THEN BEGIN
                //prevent double posting
                FOR lCount := 1 TO PostGrpCount DO
                  BalanceDec := BalanceDec - PartBalanceTable[lCount];
              END;

              IF BalanceDec <> 0 THEN BEGIN
                FillGenJnlLine(1, 0);
                GenJnlLineRec."Additional Cost (Service)" := (x=2);
                FillServJnlLine;
                NextLineNo := NextLineNo + 10000;
              END;

              IF (PostGrpCount > 0) AND (i < 6) THEN BEGIN
                //divergent posting per vendor posting group
                FOR lCount := 1 TO PostGrpCount DO BEGIN
                  IF ServVendPostGrpSettingsRec.GET(ServTypeRec.Code, VendorPostingGroupTable[lCount]) THEN BEGIN
                    BalanceDec := PartBalanceTable[lCount];
                    FillGenJnlLine(5, 0);
                    GenJnlLineRec."Additional Cost (Service)" := (x=2);
                    FillServJnlLine;
                    NextLineNo := NextLineNo + 10000;
                  END;
                END;
              END;

              IF (CustPostGrpCount > 0) AND (i = 6) THEN BEGIN
                FOR lCount := 1 TO CustPostGrpCount DO
                  IF LedgerbyServTypeCustGr.GET(ServTypeRec.Code, CustPostingGroupTable[lCount]) THEN BEGIN
                    TmpServiceEntryPostGroup.SETRANGE("Customer Posting Group", LedgerbyServTypeCustGr."Customer Posting Group No.");
                    IF TmpServiceEntryPostGroup.FINDSET THEN
                      REPEAT
                        TmpServiceEntryRec := TmpServiceEntryPostGroup;
                        TmpServiceEntryRec.INSERT;
                      UNTIL TmpServiceEntryPostGroup.NEXT = 0;
                    BalanceDec := PartRevenueBalanceTable[lCount];
                    FillGenJnlLine(9, 0);
                    GenJnlLineRec."Additional Cost (Service)" := (x=2);
                    FillServJnlLine;
                    NextLineNo := NextLineNo + 10000;
                  END;
                TmpServiceEntryPostGroup.RESET;
                TmpServiceEntryPostGroup.DELETEALL;
                TmpServiceEntryRec.DELETEALL;
              END;
            END;

            IF (gvType = gvType::"Service Contract") AND
               (x=2) THEN
            BEGIN
              ReverseServicePreclosureResults;
              IF NOT gPreview THEN BEGIN
                IF ServContrRec.Status < ServContrRec.Status::Expired THEN BEGIN
                  IF NOT CloseServiceRestOfContract THEN BEGIN
                    ServiceContractCtrlPeriod.GET(gvContr, gvContractControlPeriodCode);
                    ServiceContractCtrlPeriod."Date Finished" := TODAY;
                    ServiceContractCtrlPeriod.MODIFY;
                  END;
                  UpdateServicePrognosisLine(gvContr, TRUE, gvContractControlPeriodCode);
                END ELSE BEGIN
                  ServiceContractCtrlPeriod.SETRANGE("Service Contract No.", gvContr);
                  ServiceContractCtrlPeriod.SETRANGE("Date Finished", 0D);
                  ServiceContractCtrlPeriod.MODIFYALL("Date Finished", TODAY);
                  UpdateServicePrognosisLine(gvContr, FALSE, '');
                END;
              END;
            END;

            SETRANGE("Cost Type");
            SETRANGE("Original Cost Type");
            IF PostEntries THEN BEGIN
              IF gvType = gvType::"Service Contract" THEN
                MODIFYALL("Service Contract WIP processed", TRUE);
              IF gvType = gvType::"Service Order" THEN
                MODIFYALL("Service Order WIP processed", TRUE);
            END;

            IF FiltersOnServEntry = TRUE THEN BEGIN
              IF gvServEntryRec.GETFILTER("Additional Cost") <> '' THEN BEGIN
                IF gvServEntryRec.GETRANGEMAX("Additional Cost") = FALSE THEN
                  x := x+1;  //skip x=2
              END;
            END;
          END;
        END;
      END;

      //Finish setting status
      IF gvType = gvType::Project THEN BEGIN
        UpdateProjectStatus;
        UpdatePlantLocStatus;
      END;
      IF gvType = gvType::"Service Order" THEN BEGIN
        UpdateServiceOrderSatus;
        UpdatePlantLocStatus;
      END;

      //Close Purchase Order Control
      IF ((gvType = gvType::Project) AND (NOT ProjSetup."Provisions at Closure")) OR
         (gvType = gvType::"Service Order") THEN
      BEGIN
        ClosePurchaseOrderControl;
      END;

      IF GUIALLOWED THEN
        Window.CLOSE;

      COMMIT; //To release locks when running batches.
    END;

    [External]
    PROCEDURE CalcCostAmounts@1210190014();
    VAR
      LocRentalUnitCost@1100529600 : Decimal;
    BEGIN
      CostTypeContrRec.FINDFIRST;
      CostTypeContrRec.CALCFIELDS("Actual Costs", "Open (Inventory)",
                                  "Open Ovh. Surch. (Inventory)", Prognosis,
                                  "Actual Costs Externals", "Prognosis Total Cost");

      IF ProjSetup."Rental Units active" THEN BEGIN
        LocRentalUnitCost := CalculateRentalUnitCosts;
        RentalUnitCosts += LocRentalUnitCost;
      END;

      BalanceDec := CostTypeContrRec."Actual Costs" - LocRentalUnitCost;

      CostAmountCostType[i] := CostTypeContrRec."Actual Costs" - LocRentalUnitCost;

      PostGrpCount := 0;
      IF (gvType = gvType::Project) THEN
        SearchExeptionbyVendPstGrp;

      CalcCostProvisions;
    END;

    [External]
    PROCEDURE SearchExeptionbyVendPstGrp@1100485007();
    VAR
      lAmount@1100485002 : Decimal;
      DiffFromProjType@1100485004 : Boolean;
    BEGIN
      //Test posting per cost type/vendor posting group

      VendorPostingGrpSettingsRec.RESET;
      VendorPostingGrpSettingsRec.SETRANGE("Project Type No.", ProjRec."Project Type");
      CASE CostTypeContrRec."Cost Type" OF
        CostTypeContrRec."Cost Type"::Labor:
          BEGIN
            VendorPostingGrpSettingsRec.SETFILTER("Closed Labor Debit", '<>%1', '');
            VendorPostingGrpSettingsRec.SETFILTER("Closed Labor Credit", '<>%1', '');
          END;
        CostTypeContrRec."Cost Type"::Material:
          BEGIN
            VendorPostingGrpSettingsRec.SETFILTER("Closed Material Debit", '<>%1', '');
            VendorPostingGrpSettingsRec.SETFILTER("Closed Material Credit", '<>%1', '');
          END;
        CostTypeContrRec."Cost Type"::Subcontracting:
          BEGIN
            VendorPostingGrpSettingsRec.SETFILTER("Closed Subcontracting Debit", '<>%1', '');
            VendorPostingGrpSettingsRec.SETFILTER("Closed Subcontracting Credit", '<>%1', '');
          END;
        CostTypeContrRec."Cost Type"::Plant:
          BEGIN
            VendorPostingGrpSettingsRec.SETFILTER("Closed Plant Debit", '<>%1', '');
            VendorPostingGrpSettingsRec.SETFILTER("Closed Plant Credit", '<>%1', '');
          END;
        CostTypeContrRec."Cost Type"::Sundry:
          BEGIN
            VendorPostingGrpSettingsRec.SETFILTER("Closed Sundry Debit", '<>%1', '');
            VendorPostingGrpSettingsRec.SETFILTER("Closed Sundry Credit", '<>%1', '');
          END;
      END;

      CLEAR(PartBalanceTable);

      IF VendorPostingGrpSettingsRec.FINDSET(FALSE, FALSE) THEN BEGIN
        REPEAT
          DiffFromProjType := TRUE;
          CASE CostTypeContrRec."Cost Type" OF
            CostTypeContrRec."Cost Type"::Labor:
              BEGIN
                IF (VendorPostingGrpSettingsRec."Closed Labor Debit" = ProjTypeRec."Closed Labor Debit") AND
                   (VendorPostingGrpSettingsRec."Closed Labor Credit" = ProjTypeRec."Closed Labor Credit") THEN
                  DiffFromProjType := FALSE;
              END;
            CostTypeContrRec."Cost Type"::Material:
              BEGIN
                IF (VendorPostingGrpSettingsRec."Closed Material Debit" = ProjTypeRec."Closed Material Debit") AND
                   (VendorPostingGrpSettingsRec."Closed Material Credit" = ProjTypeRec."Closed Material Credit") THEN
                  DiffFromProjType := FALSE;
              END;
            CostTypeContrRec."Cost Type"::Subcontracting:
              BEGIN
                IF (VendorPostingGrpSettingsRec."Closed Subcontracting Debit" = ProjTypeRec."Closed Subcontracting Debit") AND
                   (VendorPostingGrpSettingsRec."Closed Subcontracting Credit" = ProjTypeRec."Closed Subcontracting Credit") THEN
                  DiffFromProjType := FALSE;
              END;
            CostTypeContrRec."Cost Type"::Plant:
              BEGIN
                IF (VendorPostingGrpSettingsRec."Closed Plant Debit" = ProjTypeRec."Closed Plant Debit") AND
                   (VendorPostingGrpSettingsRec."Closed Plant Credit" = ProjTypeRec."Closed Plant Credit") THEN
                  DiffFromProjType := FALSE;
              END;
            CostTypeContrRec."Cost Type"::Sundry:
              BEGIN
                IF (VendorPostingGrpSettingsRec."Closed Sundry Debit" = ProjTypeRec."Closed Sundry Debit") AND
                   (VendorPostingGrpSettingsRec."Closed Sundry Credit" = ProjTypeRec."Closed Sundry Credit") THEN
                  DiffFromProjType := FALSE;
              END;
          END;

          IF DiffFromProjType THEN BEGIN
            lAmount := CalcCostAmountsbyVendPstGrp;
            IF lAmount <> 0 THEN BEGIN
              PostGrpCount += 1;
              VendorPostingGroupTable[PostGrpCount] := VendorPostingGrpSettingsRec."Vendor Posting Group No.";
              PartBalanceTable[PostGrpCount] := lAmount;
            END;
          END;

        UNTIL VendorPostingGrpSettingsRec.NEXT = 0;
      END;
    END;

    [External]
    PROCEDURE CalcCostAmountsbyVendPstGrp@1100485004() LocalBalanceDec : Decimal;
    VAR
      lJobLedgerEntry@1100485000 : Record 11072005;
    BEGIN
      //first check presence lines of current vendor posting group
      LocalBalanceDec := 0;
      lJobLedgerEntry.SETCURRENTKEY("Main Project No.", "Job No.", "Entry Type", "Cost Type");
      lJobLedgerEntry.SETRANGE("Main Project No.", ProjRec."Main Project");
      lJobLedgerEntry.SETRANGE("Job No.", ProjRec."No.");
      lJobLedgerEntry.SETRANGE("Entry Type", lJobLedgerEntry."Entry Type"::Usage);
      lJobLedgerEntry.SETRANGE("Cost Type", CostTypeContrRec."Cost Type");
      IF ProjSetup."Rental Units active" THEN
        lJobLedgerEntry.SETRANGE("Rental Unit", '');
      lJobLedgerEntry.SETRANGE("Vendor Posting Group", VendorPostingGrpSettingsRec."Vendor Posting Group No.");

      //Surcharges are not posted per vendor/job type.
      IF lJobLedgerEntry.FINDSET THEN
        REPEAT
          LocalBalanceDec := LocalBalanceDec + lJobLedgerEntry."Total Cost (LCY)"
        UNTIL lJobLedgerEntry.NEXT = 0;
    END;

    [External]
    PROCEDURE SearchServExeptionbyVendPstGrp@1100525000();
    VAR
      lAmount@1100485002 : Decimal;
      DiffFromServType@1100485004 : Boolean;
    BEGIN
      //Test posting per cost type/vendor posting group
      ServVendPostGrpSettingsRec.RESET;
      ServVendPostGrpSettingsRec.SETRANGE("Service Type No.", ServTypeRec.Code);
      CASE ServEntryRec."Cost Type" OF
        ServEntryRec."Cost Type"::Labor:
          BEGIN
            ServVendPostGrpSettingsRec.SETFILTER("Closed Labor Debit", '<>%1', '');
            ServVendPostGrpSettingsRec.SETFILTER("Closed Labor Credit", '<>%1', '');
          END;
        ServEntryRec."Cost Type"::Material:
          BEGIN
            ServVendPostGrpSettingsRec.SETFILTER("Closed Material Debit", '<>%1', '');
            ServVendPostGrpSettingsRec.SETFILTER("Closed Material Credit", '<>%1', '');
          END;
        ServEntryRec."Cost Type"::Subcontracting:
          BEGIN
            ServVendPostGrpSettingsRec.SETFILTER("Closed Subcontracting Debit", '<>%1', '');
            ServVendPostGrpSettingsRec.SETFILTER("Closed Subcontracting Credit", '<>%1', '');
          END;
        ServEntryRec."Cost Type"::Plant:
          BEGIN
            ServVendPostGrpSettingsRec.SETFILTER("Closed Plant Debit", '<>%1', '');
            ServVendPostGrpSettingsRec.SETFILTER("Closed Plant Credit", '<>%1', '');
          END;
        ServEntryRec."Cost Type"::Sundry:
          BEGIN
            ServVendPostGrpSettingsRec.SETFILTER("Closed Sundry Debit", '<>%1', '');
            ServVendPostGrpSettingsRec.SETFILTER("Closed Sundry Credit", '<>%1', '');
          END;
      END;

      CLEAR(PartBalanceTable);
      CLEAR(VendorPostingGroupTable);

      IF ServVendPostGrpSettingsRec.FINDSET(FALSE, FALSE) THEN BEGIN
        REPEAT
          DiffFromServType := TRUE;
          CASE ServEntryRec."Cost Type" OF
            ServEntryRec."Cost Type"::Labor:
              BEGIN
                IF (ServVendPostGrpSettingsRec."Closed Labor Debit" = ServTypeRec."Closed Labor Debit") AND
                   (ServVendPostGrpSettingsRec."Closed Labor Credit" = ServTypeRec."Closed Labor Credit") THEN
                  DiffFromServType := FALSE;
              END;
            ServEntryRec."Cost Type"::Material:
              BEGIN
                IF (ServVendPostGrpSettingsRec."Closed Material Debit" = ServTypeRec."Closed Material Debit") AND
                   (ServVendPostGrpSettingsRec."Closed Material Credit" = ServTypeRec."Closed Material Credit") THEN
                  DiffFromServType := FALSE;
              END;
            ServEntryRec."Cost Type"::Subcontracting:
              BEGIN
                IF (ServVendPostGrpSettingsRec."Closed Subcontracting Debit" = ServTypeRec."Closed Subcontracting Debit") AND
                   (ServVendPostGrpSettingsRec."Closed Subcontracting Credit" = ServTypeRec."Closed Subcontracting Credit") THEN
                  DiffFromServType := FALSE;
              END;
            ServEntryRec."Cost Type"::Plant:
              BEGIN
                IF (ServVendPostGrpSettingsRec."Closed Plant Debit" = ServTypeRec."Closed Plant Debit") AND
                   (ServVendPostGrpSettingsRec."Closed Plant Credit" = ServTypeRec."Closed Plant Credit") THEN
                  DiffFromServType := FALSE;
              END;
            ServEntryRec."Cost Type"::Sundry:
              BEGIN
                IF (ServVendPostGrpSettingsRec."Closed Sundry Debit" = ServTypeRec."Closed Sundry Debit") AND
                   (ServVendPostGrpSettingsRec."Closed Sundry Credit" = ServTypeRec."Closed Sundry Credit") THEN
                  DiffFromServType := FALSE;
              END;
          END;

          IF DiffFromServType THEN BEGIN
            lAmount := CalcSerCostAmountsbyVendPstGrp;
            IF lAmount <> 0 THEN BEGIN
              PostGrpCount += 1;
              VendorPostingGroupTable[PostGrpCount] := ServVendPostGrpSettingsRec."Vendor Posting Group No.";
              PartBalanceTable[PostGrpCount] := lAmount;
            END;
          END;

        UNTIL ServVendPostGrpSettingsRec.NEXT = 0;
      END;
    END;

    [External]
    PROCEDURE CalcSerCostAmountsbyVendPstGrp@1100525002() LocalBalanceDec : Decimal;
    VAR
      lServLedgerEntry@1100485000 : Record 11012819;
    BEGIN
      //first check presence lines of current vendor posting group
      LocalBalanceDec := 0;
      lServLedgerEntry.COPYFILTERS(ServEntryRec);
      CASE gvType OF
        gvType::"Service Contract":
          lServLedgerEntry.SETCURRENTKEY(
            "Service Contract No.", "Source Type", "Cost Type", "Global Dimension 2 Code",
            "Additional Cost","Cost Present","Revenue Present","Posting Date");
        gvType::"Service Order":
          lServLedgerEntry.SETCURRENTKEY(
            "Service Order No.","Source Type","Cost Type","Global Dimension 2 Code","Cost Component",
            "Additional Cost","Cost Present","Revenue Present","Posting Date");
      END;
      lServLedgerEntry.SETRANGE("Vendor Posting Group", ServVendPostGrpSettingsRec."Vendor Posting Group No.");
      IF lServLedgerEntry.FINDSET THEN
        REPEAT
          LocalBalanceDec := LocalBalanceDec + lServLedgerEntry."Total Cost (LCY)"
        UNTIL lServLedgerEntry.NEXT = 0;
    END;

    LOCAL PROCEDURE SearchProjExeptionbyCustPstGrp@1100529603(CostType@1100529600 : Integer);
    VAR
      RevenueAmount@1100485002 : Decimal;
      DiffFromProjType@1100485004 : Boolean;
    BEGIN
      //Test posting revenues per cost type/customer posting group
      LedgerbyProjTypeCustGr.RESET;
      LedgerbyProjTypeCustGr.SETRANGE("Project Type No.", ProjRec."Project Type");
      CASE CostType OF
        ProjRec."Original Cost Type Filter"::" ":
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Credit", '<>%1', '');
          END;
        ProjRec."Original Cost Type Filter"::Labor:
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Labor Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Labor Credit", '<>%1', '');
          END;
        ProjRec."Original Cost Type Filter"::Material:
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Material Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Material Credit", '<>%1', '');
          END;
        ProjRec."Original Cost Type Filter"::Subcontracting:
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Subcontr.Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Subcontr.Credit", '<>%1', '');
          END;
        ProjRec."Original Cost Type Filter"::Plant:
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Plant Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Plant Credit", '<>%1', '');
          END;
        ProjRec."Original Cost Type Filter"::Sundry:
          BEGIN
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Sundry Debit", '<>%1', '');
            LedgerbyProjTypeCustGr.SETFILTER("Closed Revenue Sundry Credit", '<>%1', '');
          END;
      END;

      CustPostGrpCount := 0;
      CLEAR(PartRevenueBalanceTable);
      CLEAR(CustPostingGroupTable);

      IF LedgerbyProjTypeCustGr.FINDSET(FALSE, FALSE) THEN BEGIN
        REPEAT
          DiffFromProjType := TRUE;
          CASE CostType OF
            ProjRec."Original Cost Type Filter"::" ":
              IF (LedgerbyProjTypeCustGr."Closed Revenue Debit" = ProjTypeRec."Closed Revenue Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Credit" = ProjTypeRec."Closed Revenue Credit") THEN
                DiffFromProjType := FALSE;
            ProjRec."Original Cost Type Filter"::Labor:
              IF (LedgerbyProjTypeCustGr."Closed Revenue Labor Debit" = ProjTypeRec."Closed Revenue Labor Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Labor Credit" = ProjTypeRec."Closed Revenue Labor Credit") THEN
                DiffFromProjType := FALSE;
            ProjRec."Original Cost Type Filter"::Material:
              IF (LedgerbyProjTypeCustGr."Closed Revenue Material Debit" = ProjTypeRec."Closed Revenue Material Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Material Credit" = ProjTypeRec."Closed Revenue Material Credit") THEN
                DiffFromProjType := FALSE;
            ProjRec."Original Cost Type Filter"::Subcontracting:
              IF (LedgerbyProjTypeCustGr."Closed Revenue Subcontr.Debit" = ProjTypeRec."Closed Revenue Subcontr.Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Subcontr.Credit" = ProjTypeRec."Closed Revenue Subcontr.Credit") THEN
                DiffFromProjType := FALSE;
            ProjRec."Original Cost Type Filter"::Plant:
              IF (LedgerbyProjTypeCustGr."Closed Revenue Plant Debit" = ProjTypeRec."Closed Revenue Plant Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Plant Credit" = ProjTypeRec."Closed Revenue Plant Credit") THEN
                DiffFromProjType := FALSE;
            ProjRec."Original Cost Type Filter"::Sundry:
              IF (LedgerbyProjTypeCustGr."Closed Revenue Sundry Debit" = ProjTypeRec."Closed Revenue Sundry Debit") AND
                  (LedgerbyProjTypeCustGr."Closed Revenue Sundry Credit" = ProjTypeRec."Closed Revenue Sundry Credit") THEN
                DiffFromProjType := FALSE;
          END;

          IF DiffFromProjType THEN BEGIN
            RevenueAmount := CalcProjRevenueAmountsbyCustPstGrp;
            IF RevenueAmount <> 0 THEN BEGIN
              CustPostGrpCount += 1;
              CustPostingGroupTable[CustPostGrpCount] := LedgerbyProjTypeCustGr."Customer Posting Group No.";
              PartRevenueBalanceTable[CustPostGrpCount] := RevenueAmount;
            END;
          END;

        UNTIL LedgerbyProjTypeCustGr.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE CalcProjRevenueAmountsbyCustPstGrp@1100529602() : Decimal;
    VAR
      ProjectLedgerEntry@1100485000 : Record 11072005;
    BEGIN
      //first check presence lines of current customer posting group
      ProjectLedgerEntry.SETRANGE("Main Project No.", ProjRec."Main Project");
      ProjectLedgerEntry.SETRANGE("Job No.", ProjRec."No.");
      ProjectLedgerEntry.SETRANGE("Entry Type", ProjectLedgerEntry."Entry Type"::Sale);
      ProjectLedgerEntry.SETFILTER("Original Cost Type", ProjRec.GETFILTER("Original Cost Type Filter"));
      ProjectLedgerEntry.SETFILTER("Rental Unit", ProjRec.GETFILTER("Rental Unit Filter"));
      ProjectLedgerEntry.SETRANGE("Customer Posting Group", LedgerbyProjTypeCustGr."Customer Posting Group No.");
      ProjectLedgerEntry.SETRANGE("Advance Payment", FALSE);
      ProjectLedgerEntry.CALCSUMS("Total Price (LCY)");
      EXIT(ProjectLedgerEntry."Total Price (LCY)");
    END;

    LOCAL PROCEDURE SearchServExeptionbyCustPstGrp@1100529607(CostType@1100529600 : Integer);
    VAR
      RevenueAmount@1100485002 : Decimal;
      DiffFromServType@1100485004 : Boolean;
    BEGIN
      //Test posting per cost type/customer posting group
      LedgerbyServTypeCustGr.RESET;
      LedgerbyServTypeCustGr.SETRANGE("Service Type No.", ServTypeRec.Code);
      CASE CostType OF
        ServEntryRec."Original Cost Type"::" ":
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Credit", '<>%1', '');
          END;
        ServEntryRec."Original Cost Type"::Labor:
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Labor Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Labor Credit", '<>%1', '');
          END;
        ServEntryRec."Original Cost Type"::Material:
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Material Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Material Credit", '<>%1', '');
          END;
        ServEntryRec."Original Cost Type"::Subcontracting:
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Subcontr.Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Subcontr.Credit", '<>%1', '');
          END;
        ServEntryRec."Original Cost Type"::Plant:
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Plant Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Plant Credit", '<>%1', '');
          END;
        ServEntryRec."Original Cost Type"::Sundry:
          BEGIN
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Sundry Debit", '<>%1', '');
            LedgerbyServTypeCustGr.SETFILTER("Closed Revenue Sundry Credit", '<>%1', '');
          END;
      END;

      CustPostGrpCount := 0;
      CLEAR(PartRevenueBalanceTable);
      CLEAR(CustPostingGroupTable);
      TmpServiceEntryPostGroup.DELETEALL;

      IF LedgerbyServTypeCustGr.FINDSET(FALSE, FALSE) THEN BEGIN
        REPEAT
          DiffFromServType := TRUE;
          CASE CostType OF
            ServEntryRec."Original Cost Type"::" ":
              IF (LedgerbyServTypeCustGr."Closed Revenue Debit" = ServTypeRec."Closed Revenue Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Credit" = ServTypeRec."Closed Revenue Credit")
              THEN
                DiffFromServType := FALSE;
            ServEntryRec."Original Cost Type"::Labor:
              IF (LedgerbyServTypeCustGr."Closed Revenue Labor Debit" = ServTypeRec."Closed Revenue Labor Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Labor Credit" = ServTypeRec."Closed Revenue Labor Credit")
              THEN
                DiffFromServType := FALSE;
            ServEntryRec."Original Cost Type"::Material:
              IF (LedgerbyServTypeCustGr."Closed Revenue Material Debit" = ServTypeRec."Closed Revenue Material Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Material Credit" = ServTypeRec."Closed Revenue Material Credit")
              THEN
                DiffFromServType := FALSE;
            ServEntryRec."Original Cost Type"::Subcontracting:
              IF (LedgerbyServTypeCustGr."Closed Revenue Subcontr.Debit" = ServTypeRec."Closed Revenue Subcontr.Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Subcontr.Credit" = ServTypeRec."Closed Revenue Subcontr.Credit")
              THEN
                DiffFromServType := FALSE;
            ServEntryRec."Original Cost Type"::Plant:
              IF (LedgerbyServTypeCustGr."Closed Revenue Plant Debit" = ServTypeRec."Closed Revenue Plant Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Plant Credit" = ServTypeRec."Closed Revenue Plant Credit")
              THEN
                DiffFromServType := FALSE;
            ServEntryRec."Original Cost Type"::Sundry:
              IF (LedgerbyServTypeCustGr."Closed Revenue Sundry Debit" = ServTypeRec."Closed Revenue Sundry Debit") AND
                 (LedgerbyServTypeCustGr."Closed Revenue Sundry Credit" = ServTypeRec."Closed Revenue Sundry Credit")
              THEN
                DiffFromServType := FALSE;
          END;

          IF DiffFromServType THEN BEGIN
            RevenueAmount := CalcSerRevenueAmountsbyCustPstGrp;
            IF RevenueAmount <> 0 THEN BEGIN
              CustPostGrpCount += 1;
              CustPostingGroupTable[CustPostGrpCount] := LedgerbyServTypeCustGr."Customer Posting Group No.";
              PartRevenueBalanceTable[CustPostGrpCount] := RevenueAmount;
            END;
          END;

        UNTIL LedgerbyServTypeCustGr.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE CalcSerRevenueAmountsbyCustPstGrp@1100529606() RevenueAmount : Decimal;
    VAR
      ServLedgerEntry@1100485000 : Record 11012819;
    BEGIN
      //first check presence lines of current customer posting group
      RevenueAmount := 0;

      ServLedgerEntry.COPYFILTERS(ServEntryRec);
      ServLedgerEntry.SETRANGE("Customer Posting Group", LedgerbyServTypeCustGr."Customer Posting Group No.");
      IF ServLedgerEntry.ISEMPTY THEN
        EXIT;
      ServLedgerEntry.FINDSET;
      REPEAT
        RevenueAmount -= ServLedgerEntry."Total Revenue (LCY)";
        TmpServiceEntryPostGroup := ServLedgerEntry;
        TmpServiceEntryPostGroup.INSERT;
      UNTIL ServLedgerEntry.NEXT = 0;
    END;

    [External]
    PROCEDURE FillGenJnlLine@1210190007(lType@1210190000 : Integer;CostTypeRevenue@1100485000 : ' ,Labor,Material,Subcontracting,Plant,Sundry,Revenues');
    VAR
      ServiceContractCtrlPeriod@1100525001 : Record 11071746;
      lvText@1100525000 : Text[100];
    BEGIN
      // lType=1 standard procedure
      // lType=2 procedure for provisions  // with i=8 for  for provisions (based upon rough prognosis, so cost type is unknown, )
      //                                   // only projects.
      // lType=3 Divide Revenues Fixed Price over Cost Types; lType 3 is the only type that is not posted directly.
      // lType=4 Procedure for External Employee costs, is obsolete
      // lType=5 Procedure for divergent WIP/Finished settings per vendor
      // lType=6 Procedure for Settling the After Closure Provisions (definitely Finalize the Project)
      // lType=7 Procedure for Rental Units
      // lType=9 Closing by Customer Posting Groups

      WITH GenJnlLineRec DO BEGIN
        INIT;
        "Document No." := GetDocNoCde;
        "Reason Code" := JnlTemplRec."Reason Code";
        "Source Code" := JnlTemplRec."Source Code";
        "Account Type" := "Account Type"::"G/L Account";
        "System-Created Entry" := TRUE;
        "Posting Date" := PostingDate;
        "Line No." := NextLineNo;
        CASE gvType OF
          gvType::Project:
            BEGIN
              "Journal Template Name" := ProjSetup."Journal Template Closing Proc.";
              "Journal Batch Name" := ProjSetup."Journal Batch Closing Proc.";

              CASE lType OF
                1,2:
                  BEGIN
                    CASE i OF
                      1: "Account No." := ProjTypeRec."Closed Labor Debit";
                      2: "Account No." := ProjTypeRec."Closed Material Debit";
                      3: "Account No." := ProjTypeRec."Closed Subcontracting Debit";
                      4: "Account No." := ProjTypeRec."Closed Plant Debit";
                      5: "Account No." := ProjTypeRec."Closed Sundry Debit";
                      6: CASE CostTypeRevenue OF
                           CostTypeRevenue::" ",
                           CostTypeRevenue::Revenues       : "Account No." := ProjTypeRec."Closed Revenue Credit";
                           CostTypeRevenue::Labor          : "Account No." := ProjTypeRec."Closed Revenue Labor Credit";
                           CostTypeRevenue::Material       : "Account No." := ProjTypeRec."Closed Revenue Material Credit";
                           CostTypeRevenue::Subcontracting : "Account No." := ProjTypeRec."Closed Revenue Subcontr.Credit";
                           CostTypeRevenue::Plant          : "Account No." := ProjTypeRec."Closed Revenue Plant Credit";
                           CostTypeRevenue::Sundry         : "Account No." := ProjTypeRec."Closed Revenue Sundry Credit";
                         END;
                      7: "Account No." := ProjTypeRec."Closed Rental Unit Rev. Credit";
                      8: "Account No." := ProjTypeRec."Cost. Acc Rough Prognosis Cost";
                      9: "Account No." := ProjectTypeExtension."Closed Rental Unit Costs Cred.";
                    END;
                  END;
                3:
                  BEGIN
                    CASE i OF
                      1:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Revenue Labor Account");
                          "Account No." := ProjTypeRec."Revenue Labor Account";
                        END;
                      2:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Revenue Material Account");
                          "Account No." := ProjTypeRec."Revenue Material Account";
                        END;
                      3:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Revenue Subcontracting Account");
                          "Account No." := ProjTypeRec."Revenue Subcontracting Account";
                        END;
                      4:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Revenue Plant Account");
                          "Account No." := ProjTypeRec."Revenue Plant Account";
                        END;
                      5:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Revenue Sundry Account");
                          "Account No." := ProjTypeRec."Revenue Sundry Account";
                        END;
                      6:
                        BEGIN
                          ProjTypeRec.TESTFIELD("Fixed Price Revenues To Divide");
                         "Account No." := ProjTypeRec."Fixed Price Revenues To Divide";
                        END;
                    END;
                  END;

                5:
                  BEGIN
                    CASE i OF
                      1: "Account No." := VendorPostingGrpSettingsRec."Closed Labor Debit";
                      2: "Account No." := VendorPostingGrpSettingsRec."Closed Material Debit";
                      3: "Account No." := VendorPostingGrpSettingsRec."Closed Subcontracting Debit";
                      4: "Account No." := VendorPostingGrpSettingsRec."Closed Plant Debit";
                      5: "Account No." := VendorPostingGrpSettingsRec."Closed Sundry Debit";
                    END;
                  END;
                6:
                  BEGIN
                    CASE i OF
                       1: "Account No." := ProjTypeRec."Closed Labor Debit";
                       2: "Account No." := ProjTypeRec."Closed Material Debit";
                       3: "Account No." := ProjTypeRec."Closed Subcontracting Debit";
                       4: "Account No." := ProjTypeRec."Closed Plant Debit";
                       5: "Account No." := ProjTypeRec."Closed Sundry Debit";
                       6: "Account No." := ProjTypeRec."Closed Revenue Credit";
                       7: "Account No." := ProjTypeRec."Closed Rental Unit Rev. Credit";
                       9: "Account No." := ProjectTypeExtension."Closed Rental Unit Costs Cred.";
                    END;
                  END;
                9:
                  CASE CostTypeRevenue OF
                    CostTypeRevenue::" ",
                    CostTypeRevenue::Revenues       : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Credit";
                    CostTypeRevenue::Labor          : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Labor Credit";
                    CostTypeRevenue::Material       : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Material Credit";
                    CostTypeRevenue::Subcontracting : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Subcontr.Credit";
                    CostTypeRevenue::Plant          : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Plant Credit";
                    CostTypeRevenue::Sundry         : "Account No." := LedgerbyProjTypeCustGr."Closed Revenue Sundry Credit";
                  END;
              END;
            END;
          gvType::"Service Contract", gvType::"Service Order":
            BEGIN
              "Journal Template Name" := ServSetup."Journal Template Closing Proc.";
              "Journal Batch Name" := ServSetup."Journal Batch Closing Proc.";

              CASE lType OF
                5: BEGIN
                    CASE i OF
                      1: "Account No." := ServVendPostGrpSettingsRec."Closed Labor Debit";
                      2: "Account No." := ServVendPostGrpSettingsRec."Closed Material Debit";
                      3: "Account No." := ServVendPostGrpSettingsRec."Closed Subcontracting Debit";
                      4: "Account No." := ServVendPostGrpSettingsRec."Closed Plant Debit";
                      5: "Account No." := ServVendPostGrpSettingsRec."Closed Sundry Debit";
                    END;
                   END;
                9:
                  CASE CostTypeRevenue OF
                    CostTypeRevenue::" ",
                    CostTypeRevenue::Revenues       : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Credit";
                    CostTypeRevenue::Labor          : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Labor Credit";
                    CostTypeRevenue::Material       : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Material Credit";
                    CostTypeRevenue::Subcontracting : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Subcontr.Credit";
                    CostTypeRevenue::Plant          : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Plant Credit";
                    CostTypeRevenue::Sundry         : "Account No." := LedgerbyServTypeCustGr."Closed Revenue Sundry Credit";
                  END;
                ELSE BEGIN
                  CASE i OF
                    1: "Account No." := ServTypeRec."Closed Labor Debit";
                    2: "Account No." := ServTypeRec."Closed Material Debit";
                    3: "Account No." := ServTypeRec."Closed Subcontracting Debit";
                    4: "Account No." := ServTypeRec."Closed Plant Debit";
                    5: "Account No." := ServTypeRec."Closed Sundry Debit";
                    6: CASE CostTypeRevenue OF
                        CostTypeRevenue::" ",
                        CostTypeRevenue::Revenues : "Account No." := ServTypeRec."Closed Revenue Credit";
                        CostTypeRevenue::Labor : "Account No." := ServTypeRec."Closed Revenue Labor Credit";
                        CostTypeRevenue::Material : "Account No." := ServTypeRec."Closed Revenue Material Credit";
                        CostTypeRevenue::Subcontracting : "Account No." := ServTypeRec."Closed Revenue Subcontr.Credit";
                        CostTypeRevenue::Plant : "Account No." := ServTypeRec."Closed Revenue Plant Credit";
                        CostTypeRevenue::Sundry : "Account No." := ServTypeRec."Closed Revenue Sundry Credit";
                       END;
                  END;
                END;
            END;
          END;
        END;
        VALIDATE("Account No.");
        "Gen. Prod. Posting Group" := '';
        "Gen. Bus. Posting Group" := '';
        "VAT Prod. Posting Group" :='';
        "VAT Bus. Posting Group" := '';
        "Gen. Posting Type" := 0;
        "Bal. Account Type" := "Bal. Account Type"::"G/L Account";

        CASE gvType OF
          gvType::Project:
            CASE lType OF
              1:
                CASE i OF
                  1: "Bal. Account No." := ProjTypeRec."Closed Labor Credit";
                  2: "Bal. Account No." := ProjTypeRec."Closed Material Credit";
                  3: "Bal. Account No." := ProjTypeRec."Closed Subcontracting Credit";
                  4: "Bal. Account No." := ProjTypeRec."Closed Plant Credit";
                  5: "Bal. Account No." := ProjTypeRec."Closed Sundry Credit";
                  6: CASE CostTypeRevenue OF
                       CostTypeRevenue::" ",
                       CostTypeRevenue::Revenues       : "Bal. Account No." := ProjTypeRec."Closed Revenue Debit";
                       CostTypeRevenue::Labor          : "Bal. Account No." := ProjTypeRec."Closed Revenue Labor Debit";
                       CostTypeRevenue::Material       : "Bal. Account No." := ProjTypeRec."Closed Revenue Material Debit";
                       CostTypeRevenue::Subcontracting : "Bal. Account No." := ProjTypeRec."Closed Revenue Subcontr.Debit";
                       CostTypeRevenue::Plant          : "Bal. Account No." := ProjTypeRec."Closed Revenue Plant Debit";
                       CostTypeRevenue::Sundry         : "Bal. Account No." := ProjTypeRec."Closed Revenue Sundry Debit";
                     END;
                  7: "Bal. Account No." := ProjTypeRec."Closed Rental Unit Rev. Debit";
                  9: "Bal. Account No." := ProjectTypeExtension."Closed Rental Unit Costs Debit";
                END;
              2:
                CASE i OF
                  1: "Bal. Account No." := ProjTypeRec."Provision Account Labor";
                  2: "Bal. Account No." := ProjTypeRec."Provision Account Material";
                  3: "Bal. Account No." := ProjTypeRec."Provision Account Subcontr.";
                  4: "Bal. Account No." := ProjTypeRec."Provision Account Plant";
                  5: "Bal. Account No." := ProjTypeRec."Provision Account Sundry";
                  6: "Bal. Account No." := ProjTypeRec."Provision Account Revenue";
                  7: "Bal. Account No." := ProjTypeRec."Provision Account Rental UR";
                  8: "Bal. Account No." := ProjTypeRec."Prov. Acc Rough Prognosis Cost";
                END;
              5:
                BEGIN
                  CASE i OF
                    1: "Bal. Account No." := VendorPostingGrpSettingsRec."Closed Labor Credit";
                    2: "Bal. Account No." := VendorPostingGrpSettingsRec."Closed Material Credit";
                    3: "Bal. Account No." := VendorPostingGrpSettingsRec."Closed Subcontracting Credit";
                    4: "Bal. Account No." := VendorPostingGrpSettingsRec."Closed Plant Credit";
                    5: "Bal. Account No." := VendorPostingGrpSettingsRec."Closed Sundry Credit";
                  END;
                END;
              6:
                BEGIN
                  CASE i OF
                    1: "Bal. Account No." := ProjTypeRec."Provision Account Labor";
                    2: "Bal. Account No." := ProjTypeRec."Provision Account Material";
                    3: "Bal. Account No." := ProjTypeRec."Provision Account Subcontr.";
                    4: "Bal. Account No." := ProjTypeRec."Provision Account Plant";
                    5: "Bal. Account No." := ProjTypeRec."Provision Account Sundry";
                    6: "Bal. Account No." := ProjTypeRec."Provision Account Revenue";
                    7: "Bal. Account No." := ProjTypeRec."Provision Account Rental UR";
                  END;
                END;
              9:
                CASE CostTypeRevenue OF
                  CostTypeRevenue::" ",
                  CostTypeRevenue::Revenues       : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Debit";
                  CostTypeRevenue::Labor          : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Labor Debit";
                  CostTypeRevenue::Material       : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Material Debit";
                  CostTypeRevenue::Subcontracting : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Subcontr.Debit";
                  CostTypeRevenue::Plant          : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Plant Debit";
                  CostTypeRevenue::Sundry         : "Bal. Account No." := LedgerbyProjTypeCustGr."Closed Revenue Sundry Debit";
                END;
            END;
          gvType::"Service Contract", gvType::"Service Order":
            CASE lType OF
              5: BEGIN
                  CASE i OF
                    1: "Bal. Account No." := ServVendPostGrpSettingsRec."Closed Labor Credit";
                    2: "Bal. Account No." := ServVendPostGrpSettingsRec."Closed Material Credit";
                    3: "Bal. Account No." := ServVendPostGrpSettingsRec."Closed Subcontracting Credit";
                    4: "Bal. Account No." := ServVendPostGrpSettingsRec."Closed Plant Credit";
                    5: "Bal. Account No." := ServVendPostGrpSettingsRec."Closed Sundry Credit";
                  END;
                END;
              9:
                CASE CostTypeRevenue OF
                  CostTypeRevenue::" ",
                  CostTypeRevenue::Revenues       : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Debit";
                  CostTypeRevenue::Labor          : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Labor Debit";
                  CostTypeRevenue::Material       : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Material Debit";
                  CostTypeRevenue::Subcontracting : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Subcontr.Debit";
                  CostTypeRevenue::Plant          : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Plant Debit";
                  CostTypeRevenue::Sundry         : "Bal. Account No." := LedgerbyServTypeCustGr."Closed Revenue Sundry Debit";
                END;
              ELSE BEGIN
                CASE i OF
                  1: "Bal. Account No." := ServTypeRec."Closed Labor Credit";
                  2: "Bal. Account No." := ServTypeRec."Closed Material Credit";
                  3: "Bal. Account No." := ServTypeRec."Closed Subcontracting Credit";
                  4: "Bal. Account No." := ServTypeRec."Closed Plant Credit";
                  5: "Bal. Account No." := ServTypeRec."Closed Sundry Credit";
                  6: CASE CostTypeRevenue OF
                       CostTypeRevenue::" ",
                       CostTypeRevenue::Revenues       : "Bal. Account No." := ServTypeRec."Closed Revenue Debit";
                       CostTypeRevenue::Labor          : "Bal. Account No." := ServTypeRec."Closed Revenue Labor Debit";
                       CostTypeRevenue::Material       : "Bal. Account No." := ServTypeRec."Closed Revenue Material Debit";
                       CostTypeRevenue::Subcontracting : "Bal. Account No." := ServTypeRec."Closed Revenue Subcontr.Debit";
                       CostTypeRevenue::Plant          : "Bal. Account No." := ServTypeRec."Closed Revenue Plant Debit";
                       CostTypeRevenue::Sundry         : "Bal. Account No." := ServTypeRec."Closed Revenue Sundry Debit";
                     END;
                END;
              END;
            END;
        END;
        CASE gvType OF
          gvType::Project:
            BEGIN
              CASE lType OF
                1,3:
                  lvText := STRSUBSTNO(Text042, ProjRec.TABLECAPTION, gvProj);
                2,8:
                  lvText := STRSUBSTNO(Text052, ProjRec.TABLECAPTION, gvProj);
                4:
                  lvText := STRSUBSTNO(Text055, ProjRec.TABLECAPTION, gvProj);
                5:
                  lvText := STRSUBSTNO(Text062, ProjRec.TABLECAPTION,
                                                gvProj,
                                                VendorPostingGrpSettingsRec."Vendor Posting Group No.");
                6:
                  lvText := STRSUBSTNO(Text073, ProjRec.TABLECAPTION, gvProj);
                9:
                  lvText := STRSUBSTNO(Text095, ProjRec.TABLECAPTION,
                                                gvProj,
                                                LedgerbyProjTypeCustGr."Customer Posting Group No.");
              END;
              Description := COPYSTR(lvText, 1, MAXSTRLEN(Description));
              "Closed Project No." := gvProj;
            END;
          gvType::"Service Contract":
            BEGIN
              CASE lType OF
                5:
                  lvText := STRSUBSTNO(Text062, ServContrRec.TABLECAPTION,
                                                gvContr,
                                                ServVendPostGrpSettingsRec."Vendor Posting Group No.");
                9:
                  lvText := STRSUBSTNO(Text095, ServContrRec.TABLECAPTION,
                                                gvContr,
                                                LedgerbyServTypeCustGr."Customer Posting Group No.");
                ELSE
                  lvText := STRSUBSTNO(Text042, ServContrRec.TABLECAPTION, gvContr);
              END;
              Description := COPYSTR(lvText, 1, MAXSTRLEN(Description));
              IF gvContractControlPeriodCode <> '' THEN BEGIN
                IF ServiceContractCtrlPeriod.GET(ServContrRec."No.", gvContractControlPeriodCode) THEN
                  "Description 2" := STRSUBSTNO('%1 - %2',
                    ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
              END;
              "Closed Service Contract No." := gvContr;
            END;
          gvType::"Service Order":
            BEGIN
              CASE lType OF
                5:
                  lvText := STRSUBSTNO(Text062, ServOrderRec.TABLECAPTION,
                                                     gvOrder,
                                                     ServVendPostGrpSettingsRec."Vendor Posting Group No.");
                9:
                  lvText := STRSUBSTNO(Text095, ServContrRec.TABLECAPTION,
                                                gvContr,
                                                LedgerbyServTypeCustGr."Customer Posting Group No.");
                ELSE
                  lvText := STRSUBSTNO(Text042, ServOrderRec.TABLECAPTION, gvOrder);
              END;
              Description := COPYSTR(lvText, 1, MAXSTRLEN(Description));
              "Closed Service Order No." := gvOrder;
              "Closed Service Contract No." := ServOrderRec."Service Contract No.";
            END;
        END;
        VALIDATE("Bal. Account No.");
        "Bal. Gen. Prod. Posting Group" := '';
        "Bal. Gen. Bus. Posting Group" := '';
        "Bal. VAT Prod. Posting Group" := '';
        "Bal. VAT Bus. Posting Group" := '';
        "Bal. Gen. Posting Type" := 0;
        "Skip WIP Check" := TRUE;
        IF lType <> 3 THEN
          "Posting No. Series" := NoSeriesCde;

        CASE lType OF
          1,3,5,6,9:
            VALIDATE(Amount, BalanceDec);
          2,8:
            VALIDATE(Amount, ProvisionDec);
        END;

        CASE gvType OF
          gvType::Project:
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service Order",gvOrder,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ProjRec."Global Dimension 1 Code");
            END;
          gvType::"Service Contract":
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service-Contract",gvContr,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ServContrRec."Global Dimension 1 Code");
            END;
          gvType::"Service Order":
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service Order",gvOrder,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ServOrderRec."Global Dimension 1 Code");
            END;

        END;

        IF lType = 3 THEN BEGIN
          PostOrPreview(FALSE);
          IF PostEntries THEN
            ShowGenJnl := TRUE;
        END ELSE
          PostOrPreview(TRUE);
      END;
    END;

    [External]
    PROCEDURE FillJobJnlLine@1210190008();
    BEGIN
      IF gPreview THEN
        EXIT;

      WITH JobJnlLineRec DO BEGIN
        INIT;
        "Posting Date" := GenJnlLineRec."Posting Date";
        "Reason Code" := GenJnlLineRec."Reason Code";
        "Source Code" := GenJnlLineRec."Source Code";
        Type := Type::"G/L Account";
        "Line No." := NextLineNo;
        "Job No." := gvProj;
        "Service Contract No." := gvContr;
        "Service Order No." := gvOrder;
        "WIP Balance Account" := GenJnlLineRec."Bal. Account No.";
        "No." := GenJnlLineRec."Account No.";
        Description := GenJnlLineRec.Description;
        "Document No." := GenJnlLineRec."Document No.";
        "Source Currency Code" := GenJnlLineRec."Currency Code";
        IF (i = 6) OR (i = 7) THEN BEGIN
          "Entry Type" := "Entry Type"::Sale;
          "Closed Revenues" := GenJnlLineRec.Amount;
          "Cost Type Closing Procedure" := 5;
        END ELSE BEGIN
          "Entry Type" := "Entry Type"::Usage;
          "Closed Costs" := GenJnlLineRec.Amount;
          CASE i OF
            8: "Cost Type Closing Procedure" := 4;
            9: "Cost Type Closing Procedure" := 5;
            ELSE
              "Cost Type Closing Procedure" := i - 1;
          END;
        END;
        "Shortcut Dimension 1 Code" := GenJnlLineRec."Shortcut Dimension 1 Code";
        "Dimension Set ID" :=  GenJnlLineRec."Dimension Set ID" ;
      END;

      PostProjJnlLine.RunWithCheck(JobJnlLineRec);
    END;

    [External]
    PROCEDURE FillJobJnlLinePreclosureResult@1210190013(lProvisionLoss@1100525000 : Boolean;lContra@1100525001 : Boolean);
    BEGIN
      IF gPreview THEN
        EXIT;

      WITH JobJnlLineRec DO BEGIN
        INIT;
        "Posting Date" := GenJnlLineRec."Posting Date";
        "Reason Code" := GenJnlLineRec."Reason Code";
        "Source Code" := GenJnlLineRec."Source Code";
        Type := Type::"G/L Account";
        "Line No." := NextLineNo;
        "Job No." := gvProj;
        "Service Contract No." := gvContr;
        "Service Order No." := gvOrder;
        "WIP Balance Account" := GenJnlLineRec."Bal. Account No.";
        "No." := GenJnlLineRec."Account No.";
        Description := GenJnlLineRec.Description;
        "Document No." := GenJnlLineRec."Document No.";
        "Source Currency Code" := GenJnlLineRec."Currency Code";
        "Entry Type" := "Entry Type"::Usage;

        IF lProvisionLoss THEN BEGIN
          "Actual Provision Result" := GenJnlLineRec.Amount
        END ELSE BEGIN
          IF lContra THEN BEGIN
            "Actual Preclosure Result" := GenJnlLineRec.Amount;
            "WIP Balance Account" := GenJnlLineRec."Bal. Account No.";
            "No." := GenJnlLineRec."Account No.";
          END ELSE BEGIN
            "Actual Preclosure Result" := -GenJnlLineRec.Amount;
            "WIP Balance Account" := GenJnlLineRec."Account No.";
            "No." :=  GenJnlLineRec."Bal. Account No.";
          END;
        END;
        "Cost Type Closing Procedure" := 5;
        "Shortcut Dimension 1 Code" := GenJnlLineRec."Shortcut Dimension 1 Code";
        "Dimension Set ID" :=  GenJnlLineRec."Dimension Set ID" ;
      END;

      PostProjJnlLine.RunWithCheck(JobJnlLineRec);
    END;

    [External]
    PROCEDURE FillServJnlLine@1210190006();
    VAR
      ServiceLedgerEntry@1100525000 : Record 11012819;
      ServiceContractCtrlPeriod@1100528600 : Record 11071746;
    BEGIN
      IF NOT PostEntries THEN
        EXIT;

      WITH ServJnlLineRec DO BEGIN
         INIT;
        "Posting Date" := GenJnlLineRec."Posting Date";
        "Reason Code" := GenJnlLineRec."Reason Code";
        "Source Code" := GenJnlLineRec."Source Code";
        "Line No." := NextLineNo;
        "Project No." := gvProj;
        "Service Contract No." := gvContr;
        "Service Order No." := gvOrder;
        IF gvType = gvType::"Service Contract" THEN
          "Customer No." := ServContrRec."Bill-to Customer No. (Contr.)";
        IF gvType = gvType::"Service Order" THEN BEGIN
          "Customer No." := ServOrderRec."Bill-to Customer No.";
          "Service Location No." := ServOrderRec."Service Location No.";
        END;
        "G/L Account" := GenJnlLineRec."Account No.";
        "WIP Account Costs" := GenJnlLineRec."Account No.";
        "WIP Balance Account" := GenJnlLineRec."Bal. Account No.";
        Description := GenJnlLineRec.Description;
        "Description 2" := GenJnlLineRec."Description 2";
        "Document No." := GenJnlLineRec."Document No.";
        IF (i = 6) THEN BEGIN
          "Closed Revenues" := GenJnlLineRec.Amount;
          "Cost Type Closing Procedure" := 5;
        END ELSE BEGIN
          "Closed Costs" := GenJnlLineRec.Amount;
          "Cost Type Closing Procedure" := i - 1;
        END;
        "Closing Procedure" := TRUE;
        "Shortcut Dimension 1 Code" := GenJnlLineRec."Shortcut Dimension 1 Code";
        "Dimension Set ID" :=  GenJnlLineRec."Dimension Set ID" ;

        "Precl. Service Control Year" := gvControlYear;
        "Additional Cost" := GenJnlLineRec."Additional Cost (Service)";

        CASE gvType OF
          gvType::"Service Contract":
            IF ServiceContractCtrlPeriod.GET(gvContr, gvContractControlPeriodCode) THEN
              "Service Control Period Date" := ServiceContractCtrlPeriod."Ending Date";
          gvType::"Service Order":
            "Service Control Period Date" := ServOrderRec."Service Control Period Date";
        END;
        "Service Category" := ServEntryRec."Service Category";
      END;

      PostServJnlLine.RunWithCheck(ServJnlLineRec);

      TmpServiceEntryRec.SETRANGE("Closed Entry No. Serv. Ledger", 0);
      IF TmpServiceEntryRec.FINDSET THEN BEGIN
        REPEAT
          ServiceLedgerEntry := TmpServiceEntryRec;
          ServiceLedgerEntry."Closed Entry No. Serv. Ledger" := PostServJnlLine.GetServLedgEntryNo();
          ServiceLedgerEntry.MODIFY(FALSE);
        UNTIL TmpServiceEntryRec.NEXT = 0;
      END;
      TmpServiceEntryRec.DELETEALL;
      CLEAR(TmpServiceEntryRec);
    END;

    [External]
    PROCEDURE FillServJnlLinePreclResult@1100485005(lContra@1100525000 : Boolean;LocServicePreclosureResultLine@1100529600 : Record 11072313);
    BEGIN
      IF NOT PostEntries THEN
        EXIT;

      WITH ServJnlLineRec DO BEGIN
         INIT;
        "Posting Date" := GenJnlLineRec."Posting Date";
        "Reason Code" := GenJnlLineRec."Reason Code";
        "Source Code" := GenJnlLineRec."Source Code";
        "Line No." := NextLineNo;
        "Project No." := gvProj;
        "Service Contract No." := gvContr;
        VALIDATE("Service Order No.", gvOrder);
        IF gvType = gvType::"Service Contract" THEN
          "Customer No." := ServContrRec."Bill-to Customer No. (Contr.)";
        IF gvType = gvType::"Service Order" THEN BEGIN
          "Customer No." := ServOrderRec."Bill-to Customer No.";
          "Service Location No." := ServOrderRec."Service Location No.";
        END;

        IF lContra THEN BEGIN
          "Actual Preclosure Result" := GenJnlLineRec.Amount;
          "G/L Account" := GenJnlLineRec."Account No.";
          "WIP Account Costs" := GenJnlLineRec."Account No.";
          "WIP Balance Account" := GenJnlLineRec."Bal. Account No.";
        END ELSE BEGIN
          "Actual Preclosure Result" := -GenJnlLineRec.Amount;
          "G/L Account" :=  GenJnlLineRec."Bal. Account No.";
          "WIP Account Costs" := GenJnlLineRec."Bal. Account No.";
          "WIP Balance Account" := GenJnlLineRec."Account No.";
        END;

        Description := GenJnlLineRec.Description;
        "Description 2" := GenJnlLineRec."Description 2";
        "Document No." := GenJnlLineRec."Document No.";
        "Cost Type Closing Procedure" := 5;
        "Closing Procedure" := TRUE;
        "Shortcut Dimension 1 Code" := GenJnlLineRec."Shortcut Dimension 1 Code";
        "Dimension Set ID" :=  GenJnlLineRec."Dimension Set ID" ;

        "Precl. Service Control Year" := gvControlYear;
        "Source Type Closing Procedure" := "Source Type Closing Procedure"::"Not Used";
        IF NOT PostOldPreclosureResult THEN BEGIN
          IF (LocServicePreclosureResultLine."Starting Date" <> 0D) AND (LocServicePreclosureResultLine."Ending Date" <> 0D) THEN
            "Service Control Period Date" := LocServicePreclosureResultLine.GetServiceControlPeriodDate("Posting Date");
          "Service Category" := LocServicePreclosureResultLine."Service Category";
        END;
      END;

      PostServJnlLine.RunWithCheck(ServJnlLineRec);
    END;

    PROCEDURE AddError@7(lvMess@11012000 : Text[250];lvDoc@11012001 : Code[20]);
    VAR
      NewLine@1100485000 : Integer;
    BEGIN
      WITH ErrorRec DO BEGIN
        IF ("Project No." = gvProj) AND
           ("Service Contract No." = gvContr) AND
           ("Service Order No." = gvOrder) AND
           ("Document No." = lvDoc) AND
           ("Error message" = lvMess) THEN
          EXIT;

        RESET;
        SETRANGE("User ID", USERID);
        SETRANGE("Source Type", "Source Type"::"Finish Service-Project");
        IF FINDLAST THEN
          NewLine := "Line No." + 1
        ELSE
          NewLine := 1;

        INIT;
        "User ID" := USERID;
        "Source Type" := "Source Type"::"Finish Service-Project";
        "Line No." := NewLine;
        "Error message" := lvMess;
        "Document No." := lvDoc;
        "Project No." := gvProj;
        "Service Contract No." := gvContr;
        "Service Order No." := gvOrder;
        "Department Code" := GlobDim1Code;
        "Employee No." := ProjRec."Project Manager";
        IF CloseServiceRestOfContract THEN
          "Serv. Contr. Ctrl. Period Code" := COPYSTR(ServContrRec.FIELDCAPTION("Rest of Contract"), 1, MAXSTRLEN("Serv. Contr. Ctrl. Period Code"))
        ELSE
          "Serv. Contr. Ctrl. Period Code" := gvContractControlPeriodCode;
        INSERT;
      END;
    END;

    [External]
    PROCEDURE DisplayError@1210190000();
    BEGIN
      WITH ErrorRec DO BEGIN
        RESET;
        SETRANGE("User ID", USERID);
        SETRANGE("Source Type", "Source Type"::"Finish Service-Project");
        IF FINDFIRST THEN BEGIN
          COMMIT;
          PAGE.RUNMODAL(PAGE::Errors, ErrorRec);
          ShowGenJnl := FALSE;
        END;
      END;
    END;

    PROCEDURE CheckPurchase@19();
    BEGIN
      LineCount := 1;
      SetFiltersPurchLine;
      IF PurchLineRec.FINDSET THEN BEGIN
        NoOfRecords := PurchLineRec.COUNT;
        InitDoc;
        REPEAT
          IF DocCode <> PurchLineRec."Document No." THEN BEGIN
            DocCode := PurchLineRec."Document No.";
            AddError(ErrorTxt,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL PurchLineRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    LOCAL PROCEDURE CheckPurchaseInvoice@1100528603();
    VAR
      PurchaseHeader@1100528600 : Record 38;
    BEGIN
      SetFiltersPurchLine;
      IF PurchLineRec.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := PurchLineRec.COUNT;
        REPEAT
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
          PurchaseHeader.GET(PurchLineRec."Document Type",PurchLineRec."Document No.");
          IF PurchaseHeader.Status <> PurchaseHeader.Status::Closed THEN BEGIN
            IF PurchLineRec."Outst. Amount exc. VAT (LCY)" <> 0 THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text038,
                                      PurchLineRec.FIELDCAPTION("Amount (LCY)"),
                                      PurchLineRec."Amount (LCY)",
                                      PurchLineRec."Outst. Amount exc. VAT (LCY)",
                                      PurchLineRec.CURRENTCOMPANY);
              AddError(ErrorTxt,PurchLineRec."Document No.");
            END;
            IF PurchLineRec."Rec./Not Inv. exc.VAT (LCY)" <> 0 THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text039,
                                      PurchLineRec.FIELDCAPTION("Amount (LCY)"),
                                      PurchLineRec."Amount (LCY)",
                                      PurchLineRec."Rec./Not Inv. exc.VAT (LCY)",
                                      PurchLineRec.CURRENTCOMPANY);
              AddError(ErrorTxt,PurchLineRec."Document No.");
            END;

            IF PurchLineRec."Outstanding Quantity" <> 0 THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text038,
                                      PurchLineRec.FIELDCAPTION(Quantity),
                                      PurchLineRec.Quantity,
                                      PurchLineRec."Outstanding Quantity",
                                      PurchLineRec.CURRENTCOMPANY);
              AddError(ErrorTxt,PurchLineRec."Document No.");
            END;
            IF PurchLineRec."Qty. to Invoice" <> 0 THEN BEGIN
              ErrorTxt := STRSUBSTNO(Text039,
                                      PurchLineRec.FIELDCAPTION(Quantity),
                                      PurchLineRec.Quantity,
                                      PurchLineRec."Qty. to Invoice",
                                      PurchLineRec.CURRENTCOMPANY);
              AddError(ErrorTxt,PurchLineRec."Document No.");
            END;
          END;
        UNTIL PurchLineRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    PROCEDURE CheckSales@20();
    VAR
      ServiceContractCtrlPeriod@1100525001 : Record 11071746;
      lvErrorBln@1100525000 : Boolean;
    BEGIN
      LineCount := 1;
      SalesLineRec.SETFILTER(Type, '<>%1', SalesLineRec.Type::" ");
      IF gvType = gvType::Project THEN
        SalesLineRec.SETRANGE("Job No.",gvProj);
      IF gvType = gvType::"Service Contract" THEN BEGIN
        SalesLineRec.SETRANGE("Service Contract No.",gvContr);
        SalesLineRec.SETFILTER("Service Order No.", '%1', '');
        IF (gvContractControlPeriodCode <> '') OR CloseServiceRestOfContract THEN BEGIN
          GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
          SalesLineRec.SETRANGE("Service Control Period Date",
            ServiceContractCtrlPeriod."Starting Date", ServiceContractCtrlPeriod."Ending Date");
        END ELSE
          SalesLineRec.SETRANGE("Service Control Year", gvControlYear);
      END;
      IF gvType = gvType::"Service Order" THEN
        SalesLineRec.SETRANGE("Service Order No.",gvOrder);
      IF SalesLineRec.FINDSET THEN BEGIN
        NoOfRecords := SalesLineRec.COUNT;
        InitDoc;
        REPEAT
          lvErrorBln := TRUE;
          IF gvType = gvType::"Service Contract" THEN BEGIN
            SalesHeader.GET(SalesLineRec."Document Type", SalesLineRec."Document No.");
            IF IgnoreFuturePostings THEN
              IF SalesHeader."Posting Date" > PostingDate THEN
                lvErrorBln := FALSE;
          END;
          IF lvErrorBln THEN BEGIN
            IF DocCode <> SalesLineRec."Document No." THEN BEGIN
              DocCode := SalesLineRec."Document No.";
              AddError(ErrorTxt,DocCode);
            END;
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL SalesLineRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
      SalesLineRec.SETRANGE(Type);
    END;

    [External]
    PROCEDURE CheckSalesInvoice@1100409003();
    VAR
      SavedDocumentNo@1100409000 : Code[20];
    BEGIN
      ErrorTxt := Text082;
      ServOrderRec.GET(gvOrder);
      CustLedgerEntry.RESET;
      CustLedgerEntry.SETCURRENTKEY("Document No.");
      CustLedgerEntry.SETRANGE("Document Type", CustLedgerEntry."Document Type"::Invoice);
      SalesInvoiceLine.RESET;
      SalesInvoiceLine.SETCURRENTKEY("Service Contract No.","Service Order No.");
      SalesInvoiceLine.SETRANGE("Service Contract No.",ServOrderRec."Service Contract No.");
      SalesInvoiceLine.SETRANGE("Service Order No.",ServOrderRec."No.");
      IF SalesInvoiceLine.FINDSET THEN BEGIN
        REPEAT
          IF SalesInvoiceLine."Document No." <> SavedDocumentNo THEN BEGIN
            CustLedgerEntry.SETRANGE("Document No.", SalesInvoiceLine."Document No.");
            IF CustLedgerEntry.FINDFIRST THEN BEGIN
              CustLedgerEntry.CALCFIELDS("Remaining Amount");
              IF CustLedgerEntry."Remaining Amount" <> 0 THEN BEGIN
                AddError(ErrorTxt, SalesInvoiceLine."Document No.");
              END;
            END;
          END;
          SavedDocumentNo := SalesInvoiceLine."Document No.";
        UNTIL (SalesInvoiceLine.NEXT = 0)
      END;
    END;

    LOCAL PROCEDURE CheckServiceOrders@1100529100();
    VAR
      ServiceOrder@1100529100 : Record 11012823;
      JobRelatedServiceOrder@1100528200 : Record 11229339;
    BEGIN
      ErrorTxt := Text090;
      IF gvType = gvType::Project THEN BEGIN
        JobRelatedServiceOrder.SETRANGE("Job No.", gvProj);
        IF JobRelatedServiceOrder.FINDSET THEN BEGIN
          REPEAT
            ServiceOrder.CHANGECOMPANY(JobRelatedServiceOrder."Company Service Order");
            IF ServiceOrder.GET(JobRelatedServiceOrder."Service Order No.") THEN BEGIN
              IF (ServiceOrder.Status <> ServiceOrder.Status::Finished) AND
                 (ServiceOrder.Status <> ServiceOrder.Status::Cancelled)
              THEN
                AddError(STRSUBSTNO(ErrorTxt, ServiceOrder.TABLECAPTION, ServiceOrder."No.", JobRelatedServiceOrder."Company Service Order"), '');
            END;
          UNTIL (JobRelatedServiceOrder.NEXT = 0)
        END;
      END;
    END;

    LOCAL PROCEDURE CheckWorkOrders@1100529101();
    VAR
      ServiceOrder@1100528600 : Record 11012823;
      WorkOrder@1100529100 : Record 11229279;
    BEGIN
      ErrorTxt := Text091;
      IF gvType = gvType::"Service Order" THEN BEGIN
        ServiceOrder.GET(gvOrder);
        IF ServiceOrder.Status <> ServiceOrder.Status::Finished THEN BEGIN
          WorkOrder.SETCURRENTKEY("Source Company","Source Type","Source No.");
          WorkOrder.SETRANGE("Source No.", gvOrder);
          WorkOrder.SETRANGE("Source Company",COMPANYNAME);
          WorkOrder.SETRANGE("Source Type",WorkOrder."Source Type"::ServiceOrder);
          IF WorkOrder.FINDSET THEN
            REPEAT
              IF NOT WorkOrder."WO Finished (Field Service)" THEN
                AddError(STRSUBSTNO(ErrorTxt, WorkOrder.TABLECAPTION, WorkOrder."No."), '');
            UNTIL (WorkOrder.NEXT = 0)
        END;
      END;
    END;

    [External]
    PROCEDURE CheckServicePreclosureResult@1100528201();
    VAR
      ServiceContrPreclDetail@1100528200 : Record 11071767;
      ServicePreclosureResultLine@1100528201 : Record 11072313;
    BEGIN
      IF ServSetup."Service Control Method" = ServSetup."Service Control Method"::Snapshot THEN BEGIN
        ServiceContrPreclDetail.SETCURRENTKEY("Service Contract No.", "Contract Control Period Code", Posted);
        ServiceContrPreclDetail.SETRANGE("Service Contract No.", gvContr);
        ServiceContrPreclDetail.SETRANGE("Contract Control Period Code", gvContractControlPeriodCode);
        ServiceContrPreclDetail.SETRANGE(Posted, FALSE);
        IF ServiceContrPreclDetail.FINDFIRST THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text079, PostingDate);
          AddError(ErrorTxt, ' ');
        END;
        IF NOT IgnoreFuturePostings THEN BEGIN
          ServiceContrPreclDetail.SETRANGE(Posted, TRUE);
          ServiceContrPreclDetail.SETFILTER("Posting Date", '>%1', PostingDate);
          ServiceContrPreclDetail.SETRANGE("Service Contract WIP Processed", FALSE);
          IF ServiceContrPreclDetail.FINDFIRST THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text078, PostingDate);
            AddError(ErrorTxt, ' ');
          END;
        END;
      END ELSE BEGIN
        ServicePreclosureResultLine.SETCURRENTKEY("Service Contract No.");
        ServicePreclosureResultLine.SETRANGE("Service Contract No.", gvContr);
        ServicePreclosureResultLine.SETRANGE("Control Period Code", gvContractControlPeriodCode);
        ServicePreclosureResultLine.SETRANGE(Posted, FALSE);
        IF PostOldPreclosureResult THEN
          ServicePreclosureResultLine.SETFILTER("Posting Date", '<%1', PostingDate);
        IF NOT ServicePreclosureResultLine.ISEMPTY THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text079, PostingDate);
          AddError(ErrorTxt, ' ');
        END;
        IF NOT IgnoreFuturePostings THEN BEGIN
          ServicePreclosureResultLine.SETRANGE(Posted, TRUE);
          ServicePreclosureResultLine.SETFILTER("Posting Date", '>%1', PostingDate);
          ServicePreclosureResultLine.SETRANGE("Service Contract WIP Processed", FALSE);
          IF NOT ServicePreclosureResultLine.ISEMPTY THEN BEGIN
            ErrorTxt := STRSUBSTNO(Text078, PostingDate);
            AddError(ErrorTxt, ' ');
          END;
        END;
      END;
    END;

    [External]
    PROCEDURE CheckProjectPreclosureResult@1100529612(LocPostingDate@1100529601 : Date);
    VAR
      ProjectPreclosureResult@1100529600 : Record 11012093;
    BEGIN
      ProjectPreclosureResult.SETRANGE("Project No.", gvProj);
      ProjectPreclosureResult.SETRANGE(Posted, FALSE);
      ProjectPreclosureResult.SETFILTER("Line No.", '<>%1', PreclosureProjectRec."Line No.");
      ProjectPreclosureResult.SETFILTER("Posting Date", '<%1', LocPostingDate);
      IF NOT ProjectPreclosureResult.ISEMPTY THEN BEGIN
        ErrorTxt := STRSUBSTNO(Text079, PostingDate);
        AddError(ErrorTxt, ' ');
      END;
      IF NOT IgnoreFuturePostings THEN BEGIN
        ProjectPreclosureResult.SETRANGE(Posted, TRUE);
        ProjectPreclosureResult.SETFILTER("Posting Date", '>%1', LocPostingDate);
        ProjectPreclosureResult.SETRANGE("Correction Posted", FALSE);
        IF NOT ProjectPreclosureResult.ISEMPTY THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text078, PostingDate);
          AddError(ErrorTxt, ' ');
        END;
      END;
    END;

    [External]
    PROCEDURE CheckType@1210190003(lvType@1100485000 : Code[20]);
    BEGIN
      IF gvType = gvType::Project THEN BEGIN
        ProjTypeRec.TESTFIELD("Closed Labor Credit");
        ProjTypeRec.TESTFIELD("Closed Material Credit");
        ProjTypeRec.TESTFIELD("Closed Subcontracting Credit");
        ProjTypeRec.TESTFIELD("Closed Plant Credit");
        ProjTypeRec.TESTFIELD("Closed Sundry Credit");
        ProjTypeRec.TESTFIELD("Closed Revenue Debit");
        ProjTypeRec.TESTFIELD("Closed Labor Debit");
        ProjTypeRec.TESTFIELD("Closed Material Debit");
        ProjTypeRec.TESTFIELD("Closed Subcontracting Debit");
        ProjTypeRec.TESTFIELD("Closed Plant Debit");
        ProjTypeRec.TESTFIELD("Closed Sundry Debit");
        ProjTypeRec.TESTFIELD("Closed Revenue Credit");
        IF (ProjSetup."Rental Units active") AND (RentalUnitsProjectPresent) THEN BEGIN
          ProjTypeRec.TESTFIELD("Closed Rental Unit Rev. Debit");
          ProjTypeRec.TESTFIELD("Closed Rental Unit Rev. Credit");
          ProjectTypeExtension.TESTFIELD("Closed Rental Unit Costs Cred.");
          ProjectTypeExtension.TESTFIELD("Closed Rental Unit Costs Debit");
        END;
        IF ProjSetup."Provisions at Closure" THEN BEGIN
          IF ProjRec."Preclosure Result" <> ProjRec."Preclosure Result"::No THEN
            CheckTypePreclResultProject;
          ProjTypeRec.TESTFIELD("Provision Account Labor");
          ProjTypeRec.TESTFIELD("Provision Account Material");
          ProjTypeRec.TESTFIELD("Provision Account Subcontr.");
          ProjTypeRec.TESTFIELD("Provision Account Plant");
          ProjTypeRec.TESTFIELD("Provision Account Sundry");
          ProjTypeRec.TESTFIELD("Provision Account Revenue");
        END;

        IF (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN BEGIN
          ProjTypeRec.TESTFIELD("Closed Revenue Labor Debit");
          ProjTypeRec.TESTFIELD("Closed Revenue Material Debit");
          ProjTypeRec.TESTFIELD("Closed Revenue Subcontr.Debit");
          ProjTypeRec.TESTFIELD("Closed Revenue Plant Debit");
          ProjTypeRec.TESTFIELD("Closed Revenue Sundry Debit");
          ProjTypeRec.TESTFIELD("Closed Revenue Labor Credit");
          ProjTypeRec.TESTFIELD("Closed Revenue Material Credit");
          ProjTypeRec.TESTFIELD("Closed Revenue Subcontr.Credit");
          ProjTypeRec.TESTFIELD("Closed Revenue Plant Credit");
          ProjTypeRec.TESTFIELD("Closed Revenue Sundry Credit");
        END;

      END ELSE BEGIN
        ServTypeRec.GET(lvType);
        ServTypeRec.TESTFIELD("Closed Labor Credit");
        ServTypeRec.TESTFIELD("Closed Material Credit");
        ServTypeRec.TESTFIELD("Closed Subcontracting Credit");
        ServTypeRec.TESTFIELD("Closed Plant Credit");
        ServTypeRec.TESTFIELD("Closed Sundry Credit");
        ServTypeRec.TESTFIELD("Closed Revenue Debit");
        ServTypeRec.TESTFIELD("Closed Labor Debit");
        ServTypeRec.TESTFIELD("Closed Material Debit");
        ServTypeRec.TESTFIELD("Closed Subcontracting Debit");
        ServTypeRec.TESTFIELD("Closed Plant Debit");
        ServTypeRec.TESTFIELD("Closed Sundry Debit");
        ServTypeRec.TESTFIELD("Closed Revenue Credit");
      END;
    END;

    LOCAL PROCEDURE CheckServiceType@1100529610(ServiceTypeCode@1100529600 : Code[20];VAR TmpServiceType@1100529601 : TEMPORARY Record 11012814);
    VAR
      LocServiceType@1100529602 : Record 11012814;
    BEGIN
      IF gvType <> gvType::"Service Contract" THEN
        EXIT;

      IF ServiceTypeCode = '' THEN
        EXIT;
      IF TmpServiceType.GET(ServiceTypeCode) THEN
        EXIT;

      LocServiceType.GET(ServiceTypeCode);
      TmpServiceType := LocServiceType;
      TmpServiceType.INSERT;

      IF LocServiceType."Closed Labor Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Labor Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Material Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Material Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Subcontracting Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Subcontracting Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Plant Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Plant Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Sundry Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Sundry Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Revenue Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Revenue Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Labor Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Labor Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Material Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Material Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Subcontracting Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Subcontracting Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Plant Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Plant Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Sundry Debit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Sundry Debit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
      IF LocServiceType."Closed Revenue Credit" = '' THEN
        AddError(STRSUBSTNO(Text100, LocServiceType.FIELDCAPTION("Closed Revenue Credit"), LocServiceType.TABLECAPTION, LocServiceType.Code), ' ');
    END;

    [External]
    PROCEDURE CheckProjectInvoice@1210190004();
    VAR
      CheckDiffAmounts@1100485000 : Boolean;
      lvHoldCustNo@1100485001 : Code[20];
      lvInstallmentTotal@1100525000 : Decimal;
      lUnitPriceProdMot@1100525001 : Record 11020425;
      RAW_OK@1100409000 : Boolean;
      lvWithheldtot@1100285000 : Decimal;
    BEGIN
      //DP01527
      IF ProjRec."Internal Project" THEN
        EXIT; //No further checks
      //

      //check whether all unit price production motivations are invoiced
      lUnitPriceProdMot.RESET;
      lUnitPriceProdMot.SETRANGE("Project No.", gvProj);
      lUnitPriceProdMot.SETRANGE(Invoiced, FALSE);
      lUnitPriceProdMot.SETFILTER(Status, '<%1', lUnitPriceProdMot.Status::Expired);
      IF lUnitPriceProdMot.FINDFIRST THEN BEGIN
        ErrorTxt := STRSUBSTNO(Text069, lUnitPriceProdMot.TABLECAPTION, lUnitPriceProdMot."Production Date", lUnitPriceProdMot.Code,
          lUnitPriceProdMot.FIELDCAPTION(Invoiced));
        AddError(ErrorTxt, ' ');
      END;

      CASE ProjRec."Settlement Method" OF
        ProjRec."Settlement Method"::"Fixed Price":
        BEGIN
          //Check not invoiced installments
          IF GUIALLOWED THEN
            Window.UPDATE(3,Text022);
          LineCount := 1;
          CLEAR(ProjInstRec);
          ProjInstRec.SETRANGE("Project No.",gvProj);
          IF ProjInstRec.FINDSET THEN BEGIN
            NoOfRecords := ProjInstRec.COUNT;
            REPEAT
              lvHoldCustNo := ProjInstRec.Principal;
              IF ChargeJobOrderToPlant() THEN
                ProjInstRec.Principal := '';
              ProjInstRec.CALCFIELDS("Invoiced Price (LCY)");
              ProjInstRec.Principal := lvHoldCustNo;
              CheckDiffAmounts := TRUE;
              IF ProjInstRec."Extension Contract" <> '' THEN
                CheckDiffAmounts :=
                  (ExtensionRec.GET(gvProj, ProjInstRec."Extension Contract")) AND
                  (ExtensionRec.Status <> ExtensionRec.Status::Expired);
              //131126 IME-072 ITERO.SB Changed calculation (Installment amout - withheld amount)
              ProjInstRec.CALCFIELDS("Withheld Amt. (Invoiced)",ProjInstRec."Withheld Amt. (Credit)");
              IF CheckDiffAmounts AND (ProjInstRec."Invoiced Price (LCY)" <> ((ProjInstRec."Installment Amount (LCY)")-(ProjInstRec."Withheld Amt. (Invoiced)"+ProjInstRec."Withheld Amt. (Credit)"))) THEN BEGIN
              //<<
                ErrorTxt := STRSUBSTNO(Text023,
                                       ProjInstRec."Installment No.",
                                       ProjInstRec."Installment Amount (LCY)",
                                       ProjInstRec."Invoiced Price (LCY)",
                                       ProjInstRec.Principal);
                AddError(ErrorTxt,' ');
              END;
              IF GUIALLOWED THEN
                Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
              LineCount := LineCount + 1;
            UNTIL ProjInstRec.NEXT = 0;
            IF GUIALLOWED THEN
              Window.UPDATE(4,0);
          END;

          //Check invoicing Contract Amount
          LineCount := 1;
          ProjCustRec.SETRANGE("Project No.",gvProj);
          IF ProjCustRec.FINDSET THEN BEGIN
            IF GUIALLOWED THEN
              Window.UPDATE(3,Text024);
            NoOfRecords := ProjCustRec.COUNT;
            REPEAT
              ProjCustRec.CALCFIELDS("Total Extension Contract");
              lvInstallmentTotal := 0;

              CLEAR(ProjInstRec);
              ProjInstRec.SETRANGE("Project No.",gvProj);
              ProjInstRec.SETRANGE(Principal,ProjCustRec.Principal);
              ProjInstRec.SETRANGE("Interest Installment", ProjInstRec."Interest Installment"::" ");
              ProjInstRec.SETRANGE("Advance Payment", FALSE);
              IF ProjInstRec.FINDFIRST THEN
                REPEAT
                  //>> 131126 IME-072 ITERO.SB Changed calculation
                  lvInstallmentTotal += ProjInstRec."Installment Amount (LCY)";
                  //lvWithheldtot += ProjInstRec."Withheld Amount";
                  //>> 171211 ITERO.SB Pure 285498
                  //lvWithheldtot += ProjInstRec."Withheld Amount (LCY)";
                  ProjInstRec.CALCFIELDS("Withheld Amt. (Invoiced)",ProjInstRec."Withheld Amt. (Credit)");
                  lvWithheldtot += (ProjInstRec."Withheld Amt. (Invoiced)"+ProjInstRec."Withheld Amt. (Credit)");
                  //<<
                UNTIL ProjInstRec.NEXT = 0;
              lvInstallmentTotal:=lvInstallmentTotal-lvWithheldtot;
              CLEAR(PlotRec);
              PlotRec.SETRANGE("Project No.",gvProj);
              PlotRec.SETRANGE(Principal,ProjCustRec.Principal);
              IF PlotRec.FINDFIRST THEN
                PlotRec.CALCFIELDS("Option Total");

              TotContrDec := ProjCustRec."Contract Amount (LCY)" + ProjCustRec."Plot Price" +
                ProjCustRec."Total Extension Contract" + PlotRec."Option Total";
              IF lvInstallmentTotal <> TotContrDec THEN BEGIN
                RAW_OK := FALSE;
                IF ProjRec.RAW AND ProjRec."Civil Engineering Project" THEN BEGIN
                  ProjInstRec.SETRANGE("Project No.",gvProj);
                  ProjInstRec.SETRANGE(Principal,ProjCustRec.Principal);
                  ProjInstRec.SETRANGE("Interest Installment", ProjInstRec."Interest Installment"::" ");
                  ProjInstRec.SETRANGE("Advance Payment", FALSE);
                  ProjInstRec.SETRANGE("RAW Final Installment", TRUE);
                  IF ProjInstRec.FINDFIRST THEN
                    RAW_OK := TRUE;
                END;
                IF NOT RAW_OK THEN BEGIN
                  ErrorTxt := STRSUBSTNO(Text025,
                                         TotContrDec,
                                         lvInstallmentTotal,
                                         ProjCustRec.Principal);
                  AddError(ErrorTxt,' ');
                END;
              END;
              IF ProjCustRec."Plot Price" <> 0 THEN BEGIN
                ProjInstRec.SETRANGE("Installment No.",'0');
                ProjInstRec.SETRANGE("Advance Payment", FALSE);
                IF ProjInstRec.FINDFIRST THEN BEGIN
                  IF ProjInstRec."Installment Amount (LCY)" <> ProjCustRec."Plot Price" THEN BEGIN
                    ErrorTxt := STRSUBSTNO(Text026,
                                           ProjCustRec."Plot Price",
                                           ProjInstRec."Installment Amount (LCY)",
                                           ProjInstRec.Principal);
                    AddError(ErrorTxt,' ');
                  END;
                END ELSE BEGIN
                  ErrorTxt := STRSUBSTNO(Text027,
                                         ProjCustRec."Plot Price",
                                         ProjInstRec.Principal);
                  AddError(ErrorTxt,' ');
                END;
              END;
              IF GUIALLOWED THEN
                Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
              LineCount := LineCount + 1;
            UNTIL ProjCustRec.NEXT = 0;
            IF GUIALLOWED THEN
              Window.UPDATE(4,0);
          END;
        END;

        ProjRec."Settlement Method"::"Cost Plus":
        BEGIN
          //Check Cost Plus Entry
          IF GUIALLOWED THEN
            Window.UPDATE(3,Text028);
          LineCount := 1;
          ProjCostPlusRec.SETRANGE("Project No.",gvProj);
          ProjCostPlusRec.SETFILTER("Settlement Sheet Status", '<>%1',
                                     ProjCostPlusRec."Settlement Sheet Status"::Expired);
          ProjCostPlusRec.SETRANGE(Processed, FALSE);
          IF ProjCostPlusRec.FINDSET THEN BEGIN
            NoOfRecords := ProjCostPlusRec.COUNT;
            REPEAT
              lvHoldCustNo := ProjCostPlusRec.Principal;
              IF ChargeJobOrderToPlant() THEN
                ProjCostPlusRec.Principal := '';
              ProjCostPlusRec.CALCFIELDS("Invoiced Price");
              ProjCostPlusRec.Principal := lvHoldCustNo;
              IF ROUND(ProjCostPlusRec.Quantity * ProjCostPlusRec.DimensionalFactor * ProjCostPlusRec."Sales Price (LCY)") <> ProjCostPlusRec."Invoiced Price" THEN BEGIN
                ErrorTxt := STRSUBSTNO(Text029,
                                       ProjCostPlusRec.Principal,ProjCostPlusRec."Commission No.",ProjCostPlusRec."Settl.Sheet No.");
                AddError(ErrorTxt,' ');
              END;
              IF GUIALLOWED THEN
                Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
              LineCount := LineCount + 1;
            UNTIL ProjCostPlusRec.NEXT = 0;
            IF GUIALLOWED THEN
              Window.UPDATE(4,0);
          END;

          CheckProjEntryCostPlusCreated('');

        END;
      END;

      //Check Extension Contract
      ExtensionRec.SETRANGE("Project No.",gvProj);
      ExtensionRec.SETFILTER(
        Status,'>=%1&<%2',
        ExtensionRec.Status::Order,ExtensionRec.Status::Expired);
      ExtensionRec.SETRANGE("Settlement Method", ExtensionRec."Settlement Method"::"Cost Plus");
      IF ExtensionRec.FINDSET THEN
        REPEAT
          CheckProjEntryCostPlusCreated(ExtensionRec."Contract No.");
        UNTIL ExtensionRec.NEXT = 0;
    END;

    [External]
    PROCEDURE RentalUnitsProjectPresent@1210190020() : Boolean;
    VAR
      RentalUnit@1210190000 : Record 11012940;
    BEGIN
      RentalUnit.SETRANGE("Project No.", gvProj);
      EXIT(RentalUnit.FIND);
    END;

    [External]
    PROCEDURE CheckRentalSalesOrders@1100485006();
    VAR
      lvSalesPlantInvoiceHistory@1100485000 : Record 11012788;
      lvRemovalOrderLine@1100485002 : Record 11012789;
      lvCheckPlantInvoicedCU@1100485003 : Report 11020229;
      lvOrderIsProcessed@1100485001 : Boolean;
      lvPlantIsCompleteyInvoiced@1100485004 : Boolean;
    BEGIN
      IF NOT FPSLicenseManagement.LicenseAndReadPermissionForTable(lvSalesPlantInvoiceHistory) THEN
        EXIT;

      IF GUIALLOWED THEN
        Window.UPDATE(3,Text064);

      LineCount := 1;
      ErrorTxt := Text065;

      SalesHeader.SETRANGE("Document Type", SalesHeader."Document Type"::Order);
      SalesHeader.SETRANGE("Sales Document Type", SalesHeader."Sales Document Type"::"Sales Logistics Separated");
      SalesHeader.SETRANGE("Job No.",gvProj);
      IF SalesHeader.FINDSET THEN BEGIN
        NoOfRecords := SalesHeader.COUNT;
        REPEAT
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
          lvOrderIsProcessed := TRUE;

          IF SalesHeader.Status = SalesHeader.Status::Open THEN
            lvOrderIsProcessed := FALSE;

          IF lvOrderIsProcessed THEN BEGIN
            SalesLineRec.RESET;
            SalesLineRec.SETRANGE("Document Type", SalesHeader."Document Type");
            SalesLineRec.SETRANGE("Document No.", SalesHeader."No.");
            SalesLineRec.SETFILTER(Quantity,'<>0');
            IF SalesLineRec.FINDSET THEN BEGIN
              REPEAT
                //Check Plant
                IF SalesLineRec."Plant Type" <> '' THEN BEGIN
                  IF (SalesLineRec."Arrival Order" = '') AND (SalesLineRec."Removal Order Type" = 0) THEN
                    lvOrderIsProcessed := FALSE;

                  //Check Plant Rental
                  IF (SalesLineRec."Arrival Order" <> '') THEN BEGIN
                    //Check Arrival Orders
                    IF NOT SalesLineRec.PlantOrderIsProcessed(FALSE) THEN
                      lvOrderIsProcessed := FALSE;

                    //Check Removal Lines
                    IF lvOrderIsProcessed THEN BEGIN
                      lvRemovalOrderLine.RESET;
                      lvRemovalOrderLine.SETRANGE("Document No.", SalesLineRec."Document No.");
                      lvRemovalOrderLine.SETRANGE("Document Line No.", SalesLineRec."Line No.");
                      IF NOT lvRemovalOrderLine.FINDSET THEN
                        lvOrderIsProcessed := FALSE
                      ELSE BEGIN
                        lvRemovalOrderLine.SETFILTER(Status, '<>%1', lvRemovalOrderLine.Status::Processed);
                        IF NOT lvRemovalOrderLine.ISEMPTY THEN
                          lvOrderIsProcessed := FALSE;
                      END;
                    END;

                    //Check Invoiced Plant Rental
                    lvCheckPlantInvoicedCU.CopyInventoryFromLogistics(
                      SalesHeader,TRUE,lvPlantIsCompleteyInvoiced);
                    IF NOT lvPlantIsCompleteyInvoiced THEN
                      lvOrderIsProcessed := FALSE;
                  END;

                  //Check Plant Sales
                  IF (SalesLineRec."Removal Order Type" IN
                     [SalesLineRec."Removal Order Type"::"Plant Order",
                      SalesLineRec."Removal Order Type"::"Exit-order"]) AND
                     (SalesLineRec."Arrival Date" = 0D) AND
                     NOT SalesLineRec."Blocked for Invoicing" THEN
                  BEGIN
                    //Check Invoiced Plant Sales
                    IF (SalesLineRec.Quantity <> SalesLineRec."Quantity Invoiced") AND
                       NOT SalesLineRec."Blocked for Invoicing"
                    THEN
                      lvOrderIsProcessed := FALSE;
                  END;

                END;

                //Check Items
                IF SalesLineRec."Item No." <> '' THEN BEGIN
                  //Check Invoiced Item Sales
                  IF (SalesLineRec.Quantity <> SalesLineRec."Quantity Invoiced") AND
                     NOT SalesLineRec."Blocked for Invoicing"
                  THEN
                    lvOrderIsProcessed := FALSE;

                END;
              UNTIL (SalesLineRec.NEXT = 0) OR NOT lvOrderIsProcessed;
            END;
          END;

          IF NOT lvOrderIsProcessed THEN
            AddError(ErrorTxt,SalesHeader."No.");
        UNTIL SalesHeader.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
      SalesLineRec.RESET;
    END;

    [External]
    PROCEDURE CheckServiceInvoice@1210190005();
    VAR
      ServiceContractCtrlPeriod@1100528601 : Record 11071746;
      ContractInstallment@1100528600 : Record 11071707;
      ContractObject@1100528603 : Record 11071702;
      ServiceOrder@1100409000 : Record 11012823;
      InvoiceFrom@1100528602 : Date;
    BEGIN
      IF gvType = gvType::"Service Contract" THEN BEGIN
        //Check installments
        GetServiceContractCtrlPeriod(ServiceContractCtrlPeriod);
        CASE ServContrRec."Invoice Type" OF
          ServContrRec."Invoice Type"::Installments:
            BEGIN
              IF NOT ServContrRec."Installments based on Progress" THEN BEGIN
                ContractInstallment.SETRANGE("Service Contract No.", gvContr);
                IF ContractInstallment.FINDSET THEN
                  REPEAT
                    IF ContractInstallment."Invoiced Until" <> 0D THEN
                      InvoiceFrom := ContractInstallment."Invoiced Until" +1
                    ELSE
                      InvoiceFrom := ContractInstallment."Invoice From";
                    IF (ServContrRec."Invoice Period" = ServContrRec."Invoice Period"::Afterwards) AND (FORMAT(ContractInstallment."Invoice Interval") <> '') THEN
                      InvoiceFrom := CALCDATE(ContractInstallment."Invoice Interval", InvoiceFrom);
                    IF (InvoiceFrom <= ContractInstallment."Ending Date") OR (ContractInstallment."Ending Date" = 0D) THEN
                      IF InvoiceFrom <= ServiceContractCtrlPeriod."Ending Date" THEN BEGIN
                        ErrorTxt := STRSUBSTNO(Text075, ContractInstallment.Description);
                        AddError(ErrorTxt, ' ');
                      END;
                  UNTIL ContractInstallment.NEXT = 0;
              END;
            END;
          ServContrRec."Invoice Type"::Dynamic:
            BEGIN
              ContractObject.SETRANGE("Service Contract No.", gvContr);
              IF ContractObject.FINDSET THEN
                REPEAT
                  IF ContractObject."Invoiced Until" <> 0D THEN
                    InvoiceFrom := ContractObject."Invoiced Until" + 1
                  ELSE
                    InvoiceFrom := ContractObject."Invoice From";
                  IF (ServContrRec."Invoice Period" = ServContrRec."Invoice Period"::Afterwards) AND (FORMAT(ServContrRec."Invoice Interval") <> '') THEN
                    InvoiceFrom := CALCDATE(ServContrRec."Invoice Interval", InvoiceFrom);
                  IF (InvoiceFrom <= ContractObject."Ending Date") OR (ContractObject."Ending Date" = 0D) THEN
                    IF InvoiceFrom <= ServiceContractCtrlPeriod."Ending Date" THEN BEGIN
                      ErrorTxt := STRSUBSTNO(Text080, ContractObject."Service Object No.");
                      AddError(ErrorTxt, ' ');
                    END;
                UNTIL ContractObject.NEXT = 0;
            END;
         END;
      END;

      IF gvType = gvType::"Service Order" THEN BEGIN
        //Check Cost Plus Entry
        IF GUIALLOWED THEN
          Window.UPDATE(3,Text028);
        LineCount := 1;
        TotContrDec := 0;
        IF NOT ServiceOrder.GET(gvOrder) THEN
          ServiceOrder.INIT;
        ServCostPlusRec.SETRANGE("Service Order No.", gvOrder);
        IF ServCostPlusRec.FINDSET THEN BEGIN
          NoOfRecords := ServCostPlusRec.COUNT;
          REPEAT
            ServCostPlusRec.CALCFIELDS("Invoiced Price (LCY)");
            IF ServCostPlusRec.Chargeable THEN BEGIN
              IF ROUND(ServCostPlusRec."Invoice Price (LCY)") <> ROUND(ServCostPlusRec."Invoiced Price (LCY)") THEN BEGIN
                IF ABS(ServCostPlusRec."Invoice Price (LCY)" - ServCostPlusRec."Invoiced Price (LCY)")
                  > GenLedgerSetup."Amount Rounding Precision" THEN
                BEGIN
                  ErrorTxt := STRSUBSTNO(Text030, gvOrder);
                  AddError(ErrorTxt,' ');
                END;
              END;
            END;
            IF ServCostPlusRec."Installment Scheme" <> '' THEN
              TotContrDec := TotContrDec + ServCostPlusRec."Invoiced Price (LCY)";
            IF GUIALLOWED THEN
              Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
            LineCount := LineCount + 1;
          UNTIL ServCostPlusRec.NEXT = 0;
          IF GUIALLOWED THEN
            Window.UPDATE(4,0);
        END;

        IF ROUND(ServOrderRec."Order Amount (LCY)") <> ROUND(TotContrDec) THEN BEGIN
          ErrorTxt := STRSUBSTNO(Text025s,
                                 ServOrderRec."Order Amount (LCY)",
                                 TotContrDec,
                                 ServOrderRec.TABLECAPTION,
                                 gvOrder);
          AddError(ErrorTxt,' ');
        END;
      END;
    END;

    [External]
    PROCEDURE CheckProjEntryCostPlusCreated@1100485002(ExtContractNo@1100485000 : Code[10]);
    BEGIN
      ProjEntryRec.RESET;
      ProjEntryRec.SETCURRENTKEY("Job No.");
      ProjEntryRec.SETRANGE("Job No.", gvProj);
      ProjEntryRec.SETFILTER(ProjEntryRec."Extension Contract", '%1', ExtContractNo);
      ProjEntryRec.SETRANGE(Chargeable, TRUE);
      ProjEntryRec.SETRANGE("Cost Plus Entry Created", FALSE);

      ProjEntryRec.SETRANGE("Cost Type");
      IF (ProjSetup."Project Cost Plus Hours from" <> ProjSetup."Project Cost Plus Hours from"::"Job Ledger Entries") AND
         (NOT ProjRec."Small Project") THEN
      BEGIN
        ProjEntryRec.SETFILTER("Cost Type", '<>%1', ProjEntryRec."Cost Type"::Labor);
      END;
      IF (ProjSetup."Small Project Cost Plus Hours" <> ProjSetup."Small Project Cost Plus Hours"::"Job Ledger Entries") AND
          (ProjRec."Small Project")  THEN
      BEGIN
        ProjEntryRec.SETFILTER("Cost Type", '<>%1', ProjEntryRec."Cost Type"::Labor);
      END;

      IF ProjEntryRec.FINDFIRST THEN BEGIN
        ErrorTxt := STRSUBSTNO(Text057);
        AddError(ErrorTxt, ' ');
      END;
    END;

    [External]
    PROCEDURE CheckProjectInventory@1100525004();
    VAR
      lvProjInventEntryRec@1210190001 : Record 11012670;
      lvProjInventEntryRec2@1100525000 : Record 11012670;
    BEGIN
      IF GUIALLOWED THEN
        Window.UPDATE(3, lvProjInventEntryRec.TABLECAPTION);
      lvProjInventEntryRec.SETCURRENTKEY("Project No.", "Item Composition", "Extension Contract", "Plot No.");
      lvProjInventEntryRec.SETRANGE("Project No.", gvProj);
      IF lvProjInventEntryRec.FINDSET THEN BEGIN
        LineCount := 0;
        NoOfRecords := lvProjInventEntryRec.COUNT;
        REPEAT
          LineCount := LineCount + 1;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          IF (lvProjInventEntryRec2."Project No." <> lvProjInventEntryRec."Project No.") OR
             (lvProjInventEntryRec2."Item Composition" <> lvProjInventEntryRec."Item Composition") OR
             (lvProjInventEntryRec2."Location Code" <> lvProjInventEntryRec."Location Code") OR
             (lvProjInventEntryRec2."Bin Code" <> lvProjInventEntryRec."Bin Code") OR
             (lvProjInventEntryRec2."Shelf No." <> lvProjInventEntryRec."Shelf No.") OR
             (lvProjInventEntryRec2."Unit of Measure Code" <> lvProjInventEntryRec."Unit of Measure Code") OR
             (lvProjInventEntryRec2.Element <> lvProjInventEntryRec.Element) OR
             (lvProjInventEntryRec2."Extension Contract" <> lvProjInventEntryRec."Extension Contract") OR
             (lvProjInventEntryRec2."Plot No." <> lvProjInventEntryRec."Plot No.")
          THEN BEGIN
            lvProjInventEntryRec.CALCFIELDS("Inventory Quantity");
            IF (lvProjInventEntryRec."Inventory Quantity" <> 0) THEN BEGIN
              AddError(Text068, '');
            END;
          END;
          lvProjInventEntryRec2 := lvProjInventEntryRec;
        UNTIL (lvProjInventEntryRec.NEXT = 0) OR (lvProjInventEntryRec."Inventory Quantity" <> 0);
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    [External]
    PROCEDURE CalculateRentalUnitRevenues@1210190001() @1210190001 : Decimal;
    VAR
      lvProjEntryRec@1210190000 : Record 11072005;
    BEGIN
      lvProjEntryRec.SETRANGE("Job No.", gvProj);
      lvProjEntryRec.SETFILTER("Rental Unit", '<>%1', '');
      lvProjEntryRec.CALCSUMS("Total Price (LCY)");
      EXIT(lvProjEntryRec."Total Price (LCY)");
    END;

    [External]
    PROCEDURE CalculateRentalUnitCosts@1100529615() @1210190001 : Decimal;
    VAR
      LocProjectLedgerEntry@1210190000 : Record 11072005;
    BEGIN
      LocProjectLedgerEntry.SETRANGE("Job No.", gvProj);
      LocProjectLedgerEntry.SETFILTER("Rental Unit", '<>%1', '');
      LocProjectLedgerEntry.SETRANGE("Entry Type", LocProjectLedgerEntry."Entry Type"::Usage);
      LocProjectLedgerEntry.SETRANGE("Cost Type", CostTypeContrRec."Cost Type");
      LocProjectLedgerEntry.CALCSUMS("Total Cost (LCY)");
      EXIT(LocProjectLedgerEntry."Total Cost (LCY)");
    END;

    [External]
    PROCEDURE SetFiltersPurchLine@1210190019();
    BEGIN
      CASE gvType OF
        gvType::Project:
          BEGIN
            PurchLineRec.SETCURRENTKEY("Document Type","Job No.");
            PurchLineRec.SETRANGE("Job No.",gvProj);
          END;
        gvType::"Service Contract":
          BEGIN
            PurchLineRec.SETCURRENTKEY("Document Type","Service Contract No.");
            PurchLineRec.SETRANGE("Service Contract No.",gvContr);
            PurchLineRec.SETFILTER("Service Order No.", '%1', '');
            PurchLineRec.SETFILTER("Posting Date", gvPeriod);
          END;
        gvType::"Service Order":
          BEGIN
            PurchLineRec.SETCURRENTKEY("Document Type","Service Order No.");
            PurchLineRec.SETRANGE("Service Order No.",gvOrder);
            PurchLineRec.SETRANGE("Service Contract No.");
          END;
      END;
    END;

    [External]
    PROCEDURE SetFiltersProjRec@1210190016();
    BEGIN
      ProjRec.SETRANGE("Project Filter",gvProj);
      ProjRec.SETRANGE("Period Filter", PostingDate, PostingDate);
      IF ProjRec.GETRANGEMIN("Period Filter") = ProjRec.GETRANGEMAX("Period Filter") THEN
        ProjRec.SETRANGE("Period Filter", ProjRec.GETRANGEMIN("Period Filter"));

      SearchProgrDate.DetermineBothDates(ProjRec,FALSE);
      PrognosisActive := DeterminePrognosisDate(ProjRec);

      ProjRec."Progress Filter" := ProjRec.GETRANGEMAX("Progress Filter");
      ProjRec."Prognosis Filter" := ProjRec.GETRANGEMAX("Prognosis Filter");
      ProjRec.PrevProgressFilter := ProjRec.GETRANGEMAX(PrevProgressFilter);
      ProjRec.PrevPrognosisFilter := ProjRec.GETRANGEMAX(PrevPrognosisFilter);
    END;

    [External]
    PROCEDURE SetFiltersCostTypeContrRec@1210190010();
    BEGIN
      CostTypeContrRec.SETRANGE("Period Filter", ProjRec.GETRANGEMIN("Period Filter"), ProjRec.GETRANGEMAX("Period Filter"));
      CostTypeContrRec.SETRANGE("Progress Filter", ProjRec.GETRANGEMAX("Progress Filter"));
      CostTypeContrRec.SETRANGE(PrevProgressFilter, ProjRec.GETRANGEMAX(PrevProgressFilter));
      CostTypeContrRec.SETRANGE("Prognosis Filter", ProjRec.GETRANGEMAX("Prognosis Filter"));
      CostTypeContrRec.SETRANGE(PrevPrognosisFilter, ProjRec.GETRANGEMAX(PrevPrognosisFilter));
    END;

    [External]
    PROCEDURE SetSelectionPreclResultProject@1210190018(lvProj@11012047 : Code[20];lvPostingDate@1210190004 : Date;lvLineNo@1100525000 : Integer);
    BEGIN
      gvType := gvType::Project;
      gvProj := lvProj;
      PostingDate := lvPostingDate;

      UserSetup.GET(USERID);
      UserSetup.TESTFIELD("Resp.Pers.Closing.Proc.Project",TRUE);

      ProjSetup.GET;
      ProjSetup.TESTFIELD("Journal Template Closing Proc.");

      ProjRec.GET(gvProj);
      GlobDim1Code := ProjRec."Global Dimension 1 Code";
      ProjTypeRec.GET(ProjRec."Project Type");

      PreclosureProjectRec.GET(gvProj,PostingDate,lvLineNo);
      CheckTypePreclResultProject;
      IF PreclosureProjectRec."Result Type" = PreclosureProjectRec."Result Type"::"Provision Loss" THEN
        CheckTypeProvisionLossProject;
    END;

    [External]
    PROCEDURE SetSelectionPreclResultService@1100485003(lvContract@11012047 : Code[20];lvPostingDate@1210190004 : Date;lvYear@1100485001 : Integer;lvSourceType@1100485000 : Option;lvCostComponent@1100525000 : Code[20]);
    BEGIN
      gvType := gvType::"Service Contract";
      gvContr := lvContract;
      gvSourceType := lvSourceType;
      gvCostComponent := lvCostComponent;
      gvControlYear := lvYear;
      PostingDate := lvPostingDate;

      UserSetup.GET(USERID);
      UserSetup.TESTFIELD("Resp.Pers.Closing.Proc.Service",TRUE);

      ServSetup.GET;
      ServSetup.TESTFIELD("Journal Template Closing Proc.");

      ServContrRec.GET(gvContr);
      GlobDim1Code := ServContrRec."Global Dimension 1 Code";
      ServTypeRec.GET(ServContrRec."Service Type");
      CheckTypePreclResultService;
    END;

    [External]
    PROCEDURE SetSelectionCloseService@1100485008(IYear@1100485001 : Integer;IContractControlPeriodCode@1100528600 : Code[10]);
    BEGIN
      gvControlYear := IYear;
      gvContractControlPeriodCode := IContractControlPeriodCode;
    END;

    [External]
    PROCEDURE SetSelectionCloseServiceRestOfContract@1100529604(IYear@1100485001 : Integer;TmpServiceContractCtrlPeriod@1100529600 : TEMPORARY Record 11071746);
    BEGIN
      ServContrRec.TESTFIELD("Rest of Contract", TRUE);
      gvControlYear := IYear;
      CloseServiceRestOfContract := TRUE;
      gvContractControlPeriodCode := '';

      RestOfContractServiceContractCtrlPeriod.DELETEALL;
      RestOfContractServiceContractCtrlPeriod := TmpServiceContractCtrlPeriod;
      RestOfContractServiceContractCtrlPeriod.INSERT;
    END;

    [External]
    PROCEDURE SetSelectionProvisionsProject@1210190023(ProvisionsCosts@1100525000 : 'Actual Data,Prognosis Data,No Provision';ProvisionsRevenues@1100525001 : 'Actual Data,Prognosis Data,No Provision');
    BEGIN
      gvProvisionsCosts := ProvisionsCosts;
      gvProvisionsRevenues := ProvisionsRevenues;
    END;

    [External]
    PROCEDURE SetSelectionIgnorePlant@1100525008(IgnorePlant@1100525000 : Boolean);
    BEGIN
      gvIgnorePlant := IgnorePlant;
    END;

    [External]
    PROCEDURE CheckTypePreclResultProject@1210190021();
    BEGIN
      CASE ProjTypeRec."Method Preclosure Results" OF
        ProjTypeRec."Method Preclosure Results"::Net:
        BEGIN
          IF PostOldPreclosureResult THEN BEGIN
            ProjTypeRec.TESTFIELD("Preclosure Acc. Loss (Debit)");
            GLAcc.GET(ProjTypeRec."Preclosure Acc. Loss (Debit)");
            IF GLAcc."Income/Balance" <> GLAcc."Income/Balance"::"Income Statement" THEN BEGIN
              GLAcc."Income/Balance" := GLAcc."Income/Balance"::"Income Statement";
              ERROR(
                Text067, ProjTypeRec.FIELDCAPTION("Preclosure Acc. Loss (Debit)"), FORMAT(GLAcc."Income/Balance"),
                ProjTypeRec.TABLECAPTION, ProjTypeRec.Code);
            END;
            ProjTypeRec.TESTFIELD("Preclosure Acc. Loss (Credit)");
            GLAcc.GET(ProjTypeRec."Preclosure Acc. Loss (Credit)");
            IF GLAcc."Income/Balance" <> GLAcc."Income/Balance"::"Balance Sheet" THEN BEGIN
              GLAcc."Income/Balance" := GLAcc."Income/Balance"::"Balance Sheet";
              ERROR(
                Text067, ProjTypeRec.FIELDCAPTION("Preclosure Acc. Loss (Credit)"), FORMAT(GLAcc."Income/Balance"),
                ProjTypeRec.TABLECAPTION, ProjTypeRec.Code);
            END;
          END;
          ProjTypeRec.TESTFIELD("Preclosure Acc. Profit (Debit)");
          ProjTypeRec.TESTFIELD("Preclosure Acc. Profit (Cred)");
        END;

        ProjTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            ProjTypeRec.TESTFIELD("Preclosure Acc. Sales (Debit)");
            ProjTypeRec.TESTFIELD("Preclosure Acc. Sales (Credit)");
            ProjTypeRec.TESTFIELD("Preclosure Acc. Costs (Debit)");
            ProjTypeRec.TESTFIELD("Preclosure Acc. Costs (Credit)");
          END;

        ProjTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            ProjTypeRec.TESTFIELD("Precl. Accr. Rev. ahead (Deb)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Rev. ahead (Cr)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Rev. behind (Deb)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Rev. behind (Cr)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Cst. ahead (Deb)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Cst. ahead (Cr)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Cst. behind (Deb)");
            ProjTypeRec.TESTFIELD("Precl. Accr. Cst. behind (Cr)");
          END;
        END;

      IF NOT PostOldPreclosureResult THEN BEGIN
        ProjTypeRec.TESTFIELD("Loss Dotation");
        ProjTypeRec.TESTFIELD("Loss Provision");
      END;
    END;

    [External]
    PROCEDURE CheckTypeProvisionLossProject@1100529611();
    BEGIN
      IF NOT PostOldPreclosureResult THEN
        EXIT;

      ProjTypeRec.TESTFIELD("Release Provision Balance");
      ProjTypeRec.TESTFIELD("Release P&L");
      ProjTypeRec.TESTFIELD("Provision Loss Increase Balanc");
      ProjTypeRec.TESTFIELD("Provision Loss Increase P&L");
      ProjTypeRec.TESTFIELD("Provision Loss Decrease Balanc");
      ProjTypeRec.TESTFIELD("Provision Loss Decrease P&L");
    END;

    [External]
    PROCEDURE CheckTypePreclResultService@1100485011();
    BEGIN
      CASE ServTypeRec."Method Preclosure Results" OF
        ServTypeRec."Method Preclosure Results"::Net:
          BEGIN
            IF PostOldPreclosureResult OR (ServSetup."Service Control Method" = ServSetup."Service Control Method"::Snapshot)
            THEN BEGIN
              ServTypeRec.TESTFIELD("Preclosure Acc. Loss (Debit)");
              GLAcc.GET(ServTypeRec."Preclosure Acc. Loss (Debit)");
              IF GLAcc."Income/Balance" <> GLAcc."Income/Balance"::"Income Statement" THEN BEGIN
                GLAcc."Income/Balance" := GLAcc."Income/Balance"::"Income Statement";
                ERROR(
                  Text067, ServTypeRec.FIELDCAPTION("Preclosure Acc. Loss (Debit)"), FORMAT(GLAcc."Income/Balance"),
                  ServTypeRec.TABLECAPTION, ServTypeRec.Code);
              END;
              ServTypeRec.TESTFIELD("Preclosure Acc. Loss (Credit)");
              GLAcc.GET(ServTypeRec."Preclosure Acc. Loss (Credit)");
              IF GLAcc."Income/Balance" <> GLAcc."Income/Balance"::"Balance Sheet" THEN BEGIN
                GLAcc."Income/Balance" := GLAcc."Income/Balance"::"Balance Sheet";
                ERROR(
                  Text067, ServTypeRec.FIELDCAPTION("Preclosure Acc. Loss (Credit)"), FORMAT(GLAcc."Income/Balance"),
                  ServTypeRec.TABLECAPTION, ServTypeRec.Code);
              END;
            END;
            ServTypeRec.TESTFIELD("Preclosure Acc. Profit (Debit)");
            ServTypeRec.TESTFIELD("Preclosure Acc. Profit (Cred)");
          END;
        ServTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            ServTypeRec.TESTFIELD("Preclosure Acc. Sales (Debit)");
            ServTypeRec.TESTFIELD("Preclosure Acc. Sales (Credit)");
            ServTypeRec.TESTFIELD("Preclosure Acc. Costs (Debit)");
            ServTypeRec.TESTFIELD("Preclosure Acc. Costs (Credit)");
          END;
        ServTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            ServTypeRec.TESTFIELD("Precl. Accr. Rev. ahead (Deb)");
            ServTypeRec.TESTFIELD("Precl. Accr. Rev. ahead (Cr)");
            ServTypeRec.TESTFIELD("Precl. Accr. Rev. behind (Deb)");
            ServTypeRec.TESTFIELD("Precl. Accr. Rev. behind (Cr)");
            ServTypeRec.TESTFIELD("Precl. Accr. Cst. ahead (Deb)");
            ServTypeRec.TESTFIELD("Precl. Accr. Cst. ahead (Cr)");
            ServTypeRec.TESTFIELD("Precl. Accr. Cst. behind (Deb)");
            ServTypeRec.TESTFIELD("Precl. Accr. Cst. behind (Cr)");
          END;
      END;
      IF NOT PostOldPreclosureResult THEN BEGIN
        ServTypeRec.TESTFIELD("Loss Dotation");
        ServTypeRec.TESTFIELD("Loss Provision");
      END;
    END;

    [External]
    PROCEDURE PostPreclosureResultProject@1210190009();
    VAR
      lvProjectPreclosureResult@1100529607 : Record 11012093;
      CostDec@1100485000 : Decimal;
      RevenueDec@1100485001 : Decimal;
      ProvisionLoss@1100529603 : Decimal;
      PrevCostDec@1100529602 : Decimal;
      PrevRevenueDec@1100529601 : Decimal;
      PrevProvisionLoss@1100529600 : Decimal;
    BEGIN
      IF GUIALLOWED THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1, gvProj);
        Window.UPDATE(2, Text040);
        Window.UPDATE(3, Text049);
      END;

      IF NextLineNo = 0 THEN BEGIN
        JnlTemplRec.GET(ProjSetup."Journal Template Closing Proc.");
        JnlTemplRec.TESTFIELD("No. Series");
        ClearDocNoCde;

        NextLineNo := 10000;
      END;

      CASE ProjTypeRec."Method Preclosure Results" OF
        ProjTypeRec."Method Preclosure Results"::Net:
          BEGIN
            BalanceDec := PreclosureProjectRec."Corrected Preclosure Result";
            CostDec := 0;
            IF BalanceDec <> 0 THEN
              RevenueDec := BalanceDec
            ELSE
              RevenueDec := 0;

            PreclosureProjectRec.CALCFIELDS("Previous Actual Precl. Result");
            PrevCostDec := 0;
            PrevRevenueDec := PreclosureProjectRec."Previous Actual Precl. Result";
          END;

        ProjTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            RevenueDec := PreclosureProjectRec."Corrected Preclosure Revenue";
            CostDec := PreclosureProjectRec."Corrected Preclosure Cost";

            PreclosureProjectRec.CALCFIELDS("Prev. Actual Preclosure Rev.", "Prev. Actual Preclosure Cost");
            PrevRevenueDec := PreclosureProjectRec."Prev. Actual Preclosure Rev.";
            PrevCostDec := PreclosureProjectRec."Prev. Actual Preclosure Cost";
          END;

        ProjTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            RevenueDec := PreclosureProjectRec."Corrected Revenue Accrual";
            CostDec := PreclosureProjectRec."Corrected Cost Accrual";

            PreclosureProjectRec.CALCFIELDS("Previous Revenue Accrual", "Previous Cost Accrual");
            PrevRevenueDec := PreclosureProjectRec."Previous Revenue Accrual";
            PrevCostDec := PreclosureProjectRec."Previous Cost Accrual";
          END;
      END;

      ProvisionLoss := PreclosureProjectRec."Corrected Provision Loss";
      PreclosureProjectRec.CALCFIELDS("Previous Actual Provision Loss");
      PrevProvisionLoss := PreclosureProjectRec."Previous Actual Provision Loss";

      IF PrevCostDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, TRUE, FALSE, PrevCostDec);
        FillJobJnlLinePreclosureResult(FALSE, TRUE);
        NextLineNo := NextLineNo + 10000;
      END;

      IF PrevProvisionLoss <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, TRUE, TRUE, ABS(PrevProvisionLoss));
        FillJobJnlLinePreclosureResult(TRUE, TRUE);
        NextLineNo := NextLineNo + 10000;
      END;

      IF PrevRevenueDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, FALSE, FALSE, PrevRevenueDec);
        FillJobJnlLinePreclosureResult(FALSE, FALSE);
        NextLineNo := NextLineNo + 10000;
      END;

      lvProjectPreclosureResult.SETRANGE("Project No.", PreclosureProjectRec."Project No.");
      lvProjectPreclosureResult.SETRANGE(Posted, TRUE);
      lvProjectPreclosureResult.SETRANGE("Correction Posted", FALSE);
      IF lvProjectPreclosureResult.FINDSET THEN
        REPEAT
          lvProjectPreclosureResult."Correction Posted by" := USERID;
          lvProjectPreclosureResult."Correction Posted on" := TODAY;
          lvProjectPreclosureResult."Correction Posted" := TRUE;
          lvProjectPreclosureResult.MODIFY;
        UNTIL lvProjectPreclosureResult.NEXT = 0;

      IF CostDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(FALSE, TRUE, FALSE, CostDec);
        FillJobJnlLinePreclosureResult(FALSE, TRUE);
        NextLineNo := NextLineNo + 10000;
        PreclosureProjectRec."Account Cost" := GenJnlLineRec."Account No.";
        PreclosureProjectRec."Balance Account Cost" := GenJnlLineRec."Bal. Account No.";
        PreclosureProjectRec."G/L Register No. Cost" := NewGenRegRec."No.";
      END;

      IF ProvisionLoss <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(FALSE, TRUE, TRUE, ABS(ProvisionLoss));
        FillJobJnlLinePreclosureResult(TRUE, TRUE);
        NextLineNo := NextLineNo + 10000;
        PreclosureProjectRec."Account Provision Loss" := GenJnlLineRec."Account No.";
        PreclosureProjectRec."Balance Account Provision Loss" := GenJnlLineRec."Bal. Account No.";
        PreclosureProjectRec."G/L Reg. No. Provision Loss" := NewGenRegRec."No.";
      END;

      IF RevenueDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(FALSE, FALSE, FALSE, RevenueDec);
        FillJobJnlLinePreclosureResult(FALSE, FALSE);
        NextLineNo := NextLineNo + 10000;
        PreclosureProjectRec."Account Sales" := GenJnlLineRec."Account No.";
        PreclosureProjectRec."Balance Account Sales" := GenJnlLineRec."Bal. Account No.";
        PreclosureProjectRec."G/L Register No. Sales" := NewGenRegRec."No.";
      END;

      PreclosureProjectRec."User ID" := USERID;
      PreclosureProjectRec."Process Date" := TODAY;
      PreclosureProjectRec.Posted := TRUE;

      CASE ProjTypeRec."Method Preclosure Results" OF
        ProjTypeRec."Method Preclosure Results"::Net:
          PreclosureProjectRec."Actual Preclosure Result" := BalanceDec;
        ProjTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            PreclosureProjectRec."Actual Preclosure Revenue" := RevenueDec;
            PreclosureProjectRec."Actual Preclosure Cost" := CostDec;
          END;
        ProjTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            PreclosureProjectRec."Actual Revenue Accrual" := RevenueDec;
            PreclosureProjectRec."Actual Cost Accrual" := CostDec;
          END;
      END;
      PreclosureProjectRec."Actual Provision Loss" := ProvisionLoss;
      PreclosureProjectRec.MODIFY;
    END;

    [External]
    PROCEDURE FillGenJnlLinePreclResultProj@1100485032(lContra@1100485002 : Boolean;lTypeCost@1100485001 : Boolean;lProvisionLoss@1100525000 : Boolean;lBalanceDec@1100485000 : Decimal);
    VAR
      lAccount@1100485003 : Code[20];
      lBalAccount@1100485004 : Code[20];
    BEGIN
      IF lProvisionLoss THEN BEGIN
        IF PostOldPreclosureResult THEN BEGIN
          IF lContra AND (ProjTypeRec."Release P&L" <> '') THEN BEGIN
            ProjTypeRec.TESTFIELD("Release Provision Balance");
            ProjTypeRec.TESTFIELD("Release P&L");
            lAccount := ProjTypeRec."Release Provision Balance";
            lBalAccount := ProjTypeRec."Release P&L";
          END ELSE BEGIN
            IF lTypeCost THEN BEGIN
              ProjTypeRec.TESTFIELD("Provision Loss Increase Balanc");
              ProjTypeRec.TESTFIELD("Provision Loss Increase P&L");
              lAccount := ProjTypeRec."Provision Loss Increase Balanc";
              lBalAccount := ProjTypeRec."Provision Loss Increase P&L";
            END ELSE BEGIN
              ProjTypeRec.TESTFIELD("Provision Loss Decrease Balanc");
              ProjTypeRec.TESTFIELD("Provision Loss Decrease P&L");
              lAccount := ProjTypeRec."Provision Loss Decrease Balanc";
              lBalAccount := ProjTypeRec."Provision Loss Decrease P&L";
            END;
          END;
        END ELSE BEGIN
          lAccount := ProjTypeRec."Loss Dotation";
          lBalAccount := ProjTypeRec."Loss Provision";
        END;
      END ELSE BEGIN
        CASE ProjTypeRec."Method Preclosure Results" OF
          ProjTypeRec."Method Preclosure Results"::Net:
            BEGIN
              IF lTypeCost THEN BEGIN
                lAccount := ProjTypeRec."Preclosure Acc. Loss (Debit)";
                lBalAccount := ProjTypeRec."Preclosure Acc. Loss (Credit)";
              END ELSE BEGIN
                lAccount := ProjTypeRec."Preclosure Acc. Profit (Debit)";
                lBalAccount := ProjTypeRec."Preclosure Acc. Profit (Cred)";
              END;
            END;
          ProjTypeRec."Method Preclosure Results"::Gross:
            BEGIN
              IF lTypeCost THEN BEGIN
                lAccount := ProjTypeRec."Preclosure Acc. Costs (Debit)";
                lBalAccount := ProjTypeRec."Preclosure Acc. Costs (Credit)"
              END ELSE BEGIN
                lAccount := ProjTypeRec."Preclosure Acc. Sales (Debit)";
                lBalAccount := ProjTypeRec."Preclosure Acc. Sales (Credit)";
              END;
            END;
          ProjTypeRec."Method Preclosure Results"::GrossPL:
            BEGIN
              IF lTypeCost THEN BEGIN
                IF lBalanceDec < 0 THEN BEGIN
                  lBalAccount := ProjTypeRec."Precl. Accr. Cst. ahead (Deb)";
                  lAccount := ProjTypeRec."Precl. Accr. Cst. ahead (Cr)";
                END ELSE BEGIN
                  lAccount := ProjTypeRec."Precl. Accr. Cst. behind (Deb)";
                  lBalAccount := ProjTypeRec."Precl. Accr. Cst. behind (Cr)";
                END;
              END ELSE BEGIN
                IF lBalanceDec < 0 THEN BEGIN
                  lBalAccount := ProjTypeRec."Precl. Accr. Rev. ahead (Deb)";
                  lAccount := ProjTypeRec."Precl. Accr. Rev. ahead (Cr)";
                END ELSE BEGIN
                  lAccount := ProjTypeRec."Precl. Accr. Rev. behind (Deb)";
                  lBalAccount := ProjTypeRec."Precl. Accr. Rev. behind (Cr)";
                END;
              END;
            END;
          END;

      END;

      FillGenJnlLinePreclosureResult(lContra, lProvisionLoss, lBalanceDec, lAccount, lBalAccount);
    END;

    [External]
    PROCEDURE FillGenJnlLinePreclResultServ@1100485033(lContra@1100485002 : Boolean;lTypeCost@1100485001 : Boolean;lBalanceDec@1100485000 : Decimal;IProvisionLoss@1100529670 : Boolean);
    VAR
      lAccount@1100485004 : Code[20];
      lBalAccount@1100485003 : Code[20];
    BEGIN
      IF IProvisionLoss THEN BEGIN
        lAccount := ServTypeRec."Loss Dotation";
        lBalAccount := ServTypeRec."Loss Provision";
      END ELSE
        CASE ServTypeRec."Method Preclosure Results" OF
          ServTypeRec."Method Preclosure Results"::Net:
            BEGIN
              IF lTypeCost THEN BEGIN
                lAccount := ServTypeRec."Preclosure Acc. Loss (Debit)";
                lBalAccount := ServTypeRec."Preclosure Acc. Loss (Credit)";
              END ELSE BEGIN
                lAccount := ServTypeRec."Preclosure Acc. Profit (Debit)";
                lBalAccount := ServTypeRec."Preclosure Acc. Profit (Cred)";
              END;
            END;
          ServTypeRec."Method Preclosure Results"::Gross:
            BEGIN
              IF lTypeCost THEN BEGIN
                lAccount := ServTypeRec."Preclosure Acc. Costs (Debit)";
                lBalAccount := ServTypeRec."Preclosure Acc. Costs (Credit)";
              END ELSE BEGIN
                lAccount := ServTypeRec."Preclosure Acc. Sales (Debit)";
                lBalAccount := ServTypeRec."Preclosure Acc. Sales (Credit)";
              END;
            END;
          ServTypeRec."Method Preclosure Results"::GrossPL:
            BEGIN
              IF lTypeCost THEN BEGIN
                IF lBalanceDec < 0 THEN BEGIN
                  lBalAccount := ServTypeRec."Precl. Accr. Cst. ahead (Deb)";
                  lAccount := ServTypeRec."Precl. Accr. Cst. ahead (Cr)";
                END ELSE BEGIN
                  lAccount := ServTypeRec."Precl. Accr. Cst. behind (Deb)";
                  lBalAccount := ServTypeRec."Precl. Accr. Cst. behind (Cr)";
                END;
              END ELSE BEGIN
                IF lBalanceDec < 0 THEN BEGIN
                  lBalAccount := ServTypeRec."Precl. Accr. Rev. ahead (Deb)";
                  lAccount := ServTypeRec."Precl. Accr. Rev. ahead (Cr)";
                END ELSE BEGIN
                  lAccount := ServTypeRec."Precl. Accr. Rev. behind (Deb)";
                  lBalAccount := ServTypeRec."Precl. Accr. Rev. behind (Cr)";
                END;
              END;
            END;
        END;

      FillGenJnlLinePreclosureResult(lContra, FALSE, lBalanceDec, lAccount, lBalAccount)
    END;

    [External]
    PROCEDURE FillGenJnlLinePreclosureResult@1210190011(lContra@1210190000 : Boolean;lProvisionLoss@1100525000 : Boolean;lBalanceDec@1100485001 : Decimal;lAccount@1100485003 : Code[20];lBalAccount@1100485002 : Code[20]);
    BEGIN
      WITH GenJnlLineRec DO BEGIN
        INIT;
        "Document No." := GetDocNoCde;
        "Reason Code" := JnlTemplRec."Reason Code";
        "Source Code" := JnlTemplRec."Source Code";
        "Account Type" := "Account Type"::"G/L Account";
        "System-Created Entry" := TRUE;
        "Posting Date" := PostingDate;

        "Line No." := NextLineNo;

        VALIDATE("Account No.", lAccount);
        "Gen. Prod. Posting Group" := '';
        "Gen. Bus. Posting Group" := '';
        "VAT Prod. Posting Group" :='';
        "VAT Bus. Posting Group" := '';
        "Gen. Posting Type" := 0;
        "Bal. Account Type" := "Bal. Account Type"::"G/L Account";
        IF gvProj <> '' THEN BEGIN
          IF lProvisionLoss THEN
            Description := COPYSTR(STRSUBSTNO(Text051, ProjRec.TABLECAPTION, gvProj),1,MAXSTRLEN(Description))
          ELSE
            Description := COPYSTR(STRSUBSTNO(Text050, ProjRec.TABLECAPTION, gvProj),1,MAXSTRLEN(Description));
          "Closed Project No." := gvProj;
        END ELSE BEGIN
          Description := COPYSTR(STRSUBSTNO(Text050, ServContrRec.TABLECAPTION, gvContr),1,MAXSTRLEN(Description));
          "Closed Service Contract No." := gvContr;
        END;
        VALIDATE("Bal. Account No.", lBalAccount);
        "Bal. Gen. Prod. Posting Group" := '';
        "Bal. Gen. Bus. Posting Group" := '';
        "Bal. VAT Prod. Posting Group" := '';
        "Bal. VAT Bus. Posting Group" := '';
        "Bal. Gen. Posting Type" := 0;

        "Posting No. Series" := NoSeriesCde;
        "Skip WIP Check" := TRUE;

        IF NOT lContra THEN
          VALIDATE(Amount, lBalanceDec)
        ELSE
          VALIDATE(Amount, (lBalanceDec * -1));

        CASE gvType OF
          gvType::Project:
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service-Contract",gvContr,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ProjRec."Global Dimension 1 Code");
            END;
          gvType::"Service Contract":
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service-Contract",gvContr,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ServContrRec."Global Dimension 1 Code");
            END;
          gvType::"Service Order":
            BEGIN
              CreateDim(
                DATABASE::Job,gvProj,
                DATABASE::"Service Order",gvOrder,
                DATABASE::"Plant Number", DimMgt.MakeCombinedPlantNo("Plant Type","Plant No."),
                DATABASE::"Plant Type","Plant Type",
                DimMgt.TypeToTableID1("Account Type"),"Account No.",
                DimMgt.TypeToTableID1("Bal. Account Type"),"Bal. Account No.",
                DATABASE::"Salesperson/Purchaser","Salespers./Purch. Code",
                DATABASE::Campaign,"Campaign No.");
              VALIDATE("Shortcut Dimension 1 Code", ServOrderRec."Global Dimension 1 Code");
            END;
        END;

      END;

      PostOrPreview(TRUE);

      IF lContra = FALSE THEN
        PostGenJnlLine.GetGLReg(NewGenRegRec);
    END;

    [External]
    PROCEDURE StartGenJnl@1100485000();
    VAR
      GenJnlForm@1100485000 : Page 39;
    BEGIN
      IF NOT ShowGenJnl THEN
        EXIT;

      COMMIT;

      GenJnlForm.SetTemplate(ProjSetup."Journal Template Closing Proc.", ProjSetup."Journal Batch Closing Proc.");
      GenJnlForm.RUNMODAL;
    END;

    [External]
    PROCEDURE ChargeJobOrderToPlant@1100485001() : Boolean;
    BEGIN
      //* Customer number is empty at sales invoices
      EXIT(ProjRec."Small Project" AND ProjRec."Plant Job Order");
    END;

    [External]
    PROCEDURE InitDoc@1100525001();
    BEGIN
      DocCode := '~';
    END;

    [External]
    PROCEDURE ReversePreclosureResults@1100528200();
    VAR
      PrevCostDec@1100529602 : Decimal;
      PrevRevenueDec@1100529601 : Decimal;
      PrevProvisionLoss@1100529600 : Decimal;
    BEGIN
      IF PostOldPreclosureResult THEN BEGIN
        ReversePreclosureResultsOLD;
        ReverseProvisionsOLD(TRUE);
        EXIT;
      END;

      PreclosureProjectRec.SETCURRENTKEY("Project No.", Posted);
      PreclosureProjectRec.SETRANGE("Project No.", gvProj);
      PreclosureProjectRec.SETRANGE(Posted, TRUE);
      PreclosureProjectRec.SETRANGE("Correction Posted", FALSE);
      IF PreclosureProjectRec.ISEMPTY THEN
        EXIT;
      PreclosureProjectRec.FINDLAST;

      CASE ProjTypeRec."Method Preclosure Results" OF
        ProjTypeRec."Method Preclosure Results"::Net:
          BEGIN
            PreclosureProjectRec.CALCFIELDS("Previous Actual Precl. Result");
            PrevCostDec := 0;
            PrevRevenueDec := PreclosureProjectRec."Previous Actual Precl. Result";
          END;

        ProjTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            PreclosureProjectRec.CALCFIELDS("Prev. Actual Preclosure Rev.", "Prev. Actual Preclosure Cost");
            PrevRevenueDec := PreclosureProjectRec."Prev. Actual Preclosure Rev.";
            PrevCostDec := PreclosureProjectRec."Prev. Actual Preclosure Cost";
          END;

        ProjTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            PreclosureProjectRec.CALCFIELDS("Previous Revenue Accrual", "Previous Cost Accrual");
            PrevRevenueDec := PreclosureProjectRec."Previous Revenue Accrual";
            PrevCostDec := PreclosureProjectRec."Previous Cost Accrual";
          END;
      END;

      PreclosureProjectRec.CALCFIELDS("Previous Actual Provision Loss");
      PrevProvisionLoss := PreclosureProjectRec."Previous Actual Provision Loss";

      IF PrevCostDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, TRUE, FALSE, PrevCostDec);
        FillJobJnlLinePreclosureResult(FALSE, TRUE);
        NextLineNo := NextLineNo + 10000;
      END;

      IF PrevProvisionLoss <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, TRUE, TRUE, ABS(PrevProvisionLoss));
        FillJobJnlLinePreclosureResult(TRUE, TRUE);
        NextLineNo := NextLineNo + 10000;
      END;

      IF PrevRevenueDec <> 0 THEN BEGIN
        NewGenRegRec."No." := 0;
        FillGenJnlLinePreclResultProj(TRUE, FALSE, FALSE, PrevRevenueDec);
        FillJobJnlLinePreclosureResult(FALSE, FALSE);
        NextLineNo := NextLineNo + 10000;
      END;

      IF NOT gPreview THEN
        PreclosureProjectRec.MODIFYALL("Correction Posted", TRUE);
    END;

    LOCAL PROCEDURE ReversePreclosureResultsOLD@1100529614();
    VAR
      JobLedgerEntry@1100529600 : Record 11072005;
    BEGIN
      IF NOT PostOldPreclosureResult THEN
        EXIT;
      PreclosureProjectRec.SETCURRENTKEY("Project No.",Posted);
      PreclosureProjectRec.SETRANGE(PreclosureProjectRec."Project No.", gvProj);
      PreclosureProjectRec.SETRANGE(PreclosureProjectRec.Posted,TRUE);
      IF PreclosureProjectRec.ISEMPTY THEN
        EXIT;
      CheckTypePreclResultProject;

      CASE ProjTypeRec."Method Preclosure Results" OF
        ProjTypeRec."Method Preclosure Results"::Net:
          BEGIN
            JobLedgerEntry.SETRANGE("Job No.", gvProj);
            JobLedgerEntry.SETRANGE("Entry Type", JobLedgerEntry."Entry Type"::Usage);
            JobLedgerEntry.CALCSUMS("Actual Preclosure Result");
            BalanceDec := JobLedgerEntry."Actual Preclosure Result";
            IF BalanceDec <> 0 THEN BEGIN
              FillGenJnlLinePreclResultProj(TRUE, BalanceDec < 0, FALSE, ABS(BalanceDec));
              //Attention: function PostGenJnlLine.RunWithCheck (posting of G/L Entry)
              //post the G/L Entry but also the reverse entry. Variable GenJnlLine will contain
              //these values after posting (this is true for all places in this source when sequence of
              //functions FillGenJnlLine(..) and FillJobJnlLine(..) is used.
              FillJobJnlLinePreclosureResult(FALSE,BalanceDec < 0);
              NextLineNo := NextLineNo + 10000;
            END;
          END;
        ProjTypeRec."Method Preclosure Results"::Gross:
          BEGIN
            PreclosureProjectRec.CALCSUMS("Actual Preclosure Revenue", "Actual Preclosure Cost");
            IF PreclosureProjectRec."Actual Preclosure Cost" <> 0 THEN BEGIN
              FillGenJnlLinePreclResultProj(TRUE, TRUE, FALSE, PreclosureProjectRec."Actual Preclosure Cost");
              FillJobJnlLinePreclosureResult(FALSE,TRUE);
              NextLineNo := NextLineNo + 10000;
            END;
            IF PreclosureProjectRec."Actual Preclosure Revenue" <> 0 THEN BEGIN
              FillGenJnlLinePreclResultProj(TRUE, FALSE, FALSE, PreclosureProjectRec."Actual Preclosure Revenue");
              FillJobJnlLinePreclosureResult(FALSE,FALSE);
              NextLineNo := NextLineNo + 10000;
            END;
          END;
        ProjTypeRec."Method Preclosure Results"::GrossPL:
          BEGIN
            IF PreclosureProjectRec.FINDLAST THEN BEGIN
              PreclosureProjectRec.CALCFIELDS("Previous Revenue Accrual", "Previous Cost Accrual");
              IF PreclosureProjectRec."Previous Cost Accrual" <> 0 THEN BEGIN
                FillGenJnlLinePreclResultProj(TRUE, TRUE, FALSE,PreclosureProjectRec."Previous Cost Accrual");
                FillJobJnlLinePreclosureResult(FALSE,FALSE);
                NextLineNo += 10000;
              END;
              IF PreclosureProjectRec."Previous Revenue Accrual" <> 0 THEN BEGIN
                FillGenJnlLinePreclResultProj(TRUE, FALSE, FALSE, PreclosureProjectRec."Previous Revenue Accrual");
                FillJobJnlLinePreclosureResult(FALSE,TRUE);
                NextLineNo += 10000;
              END;
            END;
          END;
      END;

      IF NOT gPreview THEN
        PreclosureProjectRec.MODIFYALL("Correction Posted", TRUE);
    END;

    LOCAL PROCEDURE ReverseProvisionsOLD@1100525003(lFinish@1100525000 : Boolean);
    BEGIN
      IF NOT PostOldPreclosureResult THEN
        EXIT;
      PreclosureProjectRec.SETCURRENTKEY("Project No.",Posted);
      PreclosureProjectRec.SETRANGE(PreclosureProjectRec."Project No.", gvProj);
      PreclosureProjectRec.SETRANGE(PreclosureProjectRec.Posted,TRUE);
      PreclosureProjectRec.CALCSUMS("Actual Provision");
      IF PreclosureProjectRec."Actual Provision" <> 0 THEN BEGIN
        CheckTypeProvisionLossProject;
        BalanceDec := PreclosureProjectRec."Actual Provision";
        FillGenJnlLinePreclResultProj(TRUE, BalanceDec > 0, TRUE, BalanceDec);
        FillJobJnlLinePreclosureResult(TRUE, FALSE);
        NextLineNo := NextLineNo + 10000;
        IF NOT lFinish THEN BEGIN
          PreclosureProjectRec."Actual Provision" := -BalanceDec;
          PreclosureProjectRec.MODIFY;
        END;
      END;

      IF NOT gPreview THEN
        PreclosureProjectRec.MODIFYALL("Correction Posted", TRUE);
    END;

    [External]
    PROCEDURE FinishAfterClosureProvisons@1210190002();
    BEGIN
      // Be sure Setselection is called before execute
      IF GUIALLOWED THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1,gvProj);
        Window.UPDATE(2,Text040);
        Window.UPDATE(3,Text072);
      END;

      IF NOT ProjSetup."Provisions at Closure" THEN
        EXIT;

      IF ProjTypeRec."No Closing Posts Cost Plus Pr." AND
         (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN
      BEGIN
        EXIT;
      END ELSE BEGIN
        CreateCostControl.RUN(ProjRec);
        COMMIT;
      END;

      //Locking
      GenJnlLineRec.LOCKTABLE;
      GLEntry.LOCKTABLE;
      IF GLEntry.FINDLAST THEN;
      //

      IF (NextLineNo = 0) THEN BEGIN
        JnlTemplRec.GET(ProjSetup."Journal Template Closing Proc.");
        JnlTemplRec.TESTFIELD("No. Series");
        ClearDocNoCde;

        NextLineNo := 10000;
        GenJnlLineRec.RESET;
        GenJnlLineRec.SETRANGE("Journal Template Name",ProjSetup."Journal Template Closing Proc.");
        GenJnlLineRec.SETRANGE("Journal Batch Name",ProjSetup."Journal Batch Closing Proc.");
        IF GenJnlLineRec.FINDLAST THEN
          NextLineNo := GenJnlLineRec."Line No." + 10000;

        GenJnlLineRec.RESET;
      END;

      CostTypeContrRec.SETRANGE("Project No.",gvProj);
      CostTypeContrRec.SETFILTER("Project Filter", gvProj);

      ProjEntryRec2.SETCURRENTKEY("Job No.","Cost Type","Entry Type","Posting Date","Purchase Action");
      ProjEntryRec2.SETRANGE("Job No.",gvProj);

      FOR i := 1 TO 6 DO BEGIN
        BalanceDec  := 0;
        FinishedDec := 0;
        CASE i OF
          1:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Labor);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Labor);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
              BalanceDec := (FinishedDec + BalanceDec);
            END;
          2:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Material);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Material);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
              BalanceDec := (FinishedDec + BalanceDec);
            END;
          3:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Subcontracting);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Subcontracting);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
              BalanceDec := (FinishedDec + BalanceDec);
            END;
          4:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Plant);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Plant);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
              BalanceDec := (FinishedDec + BalanceDec);
            END;
          5:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Sundry);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Sundry);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
              BalanceDec := (FinishedDec + BalanceDec);
            END;
          6:BEGIN
              ProjEntryRec2.SETRANGE("Cost Type");
              ProjEntryRec2.CALCSUMS("Closed Revenues");
              FinishedDec := ProjEntryRec2."Closed Revenues";

              ProjRec.SETRANGE("Project Filter", ProjRec."No.");
              ProjRec.SETRANGE("Rental Unit Filter", '');
              ProjRec.CALCFIELDS(Revenues);
              BalanceDec := -1 * (ProjRec.Revenues - FinishedDec) ;

            END;
        END;

        IF BalanceDec <> 0 THEN BEGIN
          FillGenJnlLine(6, 0);
          FillJobJnlLine;
          NextLineNo := NextLineNo + 10000;
        END;

      END;

      ClosePurchaseOrderControl;

      IF GUIALLOWED THEN
        Window.CLOSE;
      COMMIT; // To release locks when running batches.
    END;

    [External]
    PROCEDURE CalcCostAmountsAfterClosure@1210190012();
    BEGIN
      CostTypeContrRec.FINDFIRST;
      CostTypeContrRec.CALCFIELDS("Actual Costs", "Open (Inventory)",
                                  "Open Ovh. Surch. (Inventory)", Prognosis,
                                  "Actual Costs Externals", "Prognosis Total Cost");

      BalanceDec := CostTypeContrRec."Actual Costs";
    END;

    [External]
    PROCEDURE CalcFinishedAmountAfterClosure@1210190022();
    BEGIN
      ProjEntryRec2.CALCSUMS("Closed Costs");
      FinishedDec := ProjEntryRec2."Closed Costs";
    END;

    [External]
    PROCEDURE RecalcAfterClosureProvisons@1100528243(lvVersion@1100525005 : Integer);
    VAR
      lProjectProvisionUpdate@1100528245 : Record 11072161;
    BEGIN
      // Be sure Setselection is called before execute
      IF GUIALLOWED THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1,gvProj);
        Window.UPDATE(2,Text087);
        Window.UPDATE(3,Text072);
      END;

      IF NOT ProjSetup."Provisions at Closure" THEN
        EXIT;

      IF ProjTypeRec."No Closing Posts Cost Plus Pr." AND
         (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN
      BEGIN
        EXIT;
      END ELSE BEGIN
        CreateCostControl.RUN(ProjRec);
        COMMIT;
      END;

      SetFiltersProjRec;

      lProjectProvisionUpdate.SETRANGE("Project No.", gvProj);
      lProjectProvisionUpdate.SETRANGE("Posting Date", PostingDate);
      lProjectProvisionUpdate.SETRANGE("Version No.", lvVersion);
      lProjectProvisionUpdate.DELETEALL;
      lProjectProvisionUpdate.RESET;

      NextLineNo := 10000;

      CostTypeContrRec.SETRANGE("Project No.",gvProj);
      CostTypeContrRec.SETFILTER("Project Filter", gvProj);

      ProjEntryRec2.SETCURRENTKEY("Job No.","Cost Type","Entry Type","Posting Date","Purchase Action");
      ProjEntryRec2.SETRANGE("Job No.",gvProj);

      FOR i := 1 TO 6 DO BEGIN
        BalanceDec   := 0;
        FinishedDec  := 0;

        CASE i OF
          1:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Labor);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Labor);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
            END;
          2:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Material);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Material);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
            END;
          3:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Subcontracting);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Subcontracting);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
            END;
          4:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Plant);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Plant);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
            END;
          5:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Sundry);
              ProjEntryRec2.SETRANGE("Cost Type",ProjEntryRec2."Cost Type"::Sundry);
              CalcCostAmountsAfterClosure;
              CalcFinishedAmountAfterClosure;
            END;
          6:BEGIN
              ProjEntryRec2.SETRANGE("Cost Type");
              ProjEntryRec2.CALCSUMS("Closed Revenues");
              FinishedDec := -1 * ProjEntryRec2."Closed Revenues";

              ProjRec.SETRANGE("Project Filter", ProjRec."No.");
              ProjRec.SETRANGE("Rental Unit Filter", '');
              ProjRec.CALCFIELDS(Revenues);
              ProjRec.CALCFIELDS(Revenues,"Project Contract Amount","Extension Contract Amount","Options Contract Amount");

              BalanceDec := ProjRec.Revenues;

            END;
        END;

        lProjectProvisionUpdate.INIT;
        lProjectProvisionUpdate.VALIDATE("Project No.", gvProj);
        lProjectProvisionUpdate.VALIDATE("Posting Date", PostingDate);
        lProjectProvisionUpdate.VALIDATE("Version No.", lvVersion);
        lProjectProvisionUpdate.VALIDATE("Line No.", NextLineNo);

        CASE i OF
          1: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Labor);
          2: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Material);
          3: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Subcontracting);
          4: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Plant);
          5: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Sundry);
          6: lProjectProvisionUpdate.VALIDATE("Cost Type", lProjectProvisionUpdate."Cost Type"::Revenue);
         END;

        lProjectProvisionUpdate.VALIDATE("Finished Amount", -1 * FinishedDec);
        lProjectProvisionUpdate.VALIDATE("Actual Amount", BalanceDec);
        lProjectProvisionUpdate.VALIDATE("Amount Provision",
            (lProjectProvisionUpdate."Finished Amount" - lProjectProvisionUpdate."Actual Amount"));
        lProjectProvisionUpdate.INSERT(TRUE);
        NextLineNo := NextLineNo + 10000;

      END;

      IF GUIALLOWED THEN
        Window.CLOSE;
      COMMIT; // To release locks when running batches.
    END;

    [External]
    PROCEDURE CalcCostProvisions@1100528244();
    BEGIN
      IF ProjSetup."Provisions at Closure" AND
        (gvProvisionsCosts <> gvProvisionsCosts::"No Provision")
      THEN BEGIN

        IF PrognosisActive AND (gvProvisionsCosts=gvProvisionsCosts::"Prognosis Data") THEN BEGIN
          IF ((PrognosisRec."Rough Prognosis Total Revenues" <> 0) OR
              (PrognosisRec."Rough Prognosis Total Cost" <> 0))
          THEN BEGIN
            //Check if rough prognosis is allowed
            ProjTypeRec.TESTFIELD("Cost. Acc Rough Prognosis Cost");
            ProjTypeRec.TESTFIELD("Prov. Acc Rough Prognosis Cost");
          END ELSE
            ProvisionDec := CostTypeContrRec."Prognosis Total Cost" - CostTypeContrRec."Actual Costs";

        END ELSE BEGIN
          ProvisionDec :=
            CostContMgt.OutstandingCostType(CostTypeContrRec,TRUE) +
            CostContMgt.ReceivedNotInvoicedCostType(CostTypeContrRec,TRUE) +
            CostContMgt.OpenOvhPurchCostType(CostTypeContrRec,TRUE) +
            CostTypeContrRec."Open (Inventory)" +
            CostTypeContrRec."Open Ovh. Surch. (Inventory)";
        END;
      END;
    END;

    [External]
    PROCEDURE RePostAfterClosureProvisons@1100528245(lvVersion@1100525005 : Integer);
    VAR
      lProjectProvisionUpdate@1100528245 : Record 11072160;
      lProjectProvisionUpdateLine@1100528244 : Record 11072161;
      RoughPrognosis@1100525000 : Boolean;
    BEGIN
      // Be sure Setselection is called before execute
      IF GUIALLOWED THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1,gvProj);
        Window.UPDATE(2,Text040);
        Window.UPDATE(3,Text072);
      END;

      IF NOT ProjSetup."Provisions at Closure" THEN
        EXIT;

      IF ProjTypeRec."No Closing Posts Cost Plus Pr." AND
         (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN
      BEGIN
        EXIT;
      END;

      //Locking
      GenJnlLineRec.LOCKTABLE;
      GLEntry.LOCKTABLE;
      IF GLEntry.RECORDLEVELLOCKING THEN
        IF GLEntry.FINDLAST THEN;
      //

      SetFiltersProjRec;

      lProjectProvisionUpdate.GET(gvProj,PostingDate,lvVersion);

      IF (NextLineNo = 0) THEN BEGIN
        JnlTemplRec.GET(ProjSetup."Journal Template Closing Proc.");
        JnlTemplRec.TESTFIELD("No. Series");
        ClearDocNoCde;

        NextLineNo := 10000;
        GenJnlLineRec.RESET;
        GenJnlLineRec.SETRANGE("Journal Template Name",ProjSetup."Journal Template Closing Proc.");
        GenJnlLineRec.SETRANGE("Journal Batch Name",ProjSetup."Journal Batch Closing Proc.");
        IF GenJnlLineRec.FINDLAST THEN
          NextLineNo := GenJnlLineRec."Line No." + 10000;

        GenJnlLineRec.RESET;
      END;

      PrognosisRec.INIT;
      PrognosisRec.RESET;
      IF ProjRec."Single/Main/Sub Project" = ProjRec."Single/Main/Sub Project"::"Main Project" THEN BEGIN
        PrognosisRec.SETRANGE("Main Project No.", ProjRec."No.");
        PrognosisRec.SETCURRENTKEY("Main Project No.", "Prognosis Date");
      END ELSE BEGIN
        PrognosisRec.SETRANGE("Project No.",ProjRec."No.");
        PrognosisRec.SETCURRENTKEY("Project No.", "Prognosis Date");
      END;

      RoughPrognosis := FALSE;
      IF PrognosisRec.FINDLAST THEN BEGIN
        IF (PrognosisRec."Prognosis Level" = PrognosisRec."Prognosis Level"::Rough) OR
           ((PrognosisRec."Rough Prognosis Total Revenues" <> 0) OR (PrognosisRec."Rough Prognosis Total Cost" <> 0))
        THEN BEGIN
           RoughPrognosis := TRUE;
        END;
      END;

      lProjectProvisionUpdateLine.SETRANGE("Project No.", gvProj);
      lProjectProvisionUpdateLine.SETRANGE("Posting Date", PostingDate);
      lProjectProvisionUpdateLine.SETRANGE("Version No.", lvVersion);
      lProjectProvisionUpdateLine.SETRANGE(Posted, FALSE);

      IF lProjectProvisionUpdateLine.FINDSET(TRUE, FALSE) THEN BEGIN
        REPEAT

          i := lProjectProvisionUpdateLine."Cost Type" + 1;
          IF RoughPrognosis AND (lProjectProvisionUpdateLine."Cost Type" = lProjectProvisionUpdateLine."Cost Type"::Sundry) THEN
            i := 8;

          ProvisionDec := lProjectProvisionUpdateLine."Amount to Post";

          IF lProjectProvisionUpdateLine."Cost Type" = lProjectProvisionUpdateLine."Cost Type"::Revenue  THEN
            ProvisionDec := -1 * ProvisionDec;

          IF ProvisionDec <> 0 THEN BEGIN
            FillGenJnlLine(2, 0);
            FillJobJnlLine;
            NextLineNo := NextLineNo + 10000;
          END;

          lProjectProvisionUpdateLine.VALIDATE(Posted, TRUE);
          lProjectProvisionUpdateLine.MODIFY;

        UNTIL lProjectProvisionUpdateLine.NEXT = 0;

        lProjectProvisionUpdate.VALIDATE(Posted, TRUE);
        lProjectProvisionUpdate.VALIDATE("Posted by", USERID);
        lProjectProvisionUpdate.MODIFY;

      END;

      IF GUIALLOWED THEN
        Window.CLOSE;
      COMMIT; // To release locks when running batches.
    END;

    [External]
    PROCEDURE PrognosisToProvisons@1100525006(lvVersion@1100525007 : Integer);
    VAR
      RoughPrognosis@1100528241 : Boolean;
      PrognosisDec@1100528242 : Decimal;
      lProjectProvisionUpdate@1100528245 : Record 11072161;
      EndDat@1100525005 : Date;
      ActualDec@1100525006 : Decimal;
    BEGIN
      // Be sure Setselection is called before execute
      IF GUIALLOWED THEN BEGIN
        Window.OPEN(Text001 + Text007 + Text008);
        Window.UPDATE(1,gvProj);
        Window.UPDATE(2,Text087);
        Window.UPDATE(3,Text072);
      END;

      IF NOT ProjSetup."Provisions at Closure" THEN
        EXIT;

      IF ProjTypeRec."No Closing Posts Cost Plus Pr." AND
         (ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus") THEN
      BEGIN
        EXIT;
      END ELSE BEGIN
        CreateCostControl.RUN(ProjRec);
        COMMIT;
      END;

      SetFiltersProjRec;

      //
      PrognosisRec.INIT;
      PrognosisRec.RESET;
      IF ProjRec."Single/Main/Sub Project" = ProjRec."Single/Main/Sub Project"::"Main Project" THEN BEGIN
        PrognosisRec.SETRANGE("Main Project No.", ProjRec."No.");
        PrognosisRec.SETCURRENTKEY("Main Project No.", "Prognosis Date");
      END ELSE BEGIN
        PrognosisRec.SETRANGE("Project No.",ProjRec."No.");
        PrognosisRec.SETCURRENTKEY("Project No.", "Prognosis Date");
      END;

      IF ProjRec.GETFILTER("Period Filter") <> '' THEN BEGIN
        EndDat := ProjRec.GETRANGEMAX("Period Filter");
        PrognosisRec.SETRANGE("Prognosis Date",0D,EndDat);
      END;

      IF PrognosisRec.FINDLAST THEN BEGIN
        ProjRec.SETRANGE("Prognosis Filter",PrognosisRec."Prognosis Date");
        ProjRec.SETRANGE(PrevPrognosisFilter,0D);
      END ELSE BEGIN
        IF GUIALLOWED THEN
          Window.CLOSE;
        COMMIT; // To release locks when running batches.
        EXIT;
      END;

      PrognosisRec.SETRANGE("Used in Closing Project");
      IF PrognosisRec.NEXT(-1) = -1 THEN BEGIN
        ProjRec.SETRANGE(PrevPrognosisFilter, PrognosisRec."Prognosis Date");
        IF PrognosisRec.NEXT(1) = 1 THEN;   //recover last prognosis
      END;

      lProjectProvisionUpdate.RESET;
      lProjectProvisionUpdate.SETRANGE("Project No.", gvProj);
      lProjectProvisionUpdate.SETRANGE("Posting Date", PostingDate);
      lProjectProvisionUpdate.SETRANGE("Version No.", lvVersion);

      CostTypeContrRec.SETRANGE("Project No.",gvProj);
      CostTypeContrRec."Project No." := gvProj;
      CostTypeContrRec."Main Project No." := ProjRec."Main Project";
      CostTypeContrRec.SETFILTER("Project Filter", gvProj);
      CostTypeContrRec.SETRANGE("Prognosis Filter",PrognosisRec."Prognosis Date");

      RoughPrognosis := FALSE;
      IF ((PrognosisRec."Rough Prognosis Total Revenues" <> 0) OR
                 (PrognosisRec."Rough Prognosis Total Cost" <> 0))
      THEN BEGIN
        ProjTypeRec.TESTFIELD("Cost. Acc Rough Prognosis Cost");
        ProjTypeRec.TESTFIELD("Prov. Acc Rough Prognosis Cost");
        RoughPrognosis := TRUE;
      END;

      ActualDec := 0;
      FOR i := 1 TO 6 DO BEGIN
        PrognosisDec  := 0;

        CASE i OF
          1:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Labor);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Labor;
              CostTypeContrRec.CALCFIELDS(Prognosis,"Actual Costs");
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Labor);
              PrognosisDec := CostContMgt.PrognTotCostCostType(CostTypeContrRec, TRUE);
            END;
          2:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Material);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Material;
              CostTypeContrRec.CALCFIELDS(Prognosis,"Actual Costs");
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Material);
              PrognosisDec := CostContMgt.PrognTotCostCostType(CostTypeContrRec, TRUE);
            END;
          3:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Subcontracting);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Subcontracting;
              CostTypeContrRec.CALCFIELDS(Prognosis,"Actual Costs");
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Subcontracting);
              PrognosisDec := CostContMgt.PrognTotCostCostType(CostTypeContrRec, TRUE);
            END;
          4:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Plant);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Plant;
              CostTypeContrRec.CALCFIELDS(Prognosis,"Actual Costs");
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Plant);
              PrognosisDec := CostContMgt.PrognTotCostCostType(CostTypeContrRec, TRUE);
            END;
          5:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Sundry);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Sundry;
              CostTypeContrRec.CALCFIELDS(Prognosis,"Actual Costs");
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Sundry);
              PrognosisDec := CostContMgt.PrognTotCostCostType(CostTypeContrRec, TRUE);
            END;
          6:BEGIN
              CostTypeContrRec.SETRANGE("Cost Type",CostTypeContrRec."Cost Type"::Revenue);
              CostTypeContrRec."Cost Type" := CostTypeContrRec."Cost Type"::Revenue;
              CostTypeContrRec.FINDFIRST;
              CostTypeContrRec.CALCFIELDS("Prognosis Revenues",Revenues);
              PrognosisDec := CostTypeContrRec."Prognosis Revenues";
              lProjectProvisionUpdate.SETRANGE("Cost Type", lProjectProvisionUpdate."Cost Type"::Revenue);
            END;
        END;

        IF lProjectProvisionUpdate.FINDLAST THEN BEGIN
          ActualDec := ActualDec + lProjectProvisionUpdate."Actual Amount";
          IF NOT RoughPrognosis THEN BEGIN
            IF i <> 6 THEN BEGIN
              lProjectProvisionUpdate.VALIDATE("Amount Provision",
                (PrognosisDec - lProjectProvisionUpdate."Actual Amount"));
              lProjectProvisionUpdate.MODIFY(TRUE);
            END ELSE BEGIN
              lProjectProvisionUpdate.VALIDATE("Amount Provision",
                (PrognosisDec - lProjectProvisionUpdate."Actual Amount"));
              lProjectProvisionUpdate.MODIFY(TRUE);
            END;
          END ELSE BEGIN
            IF i = 5 THEN BEGIN
              lProjectProvisionUpdate.VALIDATE("Amount Provision",
                (PrognosisRec."Rough Prognosis Total Cost" - ActualDec));
              lProjectProvisionUpdate.MODIFY(TRUE);
            END;
            IF i = 6 THEN BEGIN
              lProjectProvisionUpdate.VALIDATE("Amount Provision",
                (PrognosisRec."Rough Prognosis Total Revenues" - lProjectProvisionUpdate."Actual Amount"));
              lProjectProvisionUpdate.MODIFY(TRUE);
            END;
          END;
        END;
        NextLineNo := NextLineNo + 10000;

      END;

      IF GUIALLOWED THEN
        Window.CLOSE;
      COMMIT; // To release locks when running batches.
    END;

    [External]
    PROCEDURE ReverseServicePreclosureResults@1100528209();
    VAR
      ServiceContrPreclDetail@1100528201 : Record 11071767;
      ServicePreclosureResultLine@1100528200 : Record 11072313;
      ServiceCategory@1100529670 : Record 11071985;
      TmpServiceCategory@1100529671 : TEMPORARY Record 11071985;
      PrevCost@1100529672 : Decimal;
      PrevRevenue@1100529673 : Decimal;
      PrevProvisionLoss@1100529674 : Decimal;
      TotalingType@1100529660 : Integer;
    BEGIN
      IF ServSetup."Service Control Method" = ServSetup."Service Control Method"::Snapshot THEN BEGIN
        CLEAR(ServicePreclosureResultLine);
        ServiceContrPreclDetail.SETCURRENTKEY("Service Contract No.", "Contract Control Period Code", Posted);
        ServiceContrPreclDetail.SETRANGE("Service Contract No.", gvContr);
        IF ServContrRec.Status < ServContrRec.Status::Expired THEN
          ServiceContrPreclDetail.SETRANGE("Contract Control Period Code", gvContractControlPeriodCode);
        ServiceContrPreclDetail.SETRANGE(Posted, TRUE);
        ServiceContrPreclDetail.SETRANGE("Service Contract WIP Processed", FALSE);
        IF NOT ServiceContrPreclDetail.ISEMPTY THEN BEGIN
          ServTypeRec.GET(ServContrRec."Service Type");
          CheckTypePreclResultService;

          IF ServTypeRec."Method Preclosure Results" = ServTypeRec."Method Preclosure Results"::Net THEN BEGIN
            ServiceContrPreclDetail.CALCSUMS("Total Preclosure Result");
            BalanceDec := ServiceContrPreclDetail."Total Preclosure Result";
            IF BalanceDec <> 0 THEN BEGIN
              FillGenJnlLinePreclResultServ(TRUE, BalanceDec < 0, ABS(BalanceDec), FALSE);
              FillServJnlLinePreclResult(BalanceDec < 0, ServicePreclosureResultLine);
              NextLineNo += 10000;
            END;
          END ELSE BEGIN
            ServiceContrPreclDetail.CALCSUMS("Total Preclosure Cost", "Total Preclosure Revenue");
            IF ServiceContrPreclDetail."Total Preclosure Cost" <> 0 THEN BEGIN
              FillGenJnlLinePreclResultServ(TRUE, TRUE, ServiceContrPreclDetail."Total Preclosure Cost", FALSE);
              FillServJnlLinePreclResult(TRUE, ServicePreclosureResultLine);
              NextLineNo += 10000;
            END;
            IF ServiceContrPreclDetail."Total Preclosure Revenue" <> 0 THEN BEGIN
              FillGenJnlLinePreclResultServ(TRUE, FALSE, ServiceContrPreclDetail."Total Preclosure Revenue", FALSE);
              FillServJnlLinePreclResult(FALSE, ServicePreclosureResultLine);
              NextLineNo += 10000;
            END;
          END;
        END;
      END ELSE BEGIN
        IF PostOldPreclosureResult THEN BEGIN
          ReverseServicePreclosureResultsOld;
          EXIT;
        END;

        ServicePreclosureResultLine.SETCURRENTKEY("Service Contract No.");
        ServicePreclosureResultLine.SETRANGE("Service Contract No.", gvContr);
        IF ServContrRec.Status < ServContrRec.Status::Expired THEN
          ServicePreclosureResultLine.SETRANGE("Control Period Code", gvContractControlPeriodCode);
        ServicePreclosureResultLine.SETRANGE(Posted, TRUE);
        ServicePreclosureResultLine.SETRANGE("Correction Posted", FALSE);
        ServicePreclosureResultLine.SETRANGE("Service Contract WIP Processed", FALSE);
        CLEAR(TmpServiceCategory);
        TmpServiceCategory.INSERT;
        IF ServContrRec."Result Calc. on Total Contract" OR (ServContrRec."Budget Based on" = ServContrRec."Budget Based on"::"Maintenance Scheme") THEN
          ServicePreclosureResultLine.SETRANGE("Line Type", ServicePreclosureResultLine."Line Type"::Period)
        ELSE BEGIN
          ServicePreclosureResultLine.SETRANGE("Line Type", ServicePreclosureResultLine."Line Type"::"Service Category");
          ServiceCategory.SETRANGE("Service Contract No.", ServContrRec."No.");
          IF ServiceCategory.FINDSET THEN
            REPEAT
              TmpServiceCategory := ServiceCategory;
              TmpServiceCategory.INSERT;
            UNTIL ServiceCategory.NEXT = 0;
        END;
        IF NOT ServicePreclosureResultLine.ISEMPTY THEN BEGIN
          ServTypeRec.GET(ServContrRec."Service Type");
          CheckTypePreclResultService;

          FOR TotalingType := 0 TO 2 DO BEGIN
            ServicePreclosureResultLine.SETRANGE("Totaling Type", TotalingType);
            TmpServiceCategory.FINDSET;
            REPEAT
              ServicePreclosureResultLine.SETRANGE("Service Category", TmpServiceCategory.Code);
              IF ServicePreclosureResultLine.FINDLAST THEN BEGIN
                IF TmpServiceCategory."Service Type" <> '' THEN BEGIN
                  ServTypeRec.GET(TmpServiceCategory."Service Type");
                  CheckTypePreclResultService;
                END ELSE
                  ServTypeRec.GET(ServContrRec."Service Type");
                CASE ServTypeRec."Method Preclosure Results" OF
                  ServTypeRec."Method Preclosure Results"::Net:
                    BEGIN
                      ServicePreclosureResultLine.CALCFIELDS("Prev. Actual Preclosure Result");
                      PrevCost := 0;
                      IF ServicePreclosureResultLine."Prev. Actual Preclosure Result" > 0 THEN
                        PrevRevenue := ServicePreclosureResultLine."Prev. Actual Preclosure Result"
                      ELSE
                        PrevRevenue := 0;
                    END;
                  ServTypeRec."Method Preclosure Results"::Gross:
                    BEGIN
                      ServicePreclosureResultLine.CALCFIELDS("Prev. Actual Preclosure Rev.", "Prev. Actual Preclosure Cost");
                      PrevRevenue := ServicePreclosureResultLine."Prev. Actual Preclosure Rev.";
                      PrevCost := ServicePreclosureResultLine."Prev. Actual Preclosure Cost";
                    END;
                  ServTypeRec."Method Preclosure Results"::GrossPL:
                    BEGIN
                      ServicePreclosureResultLine.CALCFIELDS("Previous Revenue Accrual", "Previous Cost Accrual");
                      PrevRevenue := ServicePreclosureResultLine."Previous Revenue Accrual";
                      PrevCost := ServicePreclosureResultLine."Previous Cost Accrual";
                    END;
                END;

                ServicePreclosureResultLine.CALCFIELDS("Previous Actual Provision Loss");
                PrevProvisionLoss := ServicePreclosureResultLine."Previous Actual Provision Loss";

                IF PrevCost <> 0 THEN BEGIN
                  FillGenJnlLinePreclResultServ(TRUE, TRUE, PrevCost, FALSE);
                  FillServJnlLinePreclResult(TRUE, ServicePreclosureResultLine);
                  NextLineNo += 10000;
                END;
                IF PrevProvisionLoss <> 0 THEN BEGIN
                  FillGenJnlLinePreclResultServ(TRUE, TRUE, ABS(PrevProvisionLoss), TRUE);
                  FillServJnlLinePreclResult(TRUE, ServicePreclosureResultLine);
                  NextLineNo += 10000;
                END;
                IF PrevRevenue <> 0 THEN BEGIN
                  FillGenJnlLinePreclResultServ(TRUE, FALSE, PrevRevenue, FALSE);
                  FillServJnlLinePreclResult(FALSE, ServicePreclosureResultLine);
                  NextLineNo += 10000;
                END;

                ServicePreclosureResultLine.MARK(TRUE);
              END;
            UNTIL TmpServiceCategory.NEXT = 0;
          END;
        END;
      END;

      IF PostEntries THEN
        IF ServSetup."Service Control Method" = ServSetup."Service Control Method"::Snapshot THEN
          ServiceContrPreclDetail.MODIFYALL("Service Contract WIP Processed", TRUE)
        ELSE BEGIN
          ServicePreclosureResultLine.SETRANGE("Totaling Type");
          ServicePreclosureResultLine.SETRANGE("Service Category");
          ServicePreclosureResultLine.MARKEDONLY(TRUE);
          IF ServicePreclosureResultLine.FINDSET(TRUE) THEN
            REPEAT
              ServicePreclosureResultLine."Service Contract WIP Processed" := TRUE;
              ServicePreclosureResultLine.VALIDATE("Correction Posted", TRUE);
              ServicePreclosureResultLine.MODIFY;
            UNTIL ServicePreclosureResultLine.NEXT = 0;
        END;
    END;

    [External]
    PROCEDURE ReverseServicePreclosureResultsOld@1100529600();
    VAR
      ServicePreclosureResultLine@1100528200 : Record 11072313;
    BEGIN
      IF NOT PostOldPreclosureResult THEN
        EXIT;
      IF ServSetup."Service Control Method" <> ServSetup."Service Control Method"::"Real-Time" THEN
        EXIT;

      ServicePreclosureResultLine.SETCURRENTKEY("Service Contract No.");
      ServicePreclosureResultLine.SETRANGE("Service Contract No.", gvContr);
      IF ServContrRec.Status < ServContrRec.Status::Expired THEN
        ServicePreclosureResultLine.SETRANGE("Control Period Code", gvContractControlPeriodCode);
      ServicePreclosureResultLine.SETRANGE(Posted, TRUE);
      ServicePreclosureResultLine.SETRANGE("Service Contract WIP Processed", FALSE);
      ServicePreclosureResultLine.SETRANGE("Line Type", ServicePreclosureResultLine."Line Type"::Period);
      IF NOT ServicePreclosureResultLine.ISEMPTY THEN BEGIN
        CheckTypePreclResultService;
        CASE ServTypeRec."Method Preclosure Results" OF
          ServTypeRec."Method Preclosure Results"::Net:
            BEGIN
              ServicePreclosureResultLine.CALCSUMS("Actual Preclosure Result");
              BalanceDec := ServicePreclosureResultLine."Actual Preclosure Result";
              IF BalanceDec <> 0 THEN BEGIN
                FillGenJnlLinePreclResultServ(TRUE, BalanceDec < 0, ABS(BalanceDec), FALSE);
                FillServJnlLinePreclResult(BalanceDec < 0, ServicePreclosureResultLine);
                NextLineNo += 10000;
              END;
            END;
          ServTypeRec."Method Preclosure Results"::Gross:
            BEGIN
              ServicePreclosureResultLine.CALCSUMS("Actual Preclosure Cost", "Actual Preclosure Revenue");
              IF ServicePreclosureResultLine."Actual Preclosure Cost" <> 0 THEN BEGIN
                FillGenJnlLinePreclResultServ(TRUE, TRUE, ServicePreclosureResultLine."Actual Preclosure Cost", FALSE);
                FillServJnlLinePreclResult(TRUE, ServicePreclosureResultLine);
                NextLineNo += 10000;
              END;
              IF ServicePreclosureResultLine."Actual Preclosure Revenue" <> 0 THEN BEGIN
                FillGenJnlLinePreclResultServ(TRUE, FALSE, ServicePreclosureResultLine."Actual Preclosure Revenue", FALSE);
                FillServJnlLinePreclResult(FALSE, ServicePreclosureResultLine);
                NextLineNo += 10000;
              END;
            END;
          ServTypeRec."Method Preclosure Results"::GrossPL:
            BEGIN
              IF ServicePreclosureResultLine.FINDLAST THEN BEGIN
                ServicePreclosureResultLine.CALCFIELDS("Previous Revenue Accrual", "Previous Cost Accrual");
                IF ServicePreclosureResultLine."Previous Cost Accrual" <> 0 THEN BEGIN
                  FillGenJnlLinePreclResultServ(TRUE, TRUE,ServicePreclosureResultLine."Previous Cost Accrual", FALSE);
                  FillServJnlLinePreclResult(TRUE, ServicePreclosureResultLine);
                  NextLineNo += 10000;
                END;
                IF ServicePreclosureResultLine."Previous Revenue Accrual" <> 0 THEN BEGIN
                  FillGenJnlLinePreclResultServ(TRUE, FALSE,ServicePreclosureResultLine."Previous Revenue Accrual", FALSE);
                  FillServJnlLinePreclResult(FALSE, ServicePreclosureResultLine);
                  NextLineNo += 10000;
                END;
              END;
            END;
        END;
      END;

      IF NOT gPreview THEN BEGIN
        IF CorrectOldPreclosureResult THEN BEGIN
          ServicePreclosureResultLine.SETRANGE("Line Type");
          ServicePreclosureResultLine.MODIFYALL("Correction Posted", TRUE);
          ServicePreclosureResultLine.SETRANGE("Line Type", ServicePreclosureResultLine."Line Type"::Period);
        END;
        ServicePreclosureResultLine.MODIFYALL("Service Contract WIP Processed", TRUE);
      END;
    END;

    [External]
    PROCEDURE SetFilterServLedgerEntry@1100525005(VAR lvServEntryRec@1100525000 : Record 11012819);
    BEGIN
      gvServEntryRec.COPY(lvServEntryRec);
      FiltersOnServEntry := (gvServEntryRec.GETFILTERS <> '');
    END;

    [External]
    PROCEDURE SetServOrderExtraTest@1100409000(ICheckInvoicesPaid@1100525000 : Boolean;ICloseServiceOrderViaClosingPeriod@1100528600 : Boolean);
    BEGIN
      CheckInvoicesPaid := ICheckInvoicesPaid;
      CloseServiceOrderViaClosingPeriod := ICloseServiceOrderViaClosingPeriod;
    END;

    [External]
    PROCEDURE ClearDocNoCde@1210190015();
    BEGIN
      gvDocNoCde := '';
    END;

    [External]
    PROCEDURE GetDocNoCde@1210190017() lvDocNoCde : Code[20];
    VAR
      NoSeriesMgt@1210190000 : Codeunit 396;
    BEGIN
      IF NOT PostEntries THEN
        EXIT;
      IF gvDocNoCde = '' THEN BEGIN
        CLEAR(NoSeriesMgt);
        NoSeriesMgt.InitSeries(JnlTemplRec."No. Series",' ',PostingDate,gvDocNoCde,NoSeriesCde);
      END;
      lvDocNoCde := gvDocNoCde;
    END;

    [External]
    PROCEDURE DeterminePrognosisDate@1210190024(VAR ProjectRec@11012000 : Record 11072003) : Boolean;
    VAR
      EndDat@11012001 : Date;
      RetVal@1210190000 : Boolean;
    BEGIN
      //Copied from codeunit 11012029 because of filter on:
      PrognosisRec.INIT;
      PrognosisRec.RESET;
      IF ProjectRec."Single/Main/Sub Project" = ProjectRec."Single/Main/Sub Project"::"Main Project" THEN BEGIN
        PrognosisRec.SETRANGE("Main Project No.", ProjectRec."No.");
        PrognosisRec.SETCURRENTKEY("Main Project No.", "Prognosis Date");
      END ELSE BEGIN
        PrognosisRec.SETRANGE("Project No.",ProjectRec."No.");
        PrognosisRec.SETCURRENTKEY("Project No.", "Prognosis Date");
      END;

      IF ProjectRec.GETFILTER("Period Filter") <> '' THEN BEGIN
        EndDat := ProjectRec.GETRANGEMAX("Period Filter");
        PrognosisRec.SETRANGE("Prognosis Date",0D,EndDat);
      END;

      PrognosisRec.SETRANGE("Used in Closing Project", TRUE);

      IF PrognosisRec.FINDLAST THEN BEGIN
        ProjectRec.SETRANGE("Prognosis Filter",PrognosisRec."Prognosis Date");
        ProjectRec.SETRANGE(PrevPrognosisFilter,0D);
        RetVal := TRUE;
      END ELSE BEGIN
        ProjectRec.SETRANGE("Prognosis Filter",0D);
        ProjectRec.SETRANGE(PrevPrognosisFilter,0D);
        RetVal := FALSE;
      END;

      IF RetVal THEN BEGIN
        PrognosisRec.SETRANGE("Used in Closing Project");
        IF PrognosisRec.NEXT(-1) = -1 THEN BEGIN
          ProjectRec.SETRANGE(PrevPrognosisFilter, PrognosisRec."Prognosis Date");
          IF PrognosisRec.NEXT(1) = 1 THEN;   //recover last prognosis
        END;
      END;

      EXIT(RetVal);
    END;

    [External]
    PROCEDURE ClosePurchaseOrderControl@1100409001();
    VAR
      PurchOrderControlLine@1100409000 : Record 11020221;
    BEGIN
      IF gPreview THEN
        EXIT;

      IF GUIALLOWED THEN
        Window.UPDATE(3,Text037);
      PurchLineRec.RESET;
      SetFiltersPurchLine;
      PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Order);
      IF PurchLineRec.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := PurchLineRec.COUNT;
        REPEAT
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
          PurchOrderControlLine.RESET;
          PurchOrderControlLine.SETRANGE("Order No.", PurchLineRec."Document No.");
          PurchOrderControlLine.SETRANGE("Order Line No.", PurchLineRec."Line No.");
          PurchOrderControlLine.SETRANGE("Line Type", PurchOrderControlLine."Line Type"::Closing);
          IF PurchOrderControlLine.ISEMPTY THEN
            PurchLineRec.CreatePurchOrderControl(FALSE);
        UNTIL PurchLineRec.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    [External]
    PROCEDURE CheckAllocationRevenues@1100409002(_ContractAmount@1100409001 : Decimal;VAR _OpenInstallmentAmount@1100409000 : Decimal) : Boolean;
    VAR
      AllocationRevenuesProjects@1100409002 : Record 11020685;
      ProjectInstallment@1100409003 : Record 11012018;
      InstallmentInvoiced@1100409004 : Decimal;
    BEGIN
      InstallmentInvoiced := 0;

      IF ProjRec."Settlement Method" = ProjRec."Settlement Method"::"Cost Plus" THEN
        EXIT(FALSE);

      IF (_ContractAmount = 0) OR
         (ProjRec.Revenues <> 0) OR
         (ProjRec."Single/Main/Sub Project" <> ProjRec."Single/Main/Sub Project"::"Main Project") THEN
        EXIT(FALSE);

      AllocationRevenuesProjects.SETRANGE("Main Project", ProjRec."No.");
      IF AllocationRevenuesProjects.ISEMPTY THEN
        EXIT(FALSE);

      ProjectInstallment.SETRANGE("Project No.", ProjRec."No.");
      IF ProjectInstallment.FINDSET THEN BEGIN
        REPEAT
          ProjectInstallment.CALCFIELDS("Invoiced Price (LCY)");
          InstallmentInvoiced := InstallmentInvoiced + ProjectInstallment."Invoiced Price (LCY)";
        UNTIL ProjectInstallment.NEXT = 0;
      END;

      _OpenInstallmentAmount := _ContractAmount - InstallmentInvoiced;

      EXIT(TRUE);
    END;

    [External]
    PROCEDURE PostOrPreview@1100528246(lPost@1100528240 : Boolean);
    BEGIN
      IF PostEntries THEN BEGIN
        IF lPost THEN
          PostGenJnlLine.RunWithCheck(GenJnlLineRec)
        ELSE
          GenJnlLineRec.INSERT;
      END ELSE BEGIN
        AddGenJnlLineTemp(lPost);
      END;
    END;

    [External]
    PROCEDURE AddGenJnlLineTemp@1100528249(lPost@1100528240 : Boolean);
    BEGIN
      IF lPost THEN BEGIN
        TempGenJnlLineRec1.COPY(GenJnlLineRec);
        TempGenJnlLineRec1.INSERT;
      END ELSE BEGIN
        TempGenJnlLineRec2.COPY(GenJnlLineRec);
        TempGenJnlLineRec2.INSERT;
      END;
    END;

    [External]
    PROCEDURE ExportTempGenJnlLine1@1100528241(VAR IOTempGenJnlLine@1100528240 : TEMPORARY Record 81);
    VAR
      LineNo@1100528241 : Integer;
    BEGIN
      LineNo := 1;
      IF IOTempGenJnlLine.FINDLAST THEN
        LineNo := IOTempGenJnlLine."Line No." + 1;

      IF TempGenJnlLineRec1.FIND('-') THEN
        REPEAT
          IOTempGenJnlLine := TempGenJnlLineRec1;
          IOTempGenJnlLine."Line No." := LineNo;
          IOTempGenJnlLine.INSERT(FALSE);
          LineNo += 1;
        UNTIL TempGenJnlLineRec1.NEXT = 0;
      COMMIT;
    END;

    [External]
    PROCEDURE ExportTempGenJnlLine2@1100528242(VAR IOTempGenJnlLine@1100528240 : TEMPORARY Record 81);
    VAR
      LineNo@1100528241 : Integer;
    BEGIN
      LineNo := 1;
      IF IOTempGenJnlLine.FINDLAST THEN
        LineNo := IOTempGenJnlLine."Line No." + 1;

      IF TempGenJnlLineRec2.FIND('-') THEN
        REPEAT
          IOTempGenJnlLine := TempGenJnlLineRec2;
          IOTempGenJnlLine."Line No." := LineNo;
          IOTempGenJnlLine.INSERT(FALSE);
          LineNo += 1;
        UNTIL TempGenJnlLineRec2.NEXT = 0;
      COMMIT;
    END;

    LOCAL PROCEDURE CheckServTypePosting@1100525009(ServTypeCode@1100525000 : Code[20];ServTypeOtherCode@1100525001 : Code[20]) : Boolean;
    VAR
      ServiceType@1100525002 : Record 11012814;
      ServiceTypeOther@1100525003 : Record 11012814;
    BEGIN
      ServiceType.GET(ServTypeCode);
      ServiceTypeOther.GET(ServTypeOtherCode);
      IF ServiceType."No Closing Ledger Entries" <> ServiceTypeOther."No Closing Ledger Entries" THEN
        ERROR(Text094,ServOrderRec.TABLECAPTION,gvOrder,ServiceType.FIELDCAPTION("No Closing Ledger Entries"));

      ServTypeRec := ServiceType;
      EXIT(NOT ServiceType."No Closing Ledger Entries");
    END;

    LOCAL PROCEDURE UpdateProjectStatus@1100525007();
    BEGIN
      IF gPreview THEN
        EXIT;

      ProjRec.GET(gvProj);
      ProjRec."Project Status" := ProjRec."Project Status"::Finished;
      ProjRec."Posting Date Closing" := PostingDate;
      ProjRec.MODIFY;
    END;

    LOCAL PROCEDURE UpdateServiceOrderSatus@1100525010();
    VAR
      ServiceOrder@1100525004 : Record 11012823;
      ServiceOrderOld@1100525000 : Record 11012823;
      ReferencePoint@1100525002 : Record 11020271;
      DocumentReferencePoint@1100525001 : Record 11020296;
      ServiceLogbook@1100525003 : Record 11012855;
    BEGIN
      IF gPreview THEN
        EXIT;

      ServiceOrder.GET(gvOrder);
      IF ServiceOrder.Status >= ServiceOrder.Status::Finished THEN
        EXIT;

      ServiceOrderOld := ServiceOrder;

      ReferencePoint.SETRANGE("Triggered by Status ServOrder", ReferencePoint."Triggered by Status ServOrder"::Finished);
      ReferencePoint.SETRANGE(Apply, ReferencePoint.Apply::ServOrder);
      IF ReferencePoint.FINDFIRST THEN BEGIN
        DocumentReferencePoint.InsertDocRefPointWithNo(
          DocumentReferencePoint.Type::ServOrder, gvOrder, ReferencePoint."No.", TODAY, TIME);
        ServiceOrder.GET(gvOrder); // Previous insert of Reference Point changes serviceorder
        ServiceOrder.UpdateNextDeadline;
      END;
      ServiceOrder.Status := ServiceOrder.Status::Finished;
      ServiceOrder."Closing Date" := PostingDate;
      IF DocumentReferencePoint.GetNewActRefPoint >= 0 THEN
        ServiceOrder."Actual Reference Point (Gantt)" := DocumentReferencePoint.GetNewActRefPoint;
      ServiceOrder.MODIFY;
      ServiceOrder.UpdateWorkOrderInfo(-10);

      ServiceLogbook.StoreChange(2, ServiceOrder."No.",
        ServiceLogbook.FormatDescription(ServiceOrder.FIELDCAPTION(Status),
        FORMAT(ServiceOrderOld.Status), FORMAT(ServiceOrder.Status)));
    END;

    LOCAL PROCEDURE UpdatePlantLocStatus@1100525012();
    VAR
      PlantManagementCompany@1100525000 : Record 11020586;
    BEGIN
      IF gPreview THEN
        EXIT;

      IF PlantManagementCompany.FINDSET THEN
        REPEAT
          PlantLocRec.RESET;
          PlantLocRec.CHANGECOMPANY(PlantManagementCompany."Plant Company");
          PlantLocRec.SETCURRENTKEY("Company Name", "Project No.", "Service Order No.", "Employee No.");
          IF PlantManagementCompany."Plant Company" = COMPANYNAME THEN
            PlantLocRec.SETFILTER("Company Name",'%1|%2','',COMPANYNAME)
          ELSE
            PlantLocRec.SETRANGE("Company Name",COMPANYNAME);
          IF gvType = gvType::Project THEN
            PlantLocRec.SETRANGE("Project No.",gvProj)
          ELSE BEGIN
            PlantLocRec.SETRANGE("Project No.",'');
            PlantLocRec.SETRANGE("Service Order No.",gvOrder);
          END;
          PlantLocRec.SETFILTER(Status, '<%1', PlantLocRec.Status::"Administrative Finished");
          IF NOT PlantLocRec.ISEMPTY THEN
            PlantLocRec.MODIFYALL(Status,PlantLocRec.Status::"Administrative Finished");
        UNTIL PlantManagementCompany.NEXT = 0;
    END;

    LOCAL PROCEDURE CheckUnprocessedHours@1100525013(VAR HourAccountingLine@1100525000 : Record 11012039);
    VAR
      YearNo@1100528502 : Integer;
      WeekNo@1100528501 : Integer;
      EmployeeNo@1100528500 : Code[20];
    BEGIN
      IF gvType = gvType::Project THEN
        HourAccountingLine.SETRANGE("Project No.",gvProj);
      IF gvType = gvType::"Service Order" THEN
        HourAccountingLine.SETRANGE("Service Order No.",gvOrder);
      IF HourAccountingLine.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := HourAccountingLine.COUNT;
        InitDoc;
        REPEAT
          IF (DocCode <> HourAccountingLine."Document No.") OR
             (YearNo <> HourAccountingLine.Year) OR
             (WeekNo <> HourAccountingLine.Week) OR
             (EmployeeNo <> HourAccountingLine."Employee No.")
          THEN BEGIN
            DocCode := HourAccountingLine."Document No.";
            YearNo := HourAccountingLine.Year;
            WeekNo := HourAccountingLine.Week;
            EmployeeNo := HourAccountingLine."Employee No.";
            ErrorTxt := STRSUBSTNO(Text021s,YearNo,WeekNo,EmployeeNo,HourAccountingLine.CURRENTCOMPANY);
            AddError(ErrorTxt,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL HourAccountingLine.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    LOCAL PROCEDURE CheckUnprocessedHoursUAR@1100525014(VAR UARHourAccountingLine@1100525000 : Record 11012610);
    VAR
      YearNo@1100528502 : Integer;
      WeekNo@1100528501 : Integer;
      EmployeeNo@1100528500 : Code[20];
    BEGIN
      CASE gvType OF
        gvType::Project:
          UARHourAccountingLine.SETRANGE("Project No.",gvProj);
        gvType::"Service Contract":
          BEGIN
            UARHourAccountingLine.SETRANGE("Service Contract No.",gvContr);
            UARHourAccountingLine.SETFILTER("Service Order No.",'%1','');
          END;
        gvType::"Service Order":
          UARHourAccountingLine.SETRANGE("Service Order No.",gvOrder);
      END;
      IF UARHourAccountingLine.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := UARHourAccountingLine.COUNT;
        InitDoc;
        REPEAT
          IF (DocCode <> STRSUBSTNO(Text020 + ' (UAR) %1-%2',UARHourAccountingLine.Year,UARHourAccountingLine.Week))OR
             (YearNo <> UARHourAccountingLine.Year) OR
             (WeekNo <> UARHourAccountingLine.Week) OR
             (EmployeeNo <> UARHourAccountingLine."Employee No.")
          THEN BEGIN
            DocCode := STRSUBSTNO(Text020 + ' (UAR) %1-%2',UARHourAccountingLine.Year,UARHourAccountingLine.Week);
            YearNo := UARHourAccountingLine.Year;
            WeekNo := UARHourAccountingLine.Week;
            EmployeeNo := UARHourAccountingLine."Employee No.";
            ErrorTxt := STRSUBSTNO(Text021s,YearNo,WeekNo,EmployeeNo,UARHourAccountingLine.CURRENTCOMPANY);
            AddError(ErrorTxt,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL UARHourAccountingLine.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    LOCAL PROCEDURE CheckUnprocessedHoursSiteMgt@1100525015(VAR SiteMngmntHoursLine@1100528500 : Record 11012361);
    VAR
      YearNo@1100528503 : Integer;
      WeekNo@1100528502 : Integer;
      EmployeeNo@1100528501 : Code[20];
    BEGIN
      IF gvType = gvType::Project THEN BEGIN
        SiteMngmntHoursLine.SETRANGE(Type,SiteMngmntHoursLine.Type::Project);
        SiteMngmntHoursLine.SETRANGE("Object No.",gvProj);
      END;
      IF gvType = gvType::"Service Order" THEN BEGIN
        SiteMngmntHoursLine.SETRANGE(Type,SiteMngmntHoursLine.Type::Service);
        SiteMngmntHoursLine.SETRANGE("Object No.",gvOrder);
      END;
      SiteMngmntHoursLine.SETFILTER(
        Status,'%1|%2|%3|%4|%5',
        SiteMngmntHoursLine.Status::Approved,SiteMngmntHoursLine.Status::Open,SiteMngmntHoursLine.Status::"Pending Approval",
        SiteMngmntHoursLine.Status::Rejected,SiteMngmntHoursLine.Status::Released);
      IF SiteMngmntHoursLine.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := SiteMngmntHoursLine.COUNT;
        InitDoc;
        REPEAT
          IF (DocCode <> SiteMngmntHoursLine."Document No.") OR
             (YearNo <> SiteMngmntHoursLine.Year) OR
             (WeekNo <> SiteMngmntHoursLine.Week) OR
             (EmployeeNo <> SiteMngmntHoursLine."Employee No.")
          THEN BEGIN
            DocCode := SiteMngmntHoursLine."Document No.";
            YearNo := SiteMngmntHoursLine.Year;
            WeekNo := SiteMngmntHoursLine.Week;
            EmployeeNo := SiteMngmntHoursLine."Employee No.";
            ErrorTxt := STRSUBSTNO(Text021s,YearNo,WeekNo,EmployeeNo,SiteMngmntHoursLine.CURRENTCOMPANY);
            AddError(ErrorTxt,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL SiteMngmntHoursLine.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    LOCAL PROCEDURE CheckItemJnlLines@1100528206(VAR ItemJournalLine@1100528200 : Record 83);
    BEGIN
      CASE gvType OF
        gvType::Project:
          ItemJournalLine.SETRANGE("Job No.",gvProj);
        gvType::"Service Contract":
          BEGIN
            ItemJournalLine.SETRANGE("Service Contract No.",gvContr);
            ItemJournalLine.SETFILTER("Service Order No.", '%1', '');
          END;
        gvType::"Service Order":
          ItemJournalLine.SETRANGE("Service Order No.",gvOrder);
      END;
      IF ItemJournalLine.FINDSET THEN BEGIN
        LineCount := 1;
        NoOfRecords := ItemJournalLine.COUNT;
        InitDoc;
        REPEAT
          IF DocCode <> ItemJournalLine."Document No." THEN BEGIN
            DocCode := ItemJournalLine."Document No.";
            ErrorTxt := STRSUBSTNO(Text056, ItemJournalLine.CURRENTCOMPANY);
            AddError(ErrorTxt,DocCode);
          END;
          IF GUIALLOWED THEN
            Window.UPDATE(4,ROUND(LineCount / NoOfRecords * 10000,1));
          LineCount := LineCount + 1;
        UNTIL ItemJournalLine.NEXT = 0;
        IF GUIALLOWED THEN
          Window.UPDATE(4,0);
      END;
    END;

    [External]
    PROCEDURE ErrorsFound@1100528202() : Boolean;
    BEGIN
      WITH ErrorRec DO BEGIN
        RESET;
        SETRANGE("User ID", USERID);
        SETRANGE("Source Type", "Source Type"::"Finish Service-Project");
        CASE gvType OF
          gvType::Project:
            SETRANGE("Project No.", gvProj);
          gvType::"Service Contract":
            BEGIN
              SETRANGE("Service Contract No.", gvContr);
              IF gvContractControlPeriodCode <> '' THEN
                SETRANGE("Serv. Contr. Ctrl. Period Code", gvContractControlPeriodCode);
            END;
          gvType::"Service Order":
            BEGIN
              SETRANGE("Service Order No.", gvOrder);
              IF gvContractControlPeriodCode <> '' THEN BEGIN
                SETRANGE("Service Contract No.", gvContr);
                SETRANGE("Serv. Contr. Ctrl. Period Code", gvContractControlPeriodCode);
              END;
            END;
        END;
        EXIT(FINDFIRST);
      END;
    END;

    [External]
    PROCEDURE TableLocking@1100528203();
    BEGIN
      GenJnlLineRec.LOCKTABLE;
      GLEntry.LOCKTABLE;
      IF GLEntry.FINDLAST THEN;
    END;

    [External]
    PROCEDURE InitTemplateAndBatch@1100528204();
    BEGIN
      IF (NextLineNo = 0) THEN BEGIN
        IF gvType = gvType::Project THEN
          JnlTemplRec.GET(ProjSetup."Journal Template Closing Proc.")
        ELSE
          JnlTemplRec.GET(ServSetup."Journal Template Closing Proc.");
        JnlTemplRec.TESTFIELD("No. Series");
        ClearDocNoCde;
        NextLineNo := 10000;
        IF gvType = gvType::Project THEN BEGIN
          GenJnlLineRec.RESET;
          GenJnlLineRec.SETRANGE("Journal Template Name",ProjSetup."Journal Template Closing Proc.");
          GenJnlLineRec.SETRANGE("Journal Batch Name",ProjSetup."Journal Batch Closing Proc.");
          IF GenJnlLineRec.FINDLAST THEN
            NextLineNo := GenJnlLineRec."Line No." + 10000
        END;
        IF (gvType = gvType::"Service Contract") OR
           (gvType = gvType::"Service Order") THEN BEGIN
          GenJnlLineRec.RESET;
          GenJnlLineRec.SETRANGE("Journal Template Name",ServSetup."Journal Template Closing Proc.");
          GenJnlLineRec.SETRANGE("Journal Batch Name",ServSetup."Journal Batch Closing Proc.");
          IF GenJnlLineRec.FINDLAST THEN
            NextLineNo := GenJnlLineRec."Line No." + 10000
        END;
        GenJnlLineRec.RESET;
      END;
    END;

    [External]
    PROCEDURE DeleteTempGenJnlLines@1100528205();
    BEGIN
      TempGenJnlLineRec1.RESET;
      TempGenJnlLineRec1.DELETEALL;
      TempGenJnlLineRec2.RESET;
      TempGenJnlLineRec2.DELETEALL;
    END;

    [External]
    PROCEDURE CheckOpenPurchase@1100528600(IServiceOrderNo@1100528600 : Code[20]);
    BEGIN
      ClearErrors;
      gvType := gvType::"Service Order";
      gvOrder := IServiceOrderNo;
      OpenDialogWindow();
      PurchLineRec.RESET;
      PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Invoice);
      ErrorTxt := STRSUBSTNO(Text011,PurchLineRec.CURRENTCOMPANY);
      CheckPurchase;
      PurchLineRec.RESET;
      PurchLineRec.SETRANGE("Document Type",PurchLineRec."Document Type"::Order);
      CheckPurchaseInvoice();
      IF GUIALLOWED THEN
        Window.CLOSE;

      IF ErrorsFound THEN
        IF GUIALLOWED THEN
          IF CONFIRM(Text098) THEN BEGIN
            DisplayError;
            IF NOT CONFIRM(Text099) THEN
              ERROR('');
          END;
    END;

    LOCAL PROCEDURE ClearErrors@1100528601();
    BEGIN
      ErrorRec.RESET;
      ErrorRec.SETRANGE("User ID", USERID);
      ErrorRec.SETRANGE("Source Type", ErrorRec."Source Type"::"Finish Service-Project");
      IF NOT ErrorRec.ISEMPTY THEN
        ErrorRec.DELETEALL(TRUE);;
    END;

    [External]
    PROCEDURE SetCloseContract@1100529605(NewCloseContract@1100529600 : Boolean);
    BEGIN
      CloseContract := NewCloseContract;
    END;

    LOCAL PROCEDURE PostEntries@1100529608() : Boolean;
    BEGIN
      IF gPreview THEN
        EXIT(FALSE);
      CASE gvType OF
        gvType::Project:
          EXIT(TRUE);
        gvType::"Service Order":
          BEGIN
            IF ServOrderRec."Service Contract No." = '' THEN
              EXIT(TRUE);
            IF NOT ServContrRec.GET(ServOrderRec."Service Contract No.") THEN
              ServContrRec.INIT;
          END;
      END;
      IF NOT ServContrRec."Result Calc. on Total Contract" THEN
        EXIT(TRUE);
      EXIT(CloseContract);
    END;

    LOCAL PROCEDURE GetServiceContractCtrlPeriod@1100529613(VAR LocServiceContractCtrlPeriod@1100529600 : Record 11071746);
    BEGIN
      IF CloseServiceRestOfContract THEN
        LocServiceContractCtrlPeriod := RestOfContractServiceContractCtrlPeriod
      ELSE
        LocServiceContractCtrlPeriod.GET(gvContr, gvContractControlPeriodCode);
    END;

    LOCAL PROCEDURE UpdateServicePrognosisLine@1100529601(ServiceContractNo@1100529601 : Code[20];FilterByControlPeriod@1100529603 : Boolean;ControlPeriodCode@1100529602 : Code[10]);
    VAR
      ServicePrognosisLine@1100529600 : Record 11072310;
    BEGIN
      ServicePrognosisLine.SETRANGE("Service Contract No.", ServiceContractNo);
      IF FilterByControlPeriod THEN
        ServicePrognosisLine.SETRANGE("Control Period Code", ControlPeriodCode);
      IF ServicePrognosisLine.ISEMPTY THEN
        EXIT;
      ServicePrognosisLine.MODIFYALL("Control Period Finished", TRUE);
    END;

    [External]
    PROCEDURE SetCorrectOldPreclosureResult@1100529609(NewCorrectOldPreclosureResult@1100529600 : Boolean);
    BEGIN
      CorrectOldPreclosureResult := NewCorrectOldPreclosureResult;
    END;

    BEGIN
    {
      4PS03 JD 3-11-2008, Call 13101, WIP accounts are retrieved from wrong table
      4PS04 JD 8-12-2008, Call 13585, Determination of closing accounts goes wrong
      4PS05 JD 8-12-2008, Call C-014868, Close project not possible when intrest installments are generated
      4PS06 JD 28--7-2009, Call 16128, When loss is registered as a preclosure result, reversing the preclosure result goes wrong during
                                       closing the project.
      4PS07 JD 28--7-2009, Call 16107, When a preclosure result is posted for a project times things go wrong.
      4PS08 JD 26-09-2009, Call 16066, after discussion with Jim we decide that surcharge must be booked according vend.post.grp

      4PS09 JD 02-06-2010, Call 16501, the surcharge for Service must also be booked according vend.post.grp
      131126 ITERO.SB IME-072 Changed calculation of tot.amount to handle withheld prec. final installment
      150820 ITERO.DL SYM077

      170110 ITERO.WG Fix Symbrio readpermissions
      171211 ITERO.SB Pure 285498
    }
    END.
  }
}

